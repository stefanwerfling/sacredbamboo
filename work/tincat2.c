/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <math.h>
#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

#define __thiscall __cdecl // Test compile in C mode

__int16 __thiscall sub_10001000(int this, int a2, int a3, int a4, int a5, int a6);
int __thiscall sub_10001070(int this);
__int16 __thiscall sub_100010A0(_DWORD *this, _DWORD *Block, __int16 a3, int a4, WORD a5);
__int16 __thiscall sub_10001230(int **this);
__int16 __thiscall sub_10001260(int this);
int __thiscall sub_100012C0(char **this, unsigned int a2);
int __thiscall sub_10001660(int this, unsigned int a2, unsigned int a3, int a4);
void __thiscall sub_100016F0(int this);
int __thiscall sub_100017E0(void *this);
__int16 __cdecl sub_10001850(int a1, DWORD dwMilliseconds);
__int16 __cdecl sub_100019E0(HANDLE **Block);
__int16 __cdecl sub_10001A70(char *Format, int ArgList);
int __cdecl sub_10001AD0(int a1);
__int16 __cdecl sub_10001B80(char *Format);
__int16 __cdecl sub_10001BE0(char *Format);
__int16 __cdecl sub_10001C40(int a1, unsigned int a2, __int16 a3);
__int16 __cdecl sub_10001CC0(void *Block);
__int16 __cdecl sub_10001DC0(int *a1, int a2);
__int16 __cdecl sub_10001E40(int a1, int a2);
__int16 __cdecl sub_10001F30(int a1, HANDLE **Block);
void __stdcall __noreturn StartAddress(_DWORD *lpThreadParameter);
__int16 __cdecl sub_100022D0(int a1, void *Block);
void __stdcall __noreturn sub_10002360(_DWORD *lpThreadParameter);
int *__cdecl sub_10002610(__int16 a1, int a2);
void __stdcall __noreturn sub_100026E0(int *lpThreadParameter);
HANDLE **__cdecl sub_100028A0(int a1, int a2, __int16 a3);
HANDLE **__cdecl sub_10002940(int a1, int a2, __int16 a3);
_DWORD *__cdecl sub_100029E0(int a1, int a2, WORD a3, int a4, int a5, int a6, _BYTE *ArgList, _BYTE *a8, _BYTE *a9, const char *a10, const char *a11, const char *a12, __int16 a13, __int16 a14, int a15, int a16, int a17, int a18, int a19);
int sub_10003170();
int sub_10003180();
int sub_10003190();
int __cdecl sub_100031A0(int a1);
int __cdecl sub_100031F0(int a1);
_DWORD *sub_10003210(int a1, char *Format, ...);
char *sub_10003240();
int sub_10003280();
int __thiscall sub_100032B0(void *this);
_DWORD *__thiscall sub_10003300(_DWORD *this, char *Source, __int16 a3, int a4, int a5);
_DWORD *__thiscall sub_10003390(int this, int a2);
__int16 __thiscall sub_100033E0(int *this, int a2);
int __thiscall sub_10003430(void *this, int a2, int a3, _BYTE *a4, signed int a5);
int __thiscall sub_10003480(int *this);
int __thiscall sub_10003490(_DWORD *this);
int __thiscall sub_100034A0(int this, int a2);
_WORD *__thiscall sub_100034E0(_WORD *this, __int16 a2);
__int16 __thiscall sub_10003570(void *this);
void *__thiscall sub_100035A0(void *Block, char a2);
int __thiscall sub_100035F0(_DWORD *this, int a2);
__int16 __thiscall sub_10003600(_DWORD **this, int a2, __int16 a3);
__int16 __thiscall sub_10003650(_DWORD **this, void *Block, __int16 a3);
int (__thiscall ***__thiscall sub_100036B0(_DWORD *this, int a2))(_DWORD);
int __thiscall sub_10003710(_DWORD *this, int a2);
int __thiscall sub_10003720(void *this, int a2, int a3);
__int16 __thiscall sub_10003750(void *this, int a2, int a3);
int __thiscall sub_10003780(_DWORD *this);
int __thiscall sub_10003790(_DWORD *this);
int __thiscall sub_100037A0(void *this, int a2, int a3, int a4, int a5, int a6);
_DWORD *__thiscall sub_100037D0(int **this, char *Source, __int16 a3, int a4);
void __thiscall sub_10003860(_DWORD *this, _DWORD *Block);
void *__cdecl sub_10003890(const char *a1, const char *a2);
__int16 __cdecl sub_10003940(void **Block);
int __cdecl sub_10003980(int a1, int a2);
__int16 __cdecl sub_100039F0(int a1, _BYTE *a2);
_DWORD *__cdecl sub_10003A60(int a1, int a2);
__int16 __cdecl sub_10003A90(int a1, int a2, int a3, int a4, __int16 a5, void *Block, int a7);
__int16 __cdecl sub_10003B20(int a1, int a2, int a3, int a4, _BYTE *a5, signed int Size);
__int16 __cdecl sub_10003C10(int a1, int a2, int a3, int a4, int a5, _BYTE *a6, signed int Size);
__int16 __cdecl sub_10003D10(int a1, char *Source, int a3, int a4);
__int16 __cdecl sub_10003EA0(int a1, int a2);
__int16 __cdecl sub_10003F60(int a1, int a2, int Block, char *a4, int a5);
__int16 __cdecl sub_10003FC0(int a1, int a2);
int __cdecl sub_10004000(int *a1);
int __cdecl sub_10004080(int *a1);
__int16 __cdecl sub_10004110(int a1);
__int16 __cdecl sub_10004220(int a1, _DWORD *a2);
__int16 __cdecl sub_10004360(int a1, int a2);
int *__cdecl sub_10004380(int a1, char *Source, char *a3, u_short hostshort, char a5, char a6, char a7, char a8);
void *__cdecl sub_10004650(int a1, const char *a2, const char *a3, u_short hostshort, char a5, char a6, char a7, char a8);
int __cdecl sub_10004790(int a1);
__int16 __cdecl sub_10004AA0(char *Source, int a2);
__int16 __cdecl sub_10004BD0(int a1, int a2);
__int16 __cdecl sub_10004C10(_DWORD *a1, _BYTE *a2, int a3);
__int16 __cdecl sub_10004C80(int *a1, SOCKET *Block);
__int16 __cdecl sub_10004E10(int a1, int a2);
__int16 __cdecl sub_10004EA0(int a1, int a2);
__int16 __cdecl sub_10004ED0(int a1, _DWORD *a2);
__int16 __cdecl sub_10004F60(int a1, _DWORD *a2);
__int16 __cdecl sub_10004FC0(int a1, int a2);
int sub_10004FF0(); // weak
void __cdecl sub_10005010(int a1, _DWORD *a2);
__int16 __cdecl sub_10005120(int a1, _DWORD *a2);
__int16 __cdecl sub_10005480(int a1, int a2);
__int16 __cdecl sub_10005660(int a1, int a2);
__int16 __cdecl sub_100057D0(int a1, int a2);
__int16 __cdecl sub_10005940(int a1, int a2);
int __cdecl sub_100059F0(int *a1);
__int16 __cdecl sub_10005B50(int a1, int a2, int a3);
__int16 __cdecl sub_10005BE0(int a1, int a2);
int __cdecl sub_10005C60(int a1);
BOOL __cdecl sub_10005CC0(_BYTE *a1);
BOOL __cdecl sub_10005CE0(int a1, int a2);
__int16 __cdecl sub_10005D00(int a1, unsigned __int16 a2, int a3);
int __cdecl sub_10005D50(int a1, unsigned __int16 a2, int a3);
int __cdecl sub_10005D90(int a1, unsigned __int16 a2);
__int16 __cdecl sub_10005DD0(void *Block);
char *__cdecl sub_10005E10(int a1, char *Source, char *a3, int a4);
__int16 __cdecl sub_10005E90(int a1, unsigned int *a2);
int __cdecl sub_10005EF0(int a1, int a2);
int __cdecl sub_10005F70(int a1);
int *__cdecl sub_10005FA0(int a1, int a2, int a3);
__int16 __cdecl sub_10006200(int a1, int a2);
__int16 __cdecl sub_100062C0(int a1);
__int16 __cdecl sub_10006390(int a1, int a2);
int *__cdecl sub_100063C0(int a1, int a2);
int __cdecl sub_10006480(int a1, char *Source, char *a3); // idb
__int16 __cdecl sub_100064E0(int a1, int a2, char *Source, char *a4);
_DWORD *__cdecl sub_10006530(int a1, int a2);
__int16 __cdecl sub_10006630(int a1);
// void __thiscall Concurrency::details::_RefCounter::_Destroy(Concurrency::details::_RefCounter *__hidden this); idb
_DWORD *TinCat_CreateEasyCatServerAPI();
_DWORD *TinCat_CreateEasyCatClientAPI();
_WORD *__cdecl sub_10006750(char *a1, int a2, _DWORD *a3, __int16 a4, __int16 a5);
int __cdecl sub_100067C0(int a1, int a2, _DWORD *a3);
_WORD *__cdecl sub_100067E0(_DWORD *a1, __int16 a2, __int16 a3);
int __thiscall sub_10006810(int this);
__int16 __thiscall sub_10006850(_WORD *this);
_DWORD *__thiscall sub_10006880(_DWORD *this);
int __thiscall sub_100068A0(_DWORD *this);
int __thiscall sub_100068B0(_DWORD *this);
int __thiscall sub_100068C0(_DWORD *this, int a2);
int __thiscall sub_100068D0(_DWORD *this);
int __thiscall sub_100068E0(_DWORD *this);
int __thiscall sub_100068F0(_DWORD *this);
int __thiscall sub_10006900(_DWORD *this);
int __thiscall sub_10006910(_DWORD *this, int a2);
int __thiscall sub_10006920(_DWORD *this);
int __thiscall sub_10006930(_DWORD *this, int a2);
int __thiscall sub_10006940(_DWORD *this);
int __thiscall sub_10006950(_DWORD *this, int a2);
int __thiscall sub_10006960(_DWORD *this);
int __thiscall sub_10006970(_DWORD *this, int a2);
int __thiscall sub_10006980(_DWORD *this);
int __thiscall sub_10006990(_DWORD *this);
char *__thiscall sub_100069A0(char *this);
int __thiscall sub_100069B0(_DWORD *this);
int __thiscall sub_100069C0(_DWORD *this, int a2);
int __thiscall sub_100069D0(_DWORD *this);
int __thiscall sub_100069E0(_DWORD *this);
int __thiscall sub_100069F0(_DWORD *this);
_DWORD *__thiscall sub_10006A20(_DWORD *this);
int __stdcall sub_10006AD0(int a1);
int __thiscall sub_10006AE0(_DWORD *this, int a2);
int __thiscall sub_10006AF0(_DWORD *this);
int __thiscall sub_10006B00(unsigned __int16 *this);
int __thiscall sub_10006B10(_DWORD *this);
int __thiscall sub_10006B20(void *this);
int __thiscall sub_10006B30(void *this);
int __thiscall sub_10006B40(_DWORD *this);
__int16 sub_10006B50(int a1, char *Format, ...);
int __stdcall sub_10006BD0(char *a1, int a2);
void __thiscall sub_10006C50(_DWORD *this, unsigned __int16 a2);
void __thiscall sub_10006D30(_DWORD *this, unsigned __int16 a2);
char *__thiscall sub_10006E00(_DWORD *this, unsigned __int16 a2, int a3);
BOOL __thiscall sub_10006F30(_DWORD *this, unsigned int a2, unsigned int a3, int a4);
int __thiscall sub_10006F60(_DWORD *this);
int __thiscall sub_10006F80(_DWORD *this);
BOOL __thiscall sub_10006F90(_DWORD *this, char *Source, int a3);
BOOL __thiscall sub_10006FF0(_DWORD *this, const void *a2, unsigned int a3);
int __thiscall sub_10007060(int *this, int a2, _DWORD *a3);
int __thiscall sub_100072A0(void *this, char *name, int a3);
int __thiscall sub_100073C0(void *this, char *name, int a3);
BOOL __thiscall sub_100074C0(int *this, int a2);
int __thiscall sub_100074E0(unsigned __int16 *this, int a2, int a3);
int __thiscall sub_10007500(_DWORD *this, int a2, int a3, int a4);
int __thiscall sub_10007530(_DWORD *this, int a2, int a3, int a4, int a5);
_DWORD *__thiscall sub_10007570(_DWORD *this, int a2, int a3, int a4, int a5, __int16 a6, int a7, DWORD a8);
int TinCat_GetBuildNumber();
int sub_100076A0();
int __cdecl sub_100076B0(unsigned int ArgList);
_DWORD *TinCat_CreateAPI();
int __cdecl TinCat_Scramble(int a1, unsigned int a2, const char *a3, int a4);
int __thiscall sub_10007830(void *this);
int __thiscall sub_100078A0(void *this, int a2, int a3, unsigned int ArgList, int a5, int a6);
void __thiscall sub_10007BC0(int this);
int __thiscall sub_10007C60(int *this, int a2, int a3);
__int16 __thiscall sub_10007D10(int this);
__int16 __thiscall sub_10007D50(int *this, __int16 a2);
__int16 __thiscall sub_10007DD0(int *this);
int __thiscall sub_10007E40(int *this);
__int16 __thiscall sub_10007EB0(int *this, int a2);
int __thiscall sub_10007F20(void **this, const char *a2);
BOOL __thiscall sub_10007F90(int *this);
__int16 __thiscall sub_10008030(int this, int a2);
__int16 __thiscall sub_100080C0(int this, int a2);
__int16 __thiscall sub_10008160(int *this, int a2);
__int16 __thiscall sub_10008210(int this, int a2);
__int16 __thiscall sub_100082B0(int this, int a2);
__int16 __thiscall sub_10008350(int *this, int a2);
__int16 __thiscall sub_10008430(int this, int a2, int a3, int a4);
__int16 __thiscall sub_100084D0(int *this, int a2, int a3, int a4);
__int16 __thiscall sub_10008550(int *this, int a2, int a3, int a4, int a5, int a6);
__int16 __thiscall sub_100085D0(int *this, int a2, int a3, signed int ArgList);
__int16 __thiscall sub_10008780(int this, int a2);
__int16 __thiscall sub_10008830(int this, int a2);
__int16 __thiscall sub_100088E0(int this);
int __thiscall sub_10008980(int *this, char a2, char a3, char a4, char a5, int ArgList);
int __thiscall sub_10008B20(int *this, char a2, char a3, char a4, char a5, int ArgList);
int __thiscall sub_10008C30(int *this, int a2);
int __thiscall sub_10008CC0(int *this, int a2, unsigned __int16 a3, unsigned __int16 a4);
int __thiscall sub_10008E40(int *this, int a2, int a3, char *a4, int ArgList, int a6, int a7);
BOOL __thiscall sub_10009030(int *this, int a2, int a3, char *a4, int a5);
BOOL __thiscall sub_100090E0(int *this, int a2, int a3, char *Source);
int __thiscall sub_10009170(int *this, int a2);
// int __userpurge sub_10009300@<eax>(int *a1@<ecx>, int a2, unsigned __int16 (__thiscall **a3)(int, int *, int, int));
__int16 __thiscall sub_10009410(int *this);
__int16 __thiscall sub_100094C0(int this);
__int16 __thiscall sub_10009530(int this);
int __thiscall sub_100095A0(int *this, int a2);
__int16 __cdecl sub_10009620(int a1, int a2, int a3);
int __thiscall sub_10009650(int this, char *Source, __int16 a3, int a4, int a5);
__int16 __thiscall sub_10009720(int this, int a2, int a3, unsigned __int16 *a4, int a5);
int __thiscall sub_100098F0(int *this, const char *ArgList, int a3);
int __thiscall sub_100099C0(int *this, int a2, _DWORD *a3, _DWORD *a4, _DWORD *a5, _DWORD *a6);
int __thiscall sub_10009A40(int *this, int a2);
int __thiscall sub_10009AD0(int *this);
int __thiscall sub_10009BA0(int *this, int a2);
int __thiscall sub_10009C60(int *this, int a2);
int __thiscall sub_10009CF0(int *this, int a2, int a3);
int __thiscall sub_10009D50(int *this, int a2);
__int16 __thiscall sub_10009DB0(int *this, int a2);
int __thiscall sub_10009E20(int *this, int ArgList, const char *a3);
int __thiscall sub_10009F90(int *this, int a2);
__int16 __thiscall sub_1000A000(int *this, int a2);
int __thiscall sub_1000A060(int *this);
__int16 __thiscall sub_1000A0D0(int *this, unsigned int a2);
int __thiscall sub_1000A180(int *this);
int __thiscall sub_1000A1F0(_DWORD *this, unsigned int ArgList);
int __thiscall sub_1000A220(int this, int a2, int a3, int a4);
int __thiscall sub_1000A300(int this, int a2);
__int16 __thiscall sub_1000A6B0(int this, unsigned int a2);
__int16 __thiscall sub_1000A760(int this, unsigned int a2);
__int16 __thiscall sub_1000A810(int this, unsigned int a2);
int __thiscall sub_1000A8D0(void *this, unsigned __int16 a2, __int16 a3, int a4, int a5);
int TinCat_CreateTinCatValues();
_DWORD *__thiscall sub_1000A9B0(_DWORD *this);
int __thiscall sub_1000A9F0(int this);
int __thiscall sub_1000AA60(int this, __int16 a2, __int16 a3, int a4);
int __thiscall sub_1000AB00(char *this, char *Source);
int __thiscall sub_1000AB50(_DWORD *this, const void *a2);
int __thiscall sub_1000ABB0(_DWORD *this, int a2);
int __thiscall sub_1000ABE0(int this);
int __thiscall sub_1000AC60(int this);
int __thiscall sub_1000AEB0(_DWORD *this);
_DWORD *__thiscall sub_1000AEF0(_DWORD *this);
int __thiscall sub_1000AF10(_DWORD *this, int a2, LPCSTR lpPathName);
__int16 __cdecl sub_1000B080(char *a1);
int __thiscall sub_1000B0A0(int this);
_DWORD *__thiscall TinCatModules::Reconnector::operator=(_DWORD *this, _DWORD *a2);
// int __usercall sub_1000B150@<eax>(unsigned int a1@<eax>, int a2@<ecx>, int a3, const void *a4);
int __cdecl sub_1000B1F0(_DWORD *a1, int a2);
// _DWORD *__usercall sub_1000B2A0@<eax>(_DWORD *a1@<ebx>, int a2@<edi>);
// void *__usercall sub_1000B300@<eax>(_DWORD *a1@<edi>, int a2);
// void __usercall sub_1000B360(int a1@<ebx>, int a2@<edi>);
// int __usercall sub_1000B3A0@<eax>(int a1@<esi>, int a2);
// int *__usercall sub_1000B420@<eax>(int *a1@<esi>);
// int __usercall sub_1000B500@<eax>(int a1@<eax>);
unsigned int __thiscall TinCatModules::Reconnector::Init(TinCatModules::Reconnector *this, struct ITinCatAPI *a2, struct TinCatModules::IReconnectorCallbacks *a3); // idb
void __thiscall TinCatModules::Reconnector::Remove(TinCatModules::Reconnector *this); // idb
unsigned int __thiscall TinCatModules::Reconnector::HandleReceivedData(TinCatModules::Reconnector *this, unsigned int a2, unsigned int a3, unsigned __int16 a4, unsigned __int16 a5, char *a6, int a7);
unsigned int __thiscall TinCatModules::Reconnector::HandleAddedConnection(int **this, int a2);
BOOL __thiscall TinCatModules::Reconnector::HandleRemovedConnection(int **this, int a2);
int __thiscall TinCatModules::Reconnector::SetPreferredNextServer(int **this, unsigned int a2);
char *__thiscall TinCatModules::Reconnector::SetUserData(TinCatModules::Reconnector *this, int a2, void *a3, unsigned int a4);
_DWORD *__thiscall TinCatModules::Reconnector::GetUserData(TinCatModules::Reconnector *this, unsigned int a2);
TinCatModules::Reconnector *__thiscall TinCatModules::Reconnector::Reconnector(TinCatModules::Reconnector *this);
void __thiscall TinCatModules::Reconnector::~Reconnector(TinCatModules::Reconnector *this); // idb
int __cdecl sub_1000B9B0(int a1);
_DWORD *__cdecl sub_1000B9D0(_DWORD *a1, int a2);
int __cdecl sub_1000B9E0(int a1);
int __cdecl sub_1000B9F0(int a1, int a2);
int __cdecl sub_1000BA10(int a1, int a2, int a3, int a4);
// char *__stdcall inet_ntoa(struct in_addr in);
__int16 __cdecl sub_1000BA50(int a1);
__int16 sub_1000BAF0();
void *__cdecl sub_1000BB40(signed int Size);
__int16 __cdecl sub_1000BBF0(void *Block);
void __cdecl sub_1000BC60(_BYTE *a1, _BYTE *a2, int a3);
// __int16 __usercall sub_1000BC80@<ax>(int a1@<ebx>, char *a2, char a3, unsigned int a4);
__int16 __cdecl sub_1000BCB0(void *a1);
int __cdecl sub_1000BCE0(_BYTE *Block, int a2, char *a3, int a4, __int16 a5);
int __thiscall sub_1000BD50(char *this);
int __cdecl sub_1000BDF0(int (__cdecl *a1)(char *));
_DWORD *__cdecl sub_1000BEB0(int a1, _BYTE *a2, const char *a3);
_DWORD *__cdecl sub_1000C030(_DWORD *a1);
_BYTE *__cdecl sub_1000C040(_BYTE *a1, int a2);
int __cdecl sub_1000C150(int a1);
void sub_1000C160();
void sub_1000C170();
void sub_1000C180();
void sub_1000C190();
void __cdecl sub_1000C1A0(int a1);
void __cdecl sub_1000C290(int a1);
__int16 __cdecl sub_1000C300(void *Block);
__int16 __cdecl sub_1000C3D0(int a1, int a2, void *Buf);
void __cdecl sub_1000C4F0(int a1, int a2, const char *a3);
__int16 __cdecl sub_1000C580(int a1, int a2, char *a3);
__int16 __cdecl sub_1000C620(int a1, int a2, int a3, char *a4);
__int16 __cdecl sub_1000C6B0(int a1, int a2, char *a3);
__int16 __cdecl sub_1000C6D0(int a1, char *a2);
__int16 sub_1000C6F0(int a1, int a2, char *Format, ...);
__int16 sub_1000C720(char *Format, ...);
__int16 sub_1000C7C0(char *Format, ...);
_DWORD *sub_1000C860();
__int16 __cdecl sub_1000C8A0(HANDLE **Block);
__int16 __cdecl sub_1000C8D0(int a1, int a2, __int16 a3);
int __cdecl sub_1000C930(int a1, __int16 a2);
__int16 __cdecl sub_1000C990(int a1, int a2, int a3, char a4);
struct WSAData *__cdecl sub_1000CA10(WORD a1, int a2);
__int16 __cdecl sub_1000CA80(void *Block);
_DWORD *__cdecl sub_1000CAA0(int a1, int a2);
__int16 __cdecl sub_1000CAD0(void **Block);
__int16 __cdecl sub_1000CAF0(SOCKET s, char *buf, int a3, int len, int a5);
int __cdecl sub_1000CB50(SOCKET s, char *buf, int a3, int a4, int a5); // idb
__int16 __cdecl sub_1000CBC0(SOCKET *a1, int a2, int len, int a4);
void *__cdecl sub_1000CC50(SOCKET *a1, int a2, int a3);
__int16 __cdecl sub_1000CD60(SOCKET *Block);
SOCKET *__cdecl sub_1000CD90(u_short hostshort, int a2);
SOCKET *__cdecl sub_1000CF10(int addrlen, int a2, int a3);
int __cdecl sub_1000D010(SOCKET s, int a2); // idb
int __cdecl sub_1000D0A0(SOCKET s, int a2); // idb
int __cdecl sub_1000D130(SOCKET s, int a2, BOOL optval);
SOCKET *__cdecl sub_1000D1C0(u_short hostshort, char a2, char a3, char a4, char a5, int a6, int *a7);
__int16 __cdecl sub_1000D320(char *name, _DWORD *a2, _DWORD *a3, _DWORD *a4, _DWORD *a5);
__int16 __cdecl sub_1000D410(unsigned __int8 *a1, _DWORD *a2, _DWORD *a3, _DWORD *a4, _DWORD *a5);
__int16 __cdecl sub_1000D470(int a1);
char *__cdecl sub_1000D4B0(__int16 a1, __int16 a2, int a3);
__int16 __cdecl sub_1000D6B0(_DWORD *Block);
int __cdecl sub_1000D6E0(int a1, const void *a2, unsigned int a3);
int __cdecl sub_1000D7D0(int a1, const void *a2, unsigned int a3, _BYTE *a4);
int __cdecl sub_1000D850(int a1, char *a2, unsigned int *a3, _DWORD *a4);
SOCKET *__cdecl sub_1000D9E0(u_short hostshort, char a2, char a3, char a4, char a5, int a6, int a7, int *a8);
__int16 __cdecl sub_1000DBC0(char *Block, int a2, int a3);
void __cdecl sub_1000DDA0(DWORD dwMilliseconds);
// DWORD __stdcall GetTickCount();
__int16 __cdecl sub_1000DDC0(char *Buffer);
__int16 __cdecl sub_1000DDF0(char *Buffer);
int __cdecl sub_1000DE20(WORD *a1);
int __cdecl sub_1000DE90(WORD *a1, __int64 a2);
unsigned __int16 __cdecl sub_1000DF80(char *Buffer);
__int16 __cdecl sub_1000E050(int a1, __int16 a2);
__int16 __cdecl sub_1000E090(int a1, DWORD a2);
__int16 __cdecl sub_1000E0E0(int a1);
_DWORD *__cdecl sub_1000E120(__int16 a1);
__int16 __cdecl sub_1000E170(HANDLE *Block, __int16 a2);
int __cdecl sub_1000E1E0(HANDLE *Block);
_DWORD *__cdecl sub_1000E240(BOOL bManualReset, BOOL bInitialState);
__int16 __cdecl sub_1000E2A0(HANDLE *Block);
BOOL __cdecl sub_1000E2D0(HANDLE *a1);
BOOL __cdecl sub_1000E2F0(HANDLE *a1);
BOOL __cdecl sub_1000E310(HANDLE *a1);
__int16 __cdecl sub_1000E340(int a1, LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, __int16 a4, SIZE_T dwStackSize);
void __cdecl __noreturn sub_1000E3B0(int a1, DWORD dwExitCode); // idb
int __cdecl sub_1000E3E0(int a1, int a2);
__int16 __cdecl sub_1000E440(int a1);
_BOOL2 __cdecl sub_1000E460(int a1);
void sub_1000E480();
__int16 sub_1000E490();
__int16 __cdecl sub_1000E4F0(char *FileName, __int16 a2);
__int16 __cdecl sub_1000E620(__int16 a1);
__int16 __cdecl sub_1000E710(__int16 a1, void *DstBuf, unsigned int MaxCharCount);
__int16 __cdecl sub_1000E780(__int16 a1, void *Buf, unsigned int MaxCharCount);
_off_t __cdecl sub_1000E810(char *FileName);
int __cdecl sub_1000E8B0(LPCSTR lpExistingFileName, LPCSTR lpNewFileName); // idb
__int16 __cdecl sub_1000E8C0(int *a1);
void __cdecl sub_1000E930(char *Source, char *Destination, size_t Count);
int sub_1000E970();
int sub_1000E9A0();
__int16 __cdecl sub_1000E9D0(int a1);
int __cdecl sub_1000EA00(LPCSTR lpPathName); // idb
int __cdecl sub_1000EA10(int a1, int a2);
BOOL __cdecl sub_1000EA50(int a1, int a2, int a3);
// int __usercall sub_1000EA70@<eax>(int a1@<eax>, _DWORD *a2@<ecx>);
int __cdecl sub_1000EAC0(_DWORD *a1, int a2);
int __cdecl sub_1000EB20(int a1, int a2, int a3);
_DWORD *__cdecl sub_1000EB80(_DWORD *a1);
int __cdecl sub_1000EBC0(int a1);
int __cdecl sub_1000EBD0(int a1, int a2);
_DWORD *__cdecl sub_1000EC30(_DWORD *a1, int a2);
_DWORD *__cdecl sub_1000EC90(_DWORD *a1, int a2);
int __cdecl sub_1000ECF0(_DWORD *a1, int a2);
int __cdecl sub_1000ED40(_DWORD *a1, int a2);
int __cdecl sub_1000ED80(_DWORD *a1, int a2);
const char *__cdecl sub_1000EDB0(int a1, int a2);
BOOL __cdecl sub_1000EDD0(_DWORD *a1, int a2);
BOOL __cdecl sub_1000EE10(_DWORD *a1, int a2);
BOOL __cdecl sub_1000EE60(_DWORD *a1, int a2);
BOOL __cdecl sub_1000EEA0(_DWORD *a1, int a2, int a3);
int __cdecl sub_1000EF10(_DWORD *a1, int a2, int a3);
double __cdecl sub_1000EF80(_DWORD *a1, int a2);
BOOL __cdecl sub_1000EFD0(_DWORD *a1, int a2);
int __cdecl sub_1000F010(_DWORD *a1, int a2);
int __cdecl sub_1000F080(_DWORD *a1, int a2);
int __cdecl sub_1000F0E0(_DWORD *a1, int a2);
int __cdecl sub_1000F120(_DWORD *a1, int a2);
int __cdecl sub_1000F150(_DWORD *a1, int a2);
int __cdecl sub_1000F1C0(int a1);
int __cdecl sub_1000F1E0(int a1, double a2); // idb
int __cdecl sub_1000F200(_DWORD *a1, char *a2, unsigned int a3);
int __cdecl sub_1000F250(_DWORD *a1, char *a2);
int __cdecl sub_1000F2C0(_DWORD *a1, char *Str, int a3);
int __cdecl sub_1000F2F0(_DWORD *a1, char *Str, int a3);
int __cdecl sub_1000F320(_DWORD *a1, int a2, int a3);
__int64 __cdecl sub_1000F3B0(int a1, int a2);
int __cdecl sub_1000F3E0(_DWORD *a1, int a2);
int __cdecl sub_1000F430(_DWORD *a1, int a2);
int __cdecl sub_1000F480(_DWORD *a1, int a2, int a3);
int __cdecl sub_1000F4D0(_DWORD *a1);
int __cdecl sub_1000F510(_DWORD *a1, int a2);
int __cdecl sub_1000F580(_DWORD *a1, int a2);
int __cdecl sub_1000F5D0(_DWORD *a1, int a2);
int __cdecl sub_1000F610(_DWORD *a1, int a2);
int __cdecl sub_1000F670(_DWORD *a1, int a2, int a3);
int __cdecl sub_1000F6D0(_DWORD *a1, int a2);
int __cdecl sub_1000F740(_DWORD *a1, int a2);
char __cdecl sub_1000F7B0(int a1, int a2, int a3);
char __cdecl sub_1000F7D0(int a1, int a2);
int __cdecl sub_1000F7F0(_DWORD *a1, int a2, int a3, int a4);
int __cdecl sub_1000F860(_DWORD *a1, int a2, int a3, void *a4);
int __cdecl sub_1000F8B0(int a1, int a2, int a3);
int __cdecl sub_1000F900(int a1);
int __cdecl sub_1000F910(int a1);
char __cdecl sub_1000F920(_DWORD *a1, unsigned int a2);
void __cdecl __noreturn sub_1000F960(_DWORD *a1);
int __cdecl sub_1000F970(_DWORD *a1, int a2);
char __cdecl sub_1000F9C0(_DWORD *a1, int a2);
_DWORD *__cdecl sub_1000FA40(_DWORD *a1, int a2);
int __cdecl sub_1000FA90(_DWORD *a1);
int __cdecl sub_1000FB30(_DWORD *a1);
int __cdecl sub_1000FBC0(_DWORD *a1);
int __cdecl sub_1000FC00(_DWORD *a1);
int __cdecl sub_1000FC30(_DWORD *a1);
int __cdecl sub_1000FCD0(_DWORD *a1);
int __cdecl sub_1000FD70(_DWORD *a1);
void __cdecl sub_1000FE70(_DWORD *a1, int a2, int a3);
int __cdecl sub_10010260(_DWORD *a1);
int __cdecl sub_100102C0(_DWORD *a1);
int __cdecl sub_100102F0(_DWORD *a1);
int __cdecl sub_10010320(_DWORD *a1);
int __cdecl sub_10010350(_DWORD *a1);
int __cdecl sub_10010380(_DWORD *a1);
int __cdecl sub_100103B0(_DWORD *a1);
int __cdecl sub_100103E0(_DWORD *a1);
int __cdecl sub_10010410(_DWORD *a1);
int __cdecl sub_10010450(_DWORD *a1);
int __cdecl sub_10010480(_DWORD *a1);
int __cdecl sub_100104B0(_DWORD *a1);
int __cdecl sub_10010500(_DWORD *a1);
int __cdecl sub_10010530(_DWORD *a1);
int __cdecl sub_10010580(_DWORD *a1);
int __cdecl sub_100105B0(_DWORD *a1);
int __cdecl sub_100105E0(_DWORD *a1);
int __cdecl sub_10010620(_DWORD *a1);
int __cdecl sub_10010650(_DWORD *a1);
int __cdecl sub_10010680(_DWORD *a1);
int __cdecl sub_100106D0(_DWORD *a1);
int __cdecl sub_10010710(_DWORD *a1);
int __cdecl sub_10010790(_DWORD *a1);
int __cdecl sub_10010810(_DWORD *a1);
int __cdecl sub_10010940(_DWORD *a1);
int __cdecl sub_10010960(_DWORD *a1);
int __cdecl sub_100109A0(_DWORD *a1);
int __cdecl sub_10010A50(_DWORD *a1);
int __cdecl sub_10010AF0(_DWORD *a1);
int __cdecl sub_10010B90(_DWORD *a1);
int __cdecl sub_10010C10(_DWORD *a1);
int __cdecl sub_10010C90(_DWORD *a1);
int __cdecl sub_10010D40(int a1, _BYTE *a2, _BYTE *a3, int a4);
int __cdecl sub_10010D60(_DWORD *a1);
// char *__usercall sub_10010DD0@<eax>(char *a1@<eax>, int a2@<edi>);
// BOOL __usercall sub_10010E40@<eax>(int a1@<eax>, int a2@<edi>);
// BOOL __usercall sub_10010F50@<eax>(int a1@<eax>, int a2@<ebx>, unsigned int a3);
// char *__usercall sub_10010FF0@<eax>(char *a1@<eax>, _BYTE *a2@<ecx>, int a3@<ebx>);
// char *__usercall sub_10011060@<eax>(unsigned __int8 *a1@<eax>, int a2, unsigned __int8 *a3, int a4);
// char *__usercall sub_10011110@<eax>(char *a1@<eax>, int a2, unsigned __int8 *a3, int a4);
// char *__usercall sub_100111B0@<eax>(char *a1@<ebx>, int a2@<esi>, char *a3, int a4);
// char *__usercall sub_10011200@<eax>(char *a1@<ebx>, int a2@<esi>, char *a3);
// char *__usercall sub_10011260@<eax>(int a1@<eax>, int a2@<ecx>, char *a3@<ebx>);
char *__cdecl sub_100112B0(int a1, char *a2, char *a3);
// char *__usercall sub_10011570@<eax>(char *result@<eax>, unsigned int a2, char *a3, unsigned int a4);
// int __usercall sub_100115E0@<eax>(int a1@<eax>, _DWORD *a2@<esi>);
// int __usercall sub_10011650@<eax>(int a1@<eax>, char *a2@<ecx>, _DWORD *a3@<esi>);
int __cdecl sub_10011720(_DWORD *a1);
int __cdecl sub_10011900(_DWORD *a1);
int __cdecl sub_100119F0(_DWORD *a1);
// int __usercall sub_10011A40@<eax>(_DWORD *a1@<eax>, _DWORD *a2@<ebx>, char *a3, int a4);
int __cdecl sub_10011B70(_DWORD *a1);
// int __usercall sub_10011D40@<eax>(_DWORD *a1@<edx>, int a2@<ecx>, int *a3@<esi>);
// const char *__usercall sub_10011E90@<eax>(const char *a1@<ebx>, _DWORD *a2, _BYTE *a3, _DWORD *a4);
int __cdecl sub_10011F80(_DWORD *a1);
// int __usercall sub_10012220@<eax>(int a1@<eax>, int a2@<edi>, _DWORD *a3@<esi>);
int __cdecl sub_100122A0(_DWORD *a1);
// int __usercall sub_10012300@<eax>(int a1@<ebx>, _DWORD *a2@<edi>);
// int __usercall sub_10012340@<eax>(_DWORD *a1@<edi>);
int __cdecl sub_100123D0(_DWORD *a1);
int __cdecl sub_10012460(_DWORD *a1);
int __cdecl sub_100124A0(_DWORD *a1);
int __cdecl sub_10012530(_DWORD *a1);
void __cdecl __noreturn sub_10012600(_DWORD *a1);
int __cdecl sub_10012620(_DWORD *a1);
// int __usercall sub_100126A0@<eax>(_DWORD *a1@<eax>, char *a2, int a3);
int __cdecl sub_10012780(_DWORD *a1);
int __cdecl sub_100127A0(_DWORD *a1);
int __cdecl sub_100127C0(int a1);
// BOOL __usercall sub_10012800@<eax>(FILE *a1@<edi>, _DWORD *a2);
// BOOL __usercall sub_100128D0@<eax>(size_t a1@<eax>, FILE *a2@<ebx>, _DWORD *a3);
// int __usercall sub_10012970@<eax>(FILE *a1@<eax>, _DWORD *a2@<esi>, int a3);
int __cdecl sub_10012AF0(_DWORD *a1);
int __cdecl sub_10012B60(_DWORD *a1);
int __cdecl sub_10012BB0(_DWORD *a1);
// int __usercall sub_10012C30@<eax>(int a1@<eax>, _DWORD *a2@<edi>, FILE *Stream);
int __cdecl sub_10012D30(_DWORD *a1);
int __cdecl sub_10012DA0(_DWORD *a1);
int __cdecl sub_10012E00(_DWORD *a1);
int __cdecl sub_10012F10(_DWORD *a1);
int __cdecl sub_10012FD0(_DWORD *a1);
int __cdecl sub_10013070(_DWORD *a1);
int __cdecl sub_100130B0(_DWORD *a1);
int __cdecl sub_100130E0(_DWORD *a1);
int __cdecl sub_10013120(_DWORD *a1);
int __cdecl sub_10013170(_DWORD *a1);
int __cdecl sub_100131A0(int a1);
int __cdecl sub_100131D0(_DWORD *a1);
int __cdecl sub_10013460(_DWORD *a1);
int __cdecl sub_100136F0(_DWORD *a1);
int __cdecl sub_10013740(_DWORD *a1);
void __cdecl __noreturn sub_100137D0(_DWORD *a1);
int __cdecl sub_10013800(_DWORD *a1);
int __cdecl sub_10013880(_DWORD *a1);
int __cdecl sub_10013960(_DWORD *a1);
int __cdecl sub_10013A20(_DWORD *a1);
void __cdecl __noreturn sub_10013B50(_DWORD *a1);
int __cdecl sub_10013BD0(_DWORD *a1);
int __cdecl sub_10013C20(_DWORD *a1);
// int __usercall sub_10013CA0@<eax>(_DWORD *a1@<esi>);
int __cdecl sub_10013D50(_DWORD *a1);
int __cdecl sub_10013DA0(_DWORD *a1);
int __cdecl sub_10013E60(_DWORD *a1);
int __cdecl sub_10013E90(_DWORD *a1);
int __cdecl sub_10013EC0(_DWORD *a1);
int __cdecl sub_10013F00(int a1);
int __cdecl sub_10013F50(_DWORD *a1);
int __cdecl sub_10013F80(_DWORD *a1);
int __cdecl sub_10013FB0(_DWORD *a1);
int __cdecl sub_10013FF0(_DWORD *a1);
int __cdecl sub_10014030(_DWORD *a1);
int __cdecl sub_10014100(_DWORD *a1);
int __cdecl sub_10014160(_DWORD *a1);
int __cdecl sub_100141A0(_DWORD *a1);
int __cdecl sub_100141E0(_DWORD *a1);
int __cdecl sub_10014230(_DWORD *a1);
int __cdecl sub_10014280(_DWORD *a1);
int __cdecl sub_100142D0(_DWORD *a1);
int __cdecl sub_10014320(_DWORD *a1);
// char *__usercall sub_10014470@<eax>(_DWORD *a1@<esi>);
// char __usercall sub_100144C0@<al>(_DWORD *a1@<ebx>);
int __cdecl sub_10014530(_DWORD *a1);
// int __usercall sub_10014740@<eax>(int a1@<eax>, _DWORD *a2@<edi>, _DWORD *a3@<esi>);
int __cdecl sub_100147C0(_DWORD *a1);
int __cdecl sub_10014840(_DWORD *a1);
int __cdecl sub_100148A0(_DWORD *a1);
int __cdecl sub_10014900(_DWORD *a1);
int __cdecl sub_10014930(int a1);
int __cdecl sub_10014950(_DWORD *a1);
// _DWORD *__usercall sub_100149F0@<eax>(_DWORD *a1@<eax>, int a2@<esi>);
_DWORD *__cdecl sub_10014A80(_DWORD *a1);
void *__cdecl sub_10014B00(_DWORD *a1, int a2);
int __cdecl sub_10014B50(_DWORD *a1, int a2);
void __noreturn sub_10014BC0(_DWORD *a1, char *a2, ...);
int __cdecl sub_10014BF0(const char *a1, const char **a2);
int __cdecl sub_10014C50(_DWORD *a1, char *a2);
int __cdecl sub_10014C70(_DWORD *a1, int a2, const char *a3);
int __cdecl sub_10014D00(_DWORD *a1, int a2, const char *a3);
int __cdecl sub_10014D30(_DWORD *a1, int a2, char *a3);
int __cdecl sub_10014D90(_DWORD *a1, int a2, char *a3);
// int __usercall sub_10014DF0@<eax>(_DWORD *a1@<esi>);
int __cdecl sub_10014E70(_DWORD *a1, int a2, int a3);
int __cdecl sub_10014F40(_DWORD *a1, int a2);
int __cdecl sub_10015060(int a1);
int __cdecl sub_100150E0(int a1);
_BYTE *__cdecl sub_10015120(int a1, _BYTE *a2, _BYTE *a3);
char __cdecl sub_10015180(int a1);
int __cdecl sub_100151D0(int a1);
_DWORD *__cdecl sub_10015270(int a1, _DWORD *a2);
int __cdecl sub_10015290(int a1, FILE **a2, size_t *a3);
// int __usercall sub_100152D0@<eax>(int a1@<ebx>, _DWORD *a2@<edi>);
int __cdecl sub_10015310(_DWORD *a1, char *FileName);
int sub_100154C0(); // weak
int __cdecl sub_100154E0(_DWORD *a1, int a2, int a3, void *a4);
void __cdecl __noreturn sub_10015510(_DWORD *a1, int a2, const char *a3);
int __cdecl sub_100155B0(_DWORD *a1, int a2, int a3);
int __cdecl sub_10015600(_DWORD *a1, int a2);
int __cdecl sub_10015630(_DWORD *a1, int a2, int *a3);
int __cdecl sub_100156A0(_DWORD *a1, int a2, const char *a3, int *a4);
double __cdecl sub_10015700(_DWORD *a1, int a2);
double __cdecl sub_10015780(_DWORD *a1, int a2, double a3);
// _DWORD *__usercall sub_100157B0@<eax>(int a1@<eax>, _DWORD *a2@<ecx>, int a3@<edi>);
void __cdecl __noreturn sub_10015840(int a1, int a2);
int __cdecl sub_10015880(int a1, void (__cdecl *a2)(int, int), int a3);
_DWORD *__cdecl sub_10015960(_DWORD *a1, int a2);
char *__cdecl sub_100159B0(int a1, int a2);
_DWORD *__cdecl sub_10015A20(_DWORD *a1, int a2);
char __cdecl sub_10015AA0(int a1, int a2, int a3);
// int __usercall sub_10015B70@<eax>(int a1@<edx>, _DWORD *a2@<esi>, int a3);
// char *__usercall sub_10015CB0@<eax>(_DWORD *a1@<edi>, _DWORD *a2@<esi>);
int __cdecl sub_10015D40(int a1, char *a2);
// int __usercall sub_10015EE0@<eax>(int a1@<eax>, int a2@<esi>);
_DWORD *__cdecl sub_10015F40(int a1, int a2, int a3);
char __cdecl sub_10015FC0(int a1, char *a2, int a3);
double *__cdecl sub_10016040(_DWORD *a1, int *a2);
int __cdecl sub_10016100(int a1, int a2);
int __cdecl sub_100161D0(_DWORD *a1, int a2);
int __cdecl sub_10016260(_DWORD *a1, int a2, int a3);
char *__thiscall sub_100162E0(int this);
int sub_10016330(int a1, ...);
int __cdecl sub_10016390(int a1, void (__cdecl *a2)(int, int), int a3, int a4, int a5);
// int __usercall sub_10016440@<eax>(int result@<eax>, _DWORD *a2@<edx>);
int __cdecl sub_100164B0(int a1);
// int __usercall sub_10016540@<eax>(int a1@<edi>, _DWORD *a2);
// int __usercall sub_100166B0@<eax>(_DWORD *a1@<edx>, _DWORD *a2@<esi>);
// char __usercall sub_10016750@<al>(_DWORD *a1@<edx>, int a2@<edi>);
// int __usercall sub_100167F0@<eax>(int a1@<edi>, _DWORD *a2);
// char __usercall sub_100168E0@<al>(_DWORD *a1@<ebx>);
// int __usercall sub_10016960@<eax>(int result@<eax>);
// int __usercall sub_100169C0@<eax>(int result@<eax>);
// _BYTE *__usercall sub_10016A70@<eax>(_BYTE *result@<eax>, _DWORD *a2@<ecx>);
// int __usercall sub_10016B10@<eax>(_BYTE **a1@<eax>, _DWORD *a2@<ebx>, int a3);
// int __usercall sub_10016B50@<eax>(_DWORD *a1@<eax>, int a2@<edi>);
// int __usercall sub_10016B90@<eax>(_DWORD *a1@<eax>);
char __cdecl sub_10016C00(int a1);
// int __usercall sub_10016CF0@<eax>(int a1@<esi>, _DWORD *a2);
// int __usercall sub_10016D60@<eax>(int a1@<eax>);
char __cdecl sub_10016E30(_DWORD *a1);
int __cdecl sub_10016E80(int a1, int a2, char a3);
_DWORD *__cdecl sub_10016EB0(int a1, char a2, int a3);
_DWORD *__cdecl sub_10016EE0(int a1, _DWORD *a2, int a3);
_DWORD *__cdecl sub_10016F30(_DWORD *a1, int a2);
int __cdecl sub_10016F80(int a1, int a2);
// char __usercall sub_10016FF0@<al>(int a1@<edi>);
// int __usercall sub_100170B0@<eax>(int *a1@<eax>, _DWORD *a2@<edx>, _DWORD *a3@<ecx>, _DWORD *a4@<esi>);
// char __usercall sub_10017130@<al>(_DWORD *a1@<eax>, _DWORD *a2@<edx>, _DWORD *a3@<ecx>, _DWORD *a4@<esi>, _DWORD *a5);
// _DWORD *__usercall sub_100171D0@<eax>(_DWORD *a1@<eax>, _DWORD *a2@<ebx>, double *a3, int a4);
_DWORD *__cdecl sub_10017230(_DWORD *a1, _DWORD *a2, double *a3, int a4);
char __cdecl sub_100172A0(_DWORD *a1, _DWORD *a2, double *a3, _DWORD *a4);
// int __usercall sub_10017380@<eax>(int a1@<eax>, _DWORD *a2@<ecx>, _DWORD *a3@<edi>, _DWORD *a4, int a5);
// _DWORD *__usercall sub_100173F0@<eax>(int a1@<edi>, int a2@<esi>, int a3, int a4);
// int __usercall sub_10017470@<eax>(_DWORD *a1@<eax>, _DWORD *a2@<ebx>, _DWORD *a3, int a4);
// int __usercall sub_100174E0@<eax>(int a1@<eax>, int a2@<ecx>);
int __cdecl sub_10017550(_DWORD *a1, double *a2, double *a3);
// int __usercall sub_100175E0@<eax>(double *a1@<edi>, double *a2@<esi>, _DWORD *a3);
BOOL __cdecl sub_10017680(_DWORD *a1, double *a2, double *a3);
int __cdecl sub_10017760(_DWORD *a1, int a2, int a3);
// int *__usercall sub_100179E0@<eax>(int *a1@<eax>, _DWORD *a2@<edx>, int a3@<ecx>, _DWORD *a4, int a5);
_DWORD *__cdecl sub_10017BA0(_DWORD *a1, _DWORD *a2, double *a3, int a4);
double *__cdecl sub_10017C10(int a1);
int __cdecl sub_10018DA0(unsigned int a1);
int __cdecl sub_10018DC0(unsigned int a1);
BOOL __cdecl sub_10018E20(int a1, int a2);
int __cdecl sub_10018E70(char *String, double *a2);
// int __usercall sub_10018EE0@<eax>(char *a1@<edx>, _DWORD *a2@<esi>);
int __cdecl sub_10018F30(_DWORD *a1, char *Str, int a3);
int __cdecl sub_10019200(_DWORD *a1, char *Str, int a3);
char __cdecl sub_10019220(char *Destination, char *Source, size_t Count);
void *__cdecl sub_10019370(_DWORD *a1, int a2);
// _DWORD *__usercall sub_10019410@<eax>(int a1@<eax>, _DWORD *a2, const void *a3, unsigned int a4);
_DWORD *__cdecl sub_100194B0(int a1, char *a2, unsigned int a3);
_DWORD *__cdecl sub_10019540(_DWORD *a1, int a2);
_BYTE *__cdecl sub_10019580(_DWORD *a1, int a2);
_BYTE *__cdecl sub_100195C0(_DWORD *a1, int a2, _DWORD *a3);
_DWORD *__cdecl sub_10019620(_DWORD *a1, unsigned int a2);
_DWORD *__cdecl sub_10019670(int a1, unsigned int a2);
_DWORD *__cdecl sub_100196C0(_DWORD *a1);
void *__cdecl sub_10019720(_DWORD *a1, int a2);
void *__cdecl sub_100197C0(_DWORD *a1, _BYTE *a2);
int __cdecl sub_10019800(int a1, int a2, int a3);
// unsigned int __usercall sub_10019850@<eax>(int a1@<esi>, double a2);
unsigned int __cdecl sub_10019890(int a1, int a2);
// int __usercall sub_10019960@<eax>(int *a1@<edx>, int a2, int *a3, _DWORD *a4);
int __cdecl sub_100199F0(int a1, int *a2, _DWORD *a3);
// char *__usercall sub_10019B30@<eax>(int a1@<edi>, int a2@<esi>, _DWORD *a3);
// int __usercall sub_10019B80@<eax>(_DWORD *a1@<ebx>, int a2@<esi>, int a3);
_DWORD *__cdecl sub_10019C10(_DWORD *a1, int a2, int a3);
void *__cdecl sub_10019C70(_DWORD *a1, int a2);
// void *__usercall sub_10019CD0@<eax>(_DWORD *a1@<edi>, int a2);
void *__cdecl sub_10019D20(int a1, int a2);
_DWORD *__cdecl sub_10019DB0(int a1, int a2);
_DWORD *__cdecl sub_10019DF0(int a1, double *a2);
_DWORD *__cdecl sub_10019E50(_DWORD *a1, int a2, double *a3);
// unsigned int __usercall sub_10019EC0@<eax>(double *a1@<eax>, int a2@<edi>, _DWORD *a3);
int __cdecl sub_10019F50(_DWORD *a1, int a2, int a3);
void *__cdecl sub_1001A030(_DWORD *a1, int a2, int a3, int a4);
_DWORD *__cdecl sub_1001A2E0(_DWORD *a1, int a2, unsigned int a3);
_DWORD *__cdecl sub_1001A3D0(_DWORD *a1, int a2, int a3);
int __cdecl sub_1001A420(int a1);
int __cdecl sub_1001A460(int a1);
_DWORD *__cdecl sub_1001A4B0(_DWORD *a1, int a2, int a3, int a4);
unsigned int __cdecl sub_1001A4E0(int a1, char *a2, unsigned int a3);
void *__cdecl sub_1001A580(_DWORD *a1, void **a2, unsigned int a3);
// int __usercall sub_1001A5C0@<eax>(int a1@<eax>, int *a2@<esi>);
// int __usercall sub_1001A620@<eax>(_DWORD *a1@<esi>, int a2);
// int __usercall sub_1001A710@<eax>(int *a1@<esi>, int a2);
// int __usercall sub_1001A7B0@<eax>(int *a1@<esi>, _DWORD *a2);
int __cdecl sub_1001A8F0(int a1, int a2, int *a3);
// int __usercall sub_1001AA00@<eax>(_DWORD *a1@<esi>);
int __cdecl sub_1001AB20(int a1, int a2, int a3, int a4);
// int __usercall sub_1001AB60@<eax>(int a1@<eax>);
int __cdecl sub_1001ABA0(int a1);
int __cdecl sub_1001ABE0(int a1, int a2, int a3);
// char __usercall sub_1001AC60@<al>(int a1@<eax>, int a2@<ecx>);
// int __usercall sub_1001ACD0@<eax>(int a1@<eax>, int a2);
// int __usercall sub_1001AD30@<eax>(int a1@<esi>, int a2);
// BOOL __usercall sub_1001AD80@<eax>(int a1@<eax>, int a2@<edx>);
// BOOL __usercall sub_1001ADB0@<eax>(int a1@<eax>, int a2@<ecx>);
int __cdecl sub_1001ADE0(int a1, int a2, int a3);
int __cdecl sub_1001B1A0(int a1);
// void *__usercall sub_1001B1C0@<eax>(int a1@<eax>, int a2@<ecx>);
// const char *__usercall sub_1001B1F0@<eax>(int *a1@<ebx>, int a2, _DWORD *a3);
// const char *__usercall sub_1001B320@<eax>(int a1@<eax>, _DWORD *a2);
// int __usercall sub_1001B3A0@<eax>(_DWORD *a1@<edi>);
void __cdecl __noreturn sub_1001B420(_DWORD *a1);
void __cdecl __noreturn sub_1001B4B0(_DWORD *a1, char *Str, int a3);
// int __usercall sub_1001B4E0@<eax>(int a1@<ebx>, _DWORD *a2@<edi>, _DWORD *a3@<esi>, int a4, char *a5);
int __cdecl sub_1001B610(_DWORD *a1, char *Str, _DWORD *a3);
void __cdecl __noreturn sub_1001B6D0(_DWORD *a1, int a2, int a3);
void __cdecl __noreturn sub_1001B760(_DWORD *a1, _DWORD *a2, _DWORD *a3);
void __cdecl __noreturn sub_1001B780(_DWORD *a1, _DWORD *a2, int a3);
void __cdecl __noreturn sub_1001B7C0(_DWORD *a1, _DWORD *a2, _DWORD *a3);
void *__cdecl sub_1001B810(_DWORD *a1, void *Block, int a3, size_t Size);
void *__cdecl sub_1001B8A0(_DWORD *a1, void *a2, int *a3, int a4, int a5, char *Str);
// void __usercall __noreturn sub_1001B910(int a1@<eax>);
int __cdecl sub_1001B960(int a1, int a2);
int __cdecl sub_1001B990(int a1, int *a2, _DWORD *a3, int a4);
// int __usercall sub_1001BA30@<eax>(int a1@<esi>);
// int __usercall sub_1001BAD0@<eax>(int a1@<esi>, int a2, double *a3);
void __cdecl __noreturn sub_1001BE20(int a1);
int __cdecl sub_1001BEC0(int a1, int a2, int a3, int a4);
// int __usercall sub_1001BEF0@<eax>(int a1@<esi>);
// _DWORD *__usercall sub_1001BF50@<eax>(int a1@<eax>, _DWORD *a2);
// _DWORD *__usercall sub_1001C1F0@<eax>(int a1@<eax>, int a2, _DWORD *a3);
int __cdecl sub_1001C750(int a1, double *a2);
// _DWORD *__usercall sub_1001CDD0@<eax>(int a1@<eax>);
// _DWORD *__usercall sub_1001CE20@<eax>(int a1@<eax>, int a2@<edi>, int a3@<esi>, int a4);
// int __usercall sub_1001CE90@<eax>(int a1@<esi>);
// int __usercall sub_1001CF00@<eax>(int a1@<eax>, int a2@<ecx>, _DWORD *a3@<esi>);
int __cdecl sub_1001CF20(int a1);
// _DWORD *__usercall sub_1001CF80@<eax>(int a1@<eax>, int a2@<edx>);
// _DWORD *__usercall sub_1001CFC0@<eax>(int a1@<eax>, int a2@<edx>);
// int __usercall sub_1001D000@<eax>(char *a1@<edx>, int a2@<edi>, int a3);
// int __usercall sub_1001D060@<eax>(int *a1@<ebx>, int *a2@<edi>, int a3);
int __cdecl sub_1001D120(int *a1, int a2, int *a3, int a4);
// int *__usercall sub_1001D200@<eax>(int a1@<eax>, int a2@<edx>, int **a3@<ecx>, int a4);
// int __usercall sub_1001D280@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ebx>);
// char __usercall sub_1001D2F0@<al>(_DWORD *a1@<eax>, int a2@<ecx>, _DWORD *a3);
// _DWORD *__usercall sub_1001D3B0@<eax>(int a1@<edi>, _DWORD *a2@<esi>);
int __cdecl sub_1001D410(int a1);
// int __usercall sub_1001D520@<eax>(int a1@<eax>, _DWORD *a2@<ebx>);
// _DWORD *__usercall sub_1001D5C0@<eax>(int *a1@<ebx>, int a2@<esi>);
// int __usercall sub_1001D660@<eax>(int a1@<eax>, int a2);
// int __usercall sub_1001D760@<eax>(int *a1@<edi>, _DWORD *a2@<esi>);
// int __usercall sub_1001D7D0@<eax>(_DWORD *a1@<eax>, int a2@<ecx>);
// int __usercall sub_1001DA50@<eax>(int a1@<eax>);
// char __usercall sub_1001DBF0@<al>(int a1@<ebx>, _DWORD *a2, int a3, int a4);
// int __usercall sub_1001DD00@<eax>(int *a1@<ebx>, int a2@<esi>);
// int __usercall sub_1001DDA0@<eax>(_DWORD *a1@<eax>, _DWORD *a2);
// int *__usercall sub_1001DEE0@<eax>(_DWORD *a1@<eax>, int *a2@<ebx>);
// unsigned int __usercall sub_1001DF50@<eax>(int a1@<eax>, int *a2@<edi>);
// char __usercall sub_1001E180@<al>(int *a1@<eax>, int a2@<ecx>);
// int __usercall sub_1001E310@<eax>(int a1@<eax>);
int __cdecl sub_1001E4B0(int a1, int *a2, int a3);
// int __usercall sub_1001E5F0@<eax>(int a1@<eax>);
// _DWORD *__usercall sub_1001E680@<eax>(_DWORD *result@<eax>, int a2@<ecx>, int a3@<edi>);
int __cdecl sub_1001E6E0(int a1, _DWORD *a2, int a3);
int __cdecl sub_1001E810(int a1, int a2);
// int __usercall sub_1001EB70@<eax>(int a1@<eax>, int a2);
// int __usercall sub_1001ECB0@<eax>(int a1@<eax>, int a2@<ecx>, int a3, int a4, int a5);
// int __usercall sub_1001EE00@<eax>(int a1@<eax>, int a2, int a3);
// int __usercall sub_1001EF90@<eax>(int a1@<eax>, int a2);
// int __usercall sub_1001F1D0@<eax>(int a1@<eax>, int a2);
// int __usercall sub_1001F2F0@<eax>(int *a1@<ebx>, int a2@<esi>);
// _DWORD *__usercall sub_1001F3C0@<eax>(int a1@<eax>, int a2);
// int __usercall sub_1001F490@<eax>(int a1@<eax>);
// _DWORD *__usercall sub_1001F540@<eax>(int a1@<eax>);
// int __usercall sub_1001F6D0@<eax>(int *a1@<eax>, int a2@<ecx>);
// int __usercall sub_1001F730@<eax>(int a1@<eax>, int a2@<esi>);
// int *__usercall sub_1001F7C0@<eax>(int a1@<esi>);
// int __usercall sub_1001F810@<eax>(int a1@<eax>);
// int __usercall sub_1001F940@<eax>(int a1@<edi>);
// int __usercall sub_1001F9F0@<eax>(int a1@<ebx>);
int __cdecl sub_1001FB20(int a1);
int __cdecl sub_1001FC00(int a1, _DWORD *a2, int a3);
// unsigned int __usercall sub_1001FCF0@<eax>(unsigned int result@<eax>, char *a2@<ecx>, _DWORD **a3@<esi>);
// unsigned int __usercall sub_1001FD80@<eax>(unsigned int result@<eax>, char *a2@<ecx>, _DWORD **a3@<esi>, int a4);
// _DWORD *__usercall sub_1001FE60@<eax>(_DWORD **a1@<eax>);
// unsigned int __usercall sub_1001FED0@<eax>(_DWORD **a1@<eax>, int a2@<ebx>);
// void *__usercall sub_1001FF30@<eax>(_DWORD **a1@<eax>, int a2@<ebx>);
// unsigned int __usercall sub_10020020@<eax>(_DWORD **a1@<eax>, int a2@<ebx>);
// void *__usercall sub_10020080@<eax>(_DWORD **a1@<eax>, int a2);
// void *__usercall sub_10020120@<eax>(_DWORD **a1@<eax>, int a2);
_DWORD *__cdecl sub_100202D0(_DWORD **a1, int a2);
// char __usercall sub_10020490@<al>(_DWORD **a1@<esi>);
// int __usercall sub_10020510@<eax>(int a1@<edi>, _DWORD **a2@<esi>);
int sub_10020580();
// unsigned __int64 __usercall sub_10020590@<edx:eax>(_DWORD **a1@<eax>);
_DWORD *__cdecl sub_10020740(_DWORD *a1, _DWORD *a2, _DWORD *a3);
// int __usercall sub_100207A0@<eax>(int a1@<eax>, int a2@<ecx>, int *a3@<ebx>);
int __cdecl sub_100207F0(int a1);
// int __usercall sub_10020800@<eax>(int a1@<eax>, int a2@<ecx>, int a3);
// void __usercall sub_10020880(int a1@<edx>, int *a2@<ebx>, int a3, int a4, int a5, int a6, int a7);
int __cdecl sub_100209C0(int *a1, int *a2, int a3);
int __cdecl sub_10020A10(int *a1, int a2);
int __cdecl sub_10020A50(int *a1, int a2);
// int __usercall sub_10020AA0@<eax>(_DWORD *a1@<edi>, int *a2@<esi>, double *a3);
int __cdecl sub_10020B40(int *a1, int a2);
int __cdecl sub_10020B70(int *a1, double a2);
// int __usercall sub_10020BA0@<eax>(int *a1@<eax>);
int *__cdecl sub_10020BE0(int a1, _DWORD *a2, int a3);
// int __usercall sub_10020C40@<eax>(int a1@<eax>, int a2@<ecx>);
int __cdecl sub_10020C90(_DWORD *a1, int a2);
int __cdecl sub_10020CB0(int a1, int a2, int a3);
int __cdecl sub_10020D60(int a1, int a2, int a3, int a4, int a5);
int __cdecl sub_10020DA0(int a1, int a2, int a3, int a4);
int __cdecl sub_10020DD0(_DWORD *a1, int a2, int a3);
int __cdecl sub_10020E60(int a1);
// int __usercall sub_10020EA0@<eax>(int a1@<eax>, int *a2@<esi>, int a3, int a4, int a5);
int __cdecl sub_10020F00(int *a1, int a2);
int *__cdecl sub_10020F20(int a1, _DWORD *a2);
// int *__usercall sub_10020FF0@<eax>(int a1@<ebx>, _DWORD *a2@<edi>, int a3@<esi>);
// int *__usercall sub_100210E0@<eax>(int *result@<eax>, _DWORD *a2);
// int __usercall sub_10021140@<eax>(int *a1@<eax>, _DWORD *a2, int a3);
int __cdecl sub_10021270(int *a1, _DWORD *a2);
int __cdecl sub_100212F0(int *a1, _DWORD *a2);
int *__cdecl sub_10021340(int *a1, _DWORD *a2);
int __cdecl sub_10021360(int *a1, _DWORD *a2);
int __cdecl sub_100213E0(int *a1, _DWORD *a2, _DWORD *a3);
int __cdecl sub_100214C0(int *a1, _DWORD *a2, int *a3);
// int __usercall sub_100215B0@<eax>(int *a1@<eax>, int a2@<ebx>, _DWORD *a3@<edi>);
int __cdecl sub_10021630(int *a1, _DWORD *a2);
int __cdecl sub_100216E0(int *a1, _DWORD *a2);
// int __usercall sub_10021790@<eax>(int *a1@<edi>, _DWORD *a2@<esi>);
int __cdecl sub_10021860(int *a1, _DWORD *a2, _DWORD *a3);
int __cdecl sub_10021880(int *a1, int a2, _DWORD *a3);
int __cdecl sub_10021940(int *a1, int a2, _DWORD *a3);
// int __usercall sub_100219E0@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>, _DWORD *a4@<edi>, int *a5);
int __cdecl sub_10021A50(int *a1, int a2, int *a3, int *a4);
void __cdecl sub_10021C50(int *a1, int a2, int a3);
bool __stdcall sub_10021CA0(int a1);
int __stdcall sub_10021CF0(int a1, char a2, int *a3);
int __stdcall sub_10021E50(int a1);
BOOL __thiscall sub_10021EA0(_DWORD *this, _DWORD *a2);
_DWORD *__thiscall sub_10021EE0(_DWORD *this);
DWORD __thiscall sub_10021F00(_DWORD *this, int a2);
int __thiscall sub_10021F20(int *this);
bool __thiscall sub_10021F40(_DWORD *this, unsigned int a2);
int __thiscall sub_10021F70(float *this);
void __thiscall sub_10021FE0(_DWORD *this);
__int64 __thiscall sub_10021FF0(unsigned __int16 *this);
int __thiscall sub_100220A0(WORD *this);
int __thiscall sub_100220B0(WORD *this, unsigned int a2);
int __thiscall sub_100220E0(WORD *this, unsigned int a2);
int __thiscall sub_10022110(WORD *this, int a2);
int __thiscall sub_10022140(WORD *this, int a2);
_DWORD *__thiscall sub_10022170(_DWORD *this);
_DWORD *__thiscall sub_10022230(_DWORD *this, int a2, int a3);
char __thiscall sub_100222F0(int *this, int a2, int a3, int a4);
char __thiscall sub_10022430(_DWORD *this, int *a2, int *a3, int *a4, int *a5);
int __thiscall sub_10022500(int *this);
int __stdcall sub_10022580(int a1, int *a2);
int __thiscall sub_100226A0(_DWORD *this, int a2);
_DWORD *__thiscall sub_10022710(_DWORD *this, _DWORD *a2, _DWORD *a3);
int __thiscall sub_10022750(int this);
WORD *__thiscall sub_100227B0(WORD *this);
char *__thiscall sub_100227F0(_DWORD *this, char *Buffer);
bool __thiscall sub_10022850(int *this, int a2, int *a3, int *a4);
char *__thiscall sub_100228F0(int *this, char *Buffer);
_DWORD *sub_100229A0();
__int16 __cdecl sub_10022A00(int *Block, char a2);
__int16 __cdecl sub_10022A90(_DWORD *a1, int a2, int a3);
int __cdecl sub_10022B10(int a1, _DWORD *a2);
int __cdecl sub_10022B70(int a1);
_DWORD *__cdecl sub_10022BB0(unsigned __int16 a1, int a2);
__int16 __cdecl sub_10022C80(int a1, void *Block, __int16 a3);
__int16 __cdecl sub_10022D20(int a1, int a2, int a3);
__int16 __cdecl sub_10022E20(int a1, int (__cdecl *a2)(_DWORD, int), int a3);
__int16 __cdecl sub_10022EA0(void *Block, __int16 a2);
int __cdecl sub_10022F30(int a1, int a2, int a3, int a4, char a5, int a6, int a7);
_DWORD *__cdecl sub_10023060(int a1);
__int16 __cdecl sub_100230C0(void **Block);
int __cdecl sub_100230E0(int *a1);
unsigned int __cdecl sub_10023110(_DWORD *a1, unsigned int a2);
DNameNode *__thiscall sub_10023130(DNameNode *this);
int __thiscall sub_10023170(_DWORD *this, int a2);
int __thiscall sub_100231C0(_DWORD *this, int a2);
int __thiscall sub_10023200(_DWORD *this, unsigned int a2);
int __thiscall sub_10023280(void *this);
int __thiscall sub_10023290(_DWORD *this);
int __thiscall sub_100232A0(_DWORD *this, unsigned int a2);
int __thiscall sub_100232F0(_DWORD *this, unsigned int a2);
int __thiscall sub_10023340(void *this);
int __thiscall sub_100233B0(_DWORD **this);
int __thiscall sub_100233C0(_DWORD *this);
int __thiscall sub_100233E0(_DWORD *this, int a2);
int __thiscall sub_10023410(_DWORD *this);
int __thiscall sub_10023420(void *this, int a2, int a3);
int __thiscall sub_10023450(void *this, int a2, int a3);
int __thiscall sub_10023480(void *this, int a2, int a3);
int __thiscall sub_100234B0(void *this, int a2);
BOOL __thiscall sub_100234E0(_DWORD *this, int a2);
int __thiscall sub_10023510(void *this, int a2);
int __thiscall sub_10023540(_DWORD *this, unsigned int a2);
BOOL __stdcall sub_10023590(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved);
// BOOL __stdcall DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved);
int __thiscall sub_100235E0(_DWORD *this, int a2);
int __thiscall sub_10023630(_DWORD *this, int a2);
int __thiscall sub_10023690(_DWORD *this, int a2);
int __thiscall sub_10023700(_DWORD *this, int a2);
int __thiscall sub_10023760(_DWORD *this, int a2);
int __thiscall sub_100237F0(_DWORD *this, int a2);
int __thiscall sub_100238A0(DWORD *this, int a2, DWORD a3);
_DWORD *__thiscall sub_100239D0(_DWORD *Block, char a2);
int __thiscall sub_10023A00(DWORD *this, int a2);
int __thiscall sub_10023A20(DWORD *this, int a2);
int __thiscall sub_10023A40(DWORD *this, int a2, DWORD a3);
int __thiscall sub_10023A90(DWORD *this, int a2, int a3);
int __thiscall sub_10023AE0(DWORD *this, int a2, DWORD a3);
__int16 __thiscall sub_10023B50(_DWORD *this, int a2, int a3);
__int16 __thiscall sub_10023C30(_DWORD *this, int a2);
void __stdcall sub_10023CB0(void *Block);
void __thiscall sub_10023D70(void *this);
_DWORD *__thiscall sub_10023E00(_DWORD *this);
void __thiscall sub_10023E20(_DWORD *this);
char __stdcall sub_10023E30(int a1);
_DWORD *__thiscall sub_10023E40(_DWORD *this);
int __thiscall sub_10023E50(_DWORD *this, int a2);
int __thiscall sub_10023E90(int *this);
int __thiscall sub_10023EA0(_DWORD *this);
int __thiscall sub_10023EC0(_DWORD *this);
int __thiscall sub_10023ED0(_DWORD *this, int a2);
void *__cdecl sub_10023F30(char *ArgList, void *Block, unsigned int *a3);
unsigned int __cdecl sub_10024020(char *ArgList, void *Buf, unsigned int MaxCharCount);
char *__cdecl sub_10024090(const char *a1, const char *a2);
int __thiscall sub_10024100(_DWORD *this, int a2);
int __thiscall sub_10024120(_DWORD **this, int a2);
int __thiscall sub_10024140(_DWORD **this, int a2);
int __thiscall sub_10024160(_DWORD *this, unsigned int a2);
int __thiscall sub_100241E0(_DWORD **this);
int __thiscall sub_10024200(_DWORD **this);
int __thiscall sub_10024220(_DWORD **this);
int __thiscall sub_10024240(_DWORD **this);
int __thiscall sub_10024260(_DWORD *this);
int __thiscall sub_10024270(_DWORD **this);
int __thiscall sub_10024290(_DWORD *this, _DWORD *a2);
unsigned int __thiscall sub_100242D0(_DWORD *this, int a2);
unsigned int __thiscall sub_100242F0(_DWORD *this, int a2);
int __thiscall sub_10024310(_DWORD *this, int a2);
_DWORD *__thiscall sub_10024350(_DWORD *this, _DWORD *a2);
int __thiscall sub_100243A0(_DWORD *this);
int __thiscall sub_10024420(unsigned __int8 *this, char *Buffer);
void __thiscall sub_10024450(int this);
void __thiscall sub_10024480(int this, char *Source, signed int Count);
char *__thiscall sub_10024540(int this, char *Source, unsigned int a3);
void *__thiscall sub_10024620(void *this, char *a2);
void *__thiscall sub_10024640(void *this, char *a2);
_DWORD *__thiscall sub_10024660(_DWORD *this);
int __cdecl sub_10024690(_DWORD *a1, int a2, int a3);
int __cdecl sub_10024740(_DWORD *a1, int a2);
int __cdecl sub_10024790(_DWORD *a1);
_DWORD *__cdecl sub_10024800(int a1);
int __cdecl sub_100248C0(void *Block, int a2); // idb
int __cdecl sub_10024940(_DWORD *a1, int a2, int a3);
int __cdecl sub_10024A10(void *Block); // idb
int __cdecl sub_10024A20(_DWORD *a1, int a2);
// _BYTE *__usercall sub_10024A40@<eax>(_BYTE *a1@<eax>);
// const char *__usercall sub_10024A80@<eax>(const char *a1@<edi>);
// _BYTE *__usercall sub_10024AC0@<eax>(_BYTE *a1@<eax>);
// char __usercall sub_10024AF0@<al>(_BYTE *a1@<eax>);
int __cdecl sub_10024B30(int a1);
// _DWORD *__usercall sub_10024B40@<eax>(const char *a1@<edi>);
// _DWORD *__usercall sub_10024BB0@<eax>(const char *a1@<ebx>, const char *a2@<edi>);
int sub_10024C40(); // weak
void __cdecl sub_10024C80(void **Block);
int __cdecl sub_10024CC0(_DWORD *a1, char *FileName);
void __cdecl sub_10024E20(_DWORD *Block);
_DWORD *sub_10024E50();
_DWORD *__cdecl sub_10024E90(char *a1);
int __cdecl sub_10024F00(_DWORD *a1, const char *a2, const char *a3);
DNameNode *__thiscall sub_10024FE0(DNameNode *this);
int __thiscall sub_100250A0(_DWORD *this, int a2);
int __thiscall sub_10025100(_DWORD *this, int a2, unsigned int a3);
int __thiscall sub_10025130(_DWORD *this, int a2, unsigned int a3);
int __thiscall sub_10025160(_DWORD *this, int a2);
int __thiscall sub_100251C0(_DWORD *this, int a2);
int __thiscall sub_10025220(_DWORD *this);
int __thiscall sub_10025230(_DWORD *this);
int __thiscall sub_10025240(_DWORD *this);
int __thiscall sub_10025250(_DWORD *this, int a2, int a3);
int __thiscall sub_10025300(_DWORD *this, int a2, int a3);
int __stdcall sub_100253B0(int a1, int a2);
BOOL __thiscall sub_100253F0(_DWORD *this, int a2);
int __thiscall sub_10025420(_DWORD *this, int a2);
int __thiscall sub_10025480(_DWORD *this, int a2);
int __thiscall sub_100254E0(_DWORD *this, int a2);
int __thiscall sub_10025560(_DWORD *this, int a2);
int __stdcall sub_100255E0(int a1);
int __stdcall sub_10025610(int a1);
int __stdcall sub_10025650(int a1);
int __thiscall sub_10025690(_DWORD *this, _DWORD *Block);
int __thiscall sub_100256F0(int *this, int a2, unsigned int a3);
int __thiscall sub_10025740(_DWORD *this, unsigned int a2);
int __thiscall sub_100257A0(_DWORD *this);
int __thiscall sub_100257C0(_DWORD *this);
int __thiscall sub_100257F0(_DWORD *this, unsigned int a2);
int __thiscall sub_100258B0(_DWORD *this, unsigned int a2);
int __thiscall sub_10025970(_DWORD *this);
int __thiscall sub_100259E0(int *this, unsigned int a2);
int __thiscall sub_10025A20(_DWORD *this, int a2);
int __thiscall sub_10025A80(_DWORD *this, int a2);
int __thiscall sub_10025AE0(_DWORD *this, int a2);
int __thiscall sub_10025B40(_DWORD *this);
_DWORD *__thiscall sub_10025B70(_DWORD *Block, char a2);
// DNameNode *__thiscall DNameNode::DNameNode(DNameNode *__hidden this); idb
int __stdcall sub_10025BC0(int a1);
int __stdcall sub_10025BD0(int a1, int a2);
int sub_10025BE0();
int __stdcall sub_10025BF0(int a1);
int __thiscall sub_10025C00(_DWORD *this);
_DWORD *__thiscall sub_10025C30(_DWORD *this, int a2);
int __thiscall sub_10025C60(_DWORD *this, int a2);
int __stdcall sub_10025CA0(int a1);
int __stdcall sub_10025CC0(int a1);
unsigned int __thiscall sub_10025CE0(_DWORD *this, int a2);
unsigned int __thiscall sub_10025D10(_DWORD *this, int a2);
int __thiscall sub_10025D40(_DWORD *this, int a2);
_DWORD *__thiscall sub_10025D70(_DWORD *Block, char a2);
_DWORD *__cdecl sub_10025DB0(unsigned int a1, int a2, int a3, int a4);
void __cdecl sub_10025E50(void *Block, int a2);
int __cdecl sub_10025EA0(int a1, int a2);
int __cdecl sub_10025EF0(int a1, int a2);
int __cdecl sub_10025F60(int a1, int a2);
unsigned int __cdecl sub_10025FD0(int a1, void (__cdecl *a2)(int, int, int), int a3);
int __cdecl sub_10026040(int a1, int a2, int a3);
int __cdecl sub_10026060(int a1);
int __cdecl sub_100260C0(int a1);
void *__cdecl sub_100260D0(FILE *Stream);
void __cdecl __noreturn sub_100261C0(int a1, int a2);
int nullsub_1(const char *, ...); // weak
// int __usercall sub_10026200@<eax>(int *a1@<esi>);
_DWORD *sub_100262A0();
void __cdecl sub_100262F0(void *Block, void (__cdecl *a2)(_DWORD));
int __cdecl sub_10026350(int *a1, int a2);
int __cdecl sub_10026390(int *a1, int a2, int a3);
int __cdecl sub_100263D0(int *a1, int a2, int a3);
int __cdecl sub_10026460(int *a1, int a2);
int __cdecl sub_10026480(int *a1, int a2);
int __cdecl sub_100264B0(int *a1, int (__cdecl *a2)(_DWORD, int), int a3);
int __cdecl sub_100264F0(int *a1, int a2);
int __cdecl sub_10026550(int *a1, int a2);
int __cdecl sub_10026590(int *a1, int (__cdecl *a2)(_DWORD, int), int a3);
int __cdecl sub_100265C0(int a1, _CoreCrtNonSecureSearchSortCompareFunction CompareFunction); // idb
int *__cdecl sub_100265E0(int *a1, int *a2, int (__cdecl *a3)(_DWORD, int));
int __cdecl sub_10026680(_DWORD *a1, int (__cdecl *a2)(_DWORD, int), int a3);
int *__cdecl sub_100266E0(const char *a1, char a2);
void __cdecl j__free(void *Block);
// void *__cdecl operator new(unsigned int); idb
// int sprintf(char *const Buffer, const char *const Format, ...);
// int __cdecl vsprintf(char *const Buffer, const char *const Format, va_list ArgList);
// char *__cdecl strncpy(char *Destination, const char *Source, size_t Count);
// int *__cdecl _errno();
// _DWORD __cdecl _dosmaperr(_DWORD); weak
// int __cdecl atol(const char *String);
int __cdecl j__atol(const char *String);
// int __cdecl strncmp(const char *Str1, const char *Str2, size_t MaxCount);
// void *__cdecl malloc(size_t Size);
// void __cdecl free(void *Block);
// int printf(const char *const Format, ...);
// void __cdecl srand(unsigned int Seed);
// int __cdecl rand();
// char *__cdecl _strtime(char *Buffer);
// char *__cdecl _strdate(char *Buffer);
// __time32_t __cdecl time(__time32_t *const Time);
// int __cdecl _read(int FileHandle, void *DstBuf, unsigned int MaxCharCount);
int __cdecl sub_1002740A(LPCSTR lpFileName); // idb
int __cdecl sub_10027434(char *FileName, int a2, int ShareFlag); // idb
int __cdecl sub_10027490(char *FileName, int a2); // idb
// int __cdecl fclose(FILE *Stream);
// char *__cdecl fgets(char *Buffer, int MaxCount, FILE *Stream);
// int __cdecl fputs(const char *Buffer, FILE *Stream);
int __cdecl sub_10027637(LPCSTR lpExistingFileName, LPCSTR lpNewFileName); // idb
// double __cdecl ceil(double X);
// double __cdecl floor(double X);
// double __cdecl frexp(double X, int *Y);
// double __cdecl ldexp(double X, int Y);
// int __cdecl tolower(int C);
// int __cdecl __toupper_mt(CHAR MultiByteStr, WORD CharType); idb
int __cdecl sub_10028174(WORD CharType); // idb
// int __cdecl isalpha(int C);
// int __cdecl isupper(int C);
// int __cdecl islower(int C);
// int __cdecl isdigit(int C);
// int __cdecl isxdigit(int C);
// int __cdecl isspace(int C);
// int __cdecl ispunct(int C);
// int __cdecl isalnum(int C);
// int __cdecl isprint(int C);
// int __cdecl iscntrl(int C);
// void *__cdecl memchr(const void *Buf, int Val, size_t MaxCount);
// char *__cdecl strpbrk(const char *Str, const char *Control);
// char *__cdecl strchr(const char *Str, int Val);
// char *__cdecl strerror(int ErrorMessage);
// void __cdecl _lock_file(FILE *Stream);
// void __cdecl _unlock_file(FILE *Stream);
// char *__cdecl tmpnam(char *Buffer);
// FILE *__cdecl tmpfile();
int __cdecl sub_100289DB(FILE *Stream, int a2, int a3); // idb
// int __cdecl ungetc_0(int Character, FILE *Stream);
// int __cdecl fgetc(FILE *Stream);
// size_t __cdecl fread(void *Buffer, size_t ElementSize, size_t ElementCount, FILE *Stream);
size_t __cdecl sub_10028C0F(void *Buffer, size_t ElementSize, size_t ElementCount, FILE *Stream);
// size_t __cdecl fwrite(const void *Buffer, size_t ElementSize, size_t ElementCount, FILE *Stream);
size_t __cdecl sub_10028D62(void *Buffer, size_t ElementSize, size_t ElementCount, FILE *Stream);
// int fprintf(FILE *const Stream, const char *const Format, ...);
// int __cdecl ftell(FILE *Stream);
// int __cdecl fseek(FILE *Stream, int Offset, int Origin);
// int __cdecl flsall(FILE *Stream); idb
// int __cdecl fflush(FILE *Stream);
int sub_10029237();
intptr_t __cdecl sub_10029240(char *a1);
// char *__cdecl getenv(const char *VarName);
char *__cdecl sub_10029363(char *VarName);
// clock_t __cdecl clock();
// size_t __cdecl strftime(char *Buffer, size_t SizeInBytes, const char *Format, const struct tm *Tm);
// struct tm *__cdecl localtime(const __time32_t *const Time);
// struct tm *__cdecl gmtime(const __time32_t *const Time);
// _DWORD __cdecl _make_time_t(_DWORD); weak
int sub_1002A0FE();
// double __cdecl difftime(const __time32_t Time1, const __time32_t Time2);
// int __updatetlocinfo(void); weak
// char *__cdecl setlocale(int Category, const char *Locale);
// void __cdecl __noreturn exit(int Code);
// unsigned int __cdecl strtoul(const char *String, char **EndPtr, int Radix);
// void __cdecl __noreturn longjmp(jmp_buf Buf, int Value);
// _DWORD __cdecl _setjmp3(_DWORD, _DWORD);
// int __cdecl strcoll(const char *String1, const char *String2);
// double __cdecl strtod(const char *String, char **EndPtr);
// char *__cdecl strncat(char *Destination, const char *Source, size_t Count);
// size_t __cdecl strcspn(const char *Str, const char *Control);
// void *__cdecl realloc(void *Block, size_t Size);
// int __cdecl atexit(void (__cdecl *)());
// void __cdecl qsort(void *Base, size_t NumOfElements, size_t SizeOfElements, _CoreCrtNonSecureSearchSortCompareFunction CompareFunction);
// int __cdecl strcmp(const char *Str1, const char *Str2);
// void __cdecl __noreturn abort();
// int __cdecl fputc(int Character, FILE *Stream);
int __cdecl sub_1002BCF8(FILE *Stream, int a2, int a3); // idb
// char *__cdecl strtok(char *String, const char *Delimiter);
// int __cdecl _output(FILE *File, int, int); idb
// int _getptd(void); weak
// int __cdecl _input(FILE *Stream, int, int); idb
void sub_1002E55D();
void __cdecl sub_1002E5A1(); // idb
// _DWORD __cdecl _unlock(_DWORD); weak
// _DWORD __cdecl _lock(_DWORD); weak
// _DWORD __cdecl _stbuf(_DWORD); weak
// _DWORD __cdecl _ftbuf(_DWORD, _DWORD); weak
// int __cdecl _openfile(char *FileName, int, int ShareFlag, int); idb
// int _getstream(void); weak
// int __cdecl _close(int FileHandle);
// int __cdecl _access(const char *FileName, int AccessMode);
// int _open(const char *FileName, int OpenFlag, ...);
// int __cdecl _write(int FileHandle, const void *Buf, unsigned int MaxCharCount);
// intptr_t __cdecl _spawnvpe(int Mode, const char *FileName, const char *const *Arguments, const char *const *Environment);
// intptr_t __cdecl _spawnve(int Mode, const char *FileName, const char *const *Arguments, const char *const *Environment);
// _DWORD __cdecl _ld12cvt(_DWORD, _DWORD, _DWORD); weak
int __cdecl sub_10037DE9(int a1, int a2);
int __cdecl sub_10037DFF(int a1, int a2);
int __cdecl sub_10037E15(int a1, int a2);
int __cdecl sub_10037E52(int a1, int a2);
// _DWORD __cdecl __strgtold12(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
int sub_10038C34();
// int __stdcall WSAGetLastError();
// int __stdcall WSAStartup(WORD wVersionRequested, LPWSADATA lpWSAData);
// int __stdcall WSACleanup();
// int __stdcall send(SOCKET s, const char *buf, int len, int flags);
// int __stdcall recv(SOCKET s, char *buf, int len, int flags);
// int __stdcall closesocket(SOCKET s);
// int __stdcall shutdown(SOCKET s, int how);
// int __stdcall listen(SOCKET s, int backlog);
// int __stdcall bind(SOCKET s, const struct sockaddr *name, int namelen);
// u_short __stdcall htons(u_short hostshort);
// int __stdcall setsockopt(SOCKET s, int level, int optname, const char *optval, int optlen);
// SOCKET __stdcall socket(int af, int type, int protocol);
// SOCKET __stdcall accept(SOCKET s, struct sockaddr *addr, int *addrlen);
// int __stdcall _WSAFDIsSet(SOCKET fd, fd_set *);
// int __stdcall select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, const struct timeval *timeout);
// int __stdcall ioctlsocket(SOCKET s, int cmd, u_long *argp);
// int __stdcall connect(SOCKET s, const struct sockaddr *name, int namelen);
// struct hostent *__stdcall gethostbyaddr(const char *addr, int len, int type);
// unsigned int __stdcall inet_addr(const char *cp);
// struct hostent *__stdcall gethostbyname(const char *name);
// int __stdcall getsockname(SOCKET s, struct sockaddr *name, int *namelen);
// u_short __stdcall ntohs(u_short netshort);
// int __stdcall sendto(SOCKET s, const char *buf, int len, int flags, const struct sockaddr *to, int tolen);
// int __stdcall recvfrom(SOCKET s, char *buf, int len, int flags, struct sockaddr *from, int *fromlen);
// int __stdcall getsockopt(SOCKET s, int level, int optname, char *optval, int *optlen);
// int __cdecl _fstat(const int FileHandle, struct _stat32 *const Stat);
int __cdecl sub_1003A73A(LPCSTR lpPathName); // idb
int sub_1003A770();
void __cdecl nullsub_4(); // idb

//-------------------------------------------------------------------------
// Data declarations

// extern void (__stdcall *Sleep)(DWORD dwMilliseconds);
// extern void (__stdcall *GetLocalTime)(LPSYSTEMTIME lpSystemTime);
// extern BOOL (__stdcall *FileTimeToSystemTime)(const FILETIME *lpFileTime, LPSYSTEMTIME lpSystemTime);
// extern BOOL (__stdcall *SystemTimeToFileTime)(const SYSTEMTIME *lpSystemTime, LPFILETIME lpFileTime);
// extern HANDLE (__stdcall *CreateMutexA)(LPSECURITY_ATTRIBUTES lpMutexAttributes, BOOL bInitialOwner, LPCSTR lpName);
// extern DWORD (__stdcall *WaitForSingleObject)(HANDLE hHandle, DWORD dwMilliseconds);
// extern BOOL (__stdcall *ReleaseMutex)(HANDLE hMutex);
// extern BOOL (__stdcall *CloseHandle)(HANDLE hObject);
// extern HANDLE (__stdcall *CreateEventA)(LPSECURITY_ATTRIBUTES lpEventAttributes, BOOL bManualReset, BOOL bInitialState, LPCSTR lpName);
// extern BOOL (__stdcall *SetEvent)(HANDLE hEvent);
// extern BOOL (__stdcall *ResetEvent)(HANDLE hEvent);
// extern HANDLE (__stdcall *CreateThread)(LPSECURITY_ATTRIBUTES lpThreadAttributes, SIZE_T dwStackSize, LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, DWORD dwCreationFlags, LPDWORD lpThreadId);
// extern void (__stdcall __noreturn *ExitThread)(DWORD dwExitCode);
// extern DWORD (__stdcall *GetLastError)();
// extern BOOL (__stdcall *DeleteFileA)(LPCSTR lpFileName);
// extern BOOL (__stdcall *MoveFileA)(LPCSTR lpExistingFileName, LPCSTR lpNewFileName);
// extern BOOL (__stdcall *CreateDirectoryA)(LPCSTR lpPathName, LPSECURITY_ATTRIBUTES lpSecurityAttributes);
void *off_1003C220 = &loc_100032D0; // weak
int (__stdcall *off_1003C230[2])(int) = { &sub_10025BF0, &sub_10023E30 }; // weak
int (*off_1003C238)() = &sub_10006940; // weak
int (__stdcall *off_1003C258)(char *Source, __int16, int) = &sub_100037D0; // weak
__int16 word_1003C428 = 32; // weak
void *off_1003CC9C = &loc_100066C0; // weak
void *off_1003CCA4 = &loc_100066E0; // weak
int (__stdcall *off_1003CCB8)(void *Block, __int16, int, int) = &sub_100010A0; // weak
void *off_1003CD58 = &loc_10006860; // weak
void *off_1003CE60 = &loc_10006A00; // weak
void *off_1003CEE8 = &loc_100092E0; // weak
void *off_1003D8FC = &loc_1000B110; // weak
char byte_1003D986[2] = { '\0', '\0' }; // weak
_UNKNOWN unk_1003E150; // weak
int Origin[3] = { 0, 1, 2 }; // weak
char *off_1003E69C[3] = { "set", "cur", "end" }; // weak
int Category[6] = { 0, 1, 2, 3, 4, 5 }; // weak
char *off_1003E770[6] = { "all", "collate", "ctype", "monetary", "numeric", "time" }; // weak
const int off_1003F1A8 = 268693120; // idb
int dword_1003F23C[] = { 1970102111 }; // weak
_UNKNOWN unk_1003F368; // weak
char byte_1003F377[257] =
{
  '\0',
  '\0',
  '\x01',
  '\x01',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x03',
  '\x03',
  '\x03',
  '\x03',
  '\x03',
  '\x03',
  '\x03',
  '\x03',
  '\x04',
  '\x04',
  '\x04',
  '\x04',
  '\x04',
  '\x04',
  '\x04',
  '\x04',
  '\x04',
  '\x04',
  '\x04',
  '\x04',
  '\x04',
  '\x04',
  '\x04',
  '\x04',
  '\x05',
  '\x05',
  '\x05',
  '\x05',
  '\x05',
  '\x05',
  '\x05',
  '\x05',
  '\x05',
  '\x05',
  '\x05',
  '\x05',
  '\x05',
  '\x05',
  '\x05',
  '\x05',
  '\x05',
  '\x05',
  '\x05',
  '\x05',
  '\x05',
  '\x05',
  '\x05',
  '\x05',
  '\x05',
  '\x05',
  '\x05',
  '\x05',
  '\x05',
  '\x05',
  '\x05',
  '\x05',
  '\x06',
  '\x06',
  '\x06',
  '\x06',
  '\x06',
  '\x06',
  '\x06',
  '\x06',
  '\x06',
  '\x06',
  '\x06',
  '\x06',
  '\x06',
  '\x06',
  '\x06',
  '\x06',
  '\x06',
  '\x06',
  '\x06',
  '\x06',
  '\x06',
  '\x06',
  '\x06',
  '\x06',
  '\x06',
  '\x06',
  '\x06',
  '\x06',
  '\x06',
  '\x06',
  '\x06',
  '\x06',
  '\x06',
  '\x06',
  '\x06',
  '\x06',
  '\x06',
  '\x06',
  '\x06',
  '\x06',
  '\x06',
  '\x06',
  '\x06',
  '\x06',
  '\x06',
  '\x06',
  '\x06',
  '\x06',
  '\x06',
  '\x06',
  '\x06',
  '\x06',
  '\x06',
  '\x06',
  '\x06',
  '\x06',
  '\x06',
  '\x06',
  '\x06',
  '\x06',
  '\x06',
  '\x06',
  '\x06',
  '\x06',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\0'
}; // weak
char byte_1003F85C[] = { '\x06' }; // weak
char byte_1003F85D[27] =
{
  '\x06',
  '\x06',
  '\x06',
  '\a',
  '\a',
  '\a',
  '\a',
  '\n',
  '\t',
  '\x05',
  '\x04',
  '\x03',
  '\x03',
  '\x03',
  '\x03',
  '\x03',
  '\x03',
  '\x03',
  '\x03',
  '\x03',
  '\x03',
  '\x03',
  '\x03',
  '\x02',
  '\x02',
  '\x01',
  '\x01'
}; // weak
char byte_1003FC04[] = { '$' }; // weak
int dword_1003FC10[12] =
{
  943208504,
  874783800,
  -1734830078,
  164,
  16941058,
  2162689,
  21,
  21,
  22,
  23,
  22,
  23
}; // weak
int (__stdcall *off_1003FC94)(int) = &sub_10021F00; // weak
void *off_1003FCA0 = &loc_100227D0; // weak
int (__stdcall *off_1003FD50[3])(int) = { &sub_10023A00, &sub_10023A00, &sub_10023A20 }; // weak
int (__stdcall *off_1003FDD8[2])(int) = { &sub_10025BF0, &sub_10023E30 }; // weak
void *off_1003FEAC = &loc_100243D0; // weak
void *off_1003FF18 = &loc_10025030; // weak
int (__stdcall *off_1003FFA0[3])(int) = { &sub_10025BC0, &sub_10025BC0, &sub_10025BC0 }; // weak
void (*dword_100462CC[2])(void) = { NULL, NULL }; // weak
void (*dword_100462D4)(void) = NULL; // weak
char aNetflow[8] = "NETFLOW"; // weak
char aNetdrv[7] = "NETDRV"; // weak
char asc_10047068[81] = "--------------------------------------------------------------------------------"; // weak
char aSocketLowwater[17] = "Socket: lowwater"; // weak
char aCommonTalk[14] = "<common talk>"; // weak
char aNetkrnl[8] = "NETKRNL"; // weak
char aTinapi[7] = "TINAPI"; // weak
char aInstanceFourI4[44] = "Instance Four i4:, TinCat component system."; // weak
char aCCopyright1996[69] = "(c) Copyright 1996-2004 Instance Four, Germany. All rights reserved."; // weak
char a04Mar2004Tinca[30] = "04-MAR-2004, TinCat Release 2"; // weak
char aIdTinapiCppV17[56] = "$Id: tinapi.cpp,v 1.73 2005/02/22 00:12:59 cvs_jr Exp $"; // weak
__int16 word_10048A20 = 2; // weak
int dword_10048A24 = 28; // weak
char aUserlogTxt[96] =
{
  'u',
  's',
  'e',
  'r',
  'l',
  'o',
  'g',
  '.',
  't',
  'x',
  't',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  'n',
  'e',
  't',
  'l',
  'o',
  'g',
  '.',
  't',
  'x',
  't',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  'l',
  'o',
  'g',
  'd',
  'a',
  't',
  'a',
  '.',
  'c',
  's',
  'v',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // weak
char aClassInitializ[19] = ":class_initialized"; // weak
char aUser[] = "user"; // idb
char aPassword[] = "password"; // idb
char aTinusr[7] = "TINUSR"; // weak
char aTinvalue[9] = "TINVALUE"; // weak
_UNKNOWN unk_10048FE0; // weak
_UNKNOWN unk_100491E0; // weak
char aLogfileTxt_0[12] = "logfile.txt"; // weak
char aBaselibMem[12] = "BASELIB MEM"; // weak
char aBlInitmemsyste[17] = "BL_InitMemSystem"; // weak
char aBlExitmemsyste[17] = "BL_ExitMemSystem"; // weak
char aBlOrggetmem[13] = "BL_OrgGetMem"; // weak
char aBlOrgfreemem[14] = "BL_OrgFreeMem"; // weak
char aLogfileTxt[12] = "LOGFILE.TXT"; // weak
char asc_10049574[3] = "\r\n"; // weak
char asc_10049578[2] = "\r"; // weak
char aDebug[10] = "**DEBUG: "; // weak
char asc_10049600[2] = "("; // weak
__int16 word_10049630[] = { -10001 }; // weak
int dword_10049634[] = { 10093 }; // weak
char aWsaSystemNotIn[2848] =
{
  'W',
  'S',
  'A',
  ' ',
  's',
  'y',
  's',
  't',
  'e',
  'm',
  ' ',
  'n',
  'o',
  't',
  ' ',
  'i',
  'n',
  'i',
  't',
  'i',
  'a',
  'l',
  'i',
  'z',
  'e',
  'd',
  '.',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\xEE',
  '\xD8',
  '\xFF',
  '\xFF',
  'B',
  '\'',
  '\0',
  '\0',
  'N',
  'e',
  't',
  'w',
  'o',
  'r',
  'k',
  ' ',
  's',
  'u',
  'b',
  's',
  'y',
  's',
  't',
  'e',
  'm',
  ' ',
  'h',
  'a',
  's',
  ' ',
  'f',
  'a',
  'i',
  'l',
  'e',
  'd',
  '.',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\xED',
  '\xD8',
  '\xFF',
  '\xFF',
  'I',
  '\'',
  '\0',
  '\0',
  'T',
  'h',
  'e',
  ' ',
  's',
  'o',
  'c',
  'k',
  'e',
  't',
  ' ',
  'i',
  's',
  ' ',
  'n',
  'o',
  't',
  ' ',
  'c',
  'o',
  'n',
  'n',
  'e',
  'c',
  't',
  'e',
  'd',
  '.',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\xEC',
  '\xD8',
  '\xFF',
  '\xFF',
  '\x14',
  '\'',
  '\0',
  '\0',
  'I',
  'n',
  't',
  'e',
  'r',
  'r',
  'u',
  'p',
  't',
  'e',
  'd',
  ' ',
  'f',
  'u',
  'n',
  'c',
  't',
  'i',
  'o',
  'n',
  ' ',
  'c',
  'a',
  'l',
  'l',
  '.',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\xEB',
  '\xD8',
  '\xFF',
  '\xFF',
  '4',
  '\'',
  '\0',
  '\0',
  'B',
  'l',
  'o',
  'c',
  'k',
  'i',
  'n',
  'g',
  ' ',
  's',
  'o',
  'c',
  'k',
  'e',
  't',
  's',
  ' ',
  'o',
  'p',
  'e',
  'r',
  'a',
  't',
  'i',
  'o',
  'n',
  ' ',
  'i',
  'n',
  ' ',
  'p',
  'r',
  'o',
  'g',
  'r',
  'e',
  's',
  's',
  '.',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\xEA',
  '\xD8',
  '\xFF',
  '\xFF',
  '6',
  '\'',
  '\0',
  '\0',
  'T',
  'h',
  'e',
  ' ',
  'd',
  'e',
  's',
  'c',
  'r',
  'i',
  'p',
  't',
  'o',
  'r',
  ' ',
  'i',
  's',
  ' ',
  'n',
  'o',
  't',
  ' ',
  'a',
  ' ',
  's',
  'o',
  'c',
  'k',
  'e',
  't',
  '.',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\xE9',
  '\xD8',
  '\xFF',
  '\xFF',
  '=',
  '\'',
  '\0',
  '\0',
  'O',
  'p',
  'e',
  'r',
  'a',
  't',
  'i',
  'o',
  'n',
  ' ',
  'n',
  'o',
  't',
  ' ',
  's',
  'u',
  'p',
  'p',
  'o',
  'r',
  't',
  'e',
  'd',
  '.',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\xE8',
  '\xD8',
  '\xFF',
  '\xFF',
  'J',
  '\'',
  '\0',
  '\0',
  'T',
  'h',
  'e',
  ' ',
  's',
  'o',
  'c',
  'k',
  'e',
  't',
  ' ',
  'h',
  'a',
  's',
  ' ',
  'b',
  'e',
  'e',
  'n',
  ' ',
  's',
  'h',
  'u',
  't',
  ' ',
  'd',
  'o',
  'w',
  'n',
  '.',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\xE7',
  '\xD8',
  '\xFF',
  '\xFF',
  '3',
  '\'',
  '\0',
  '\0',
  'S',
  'o',
  'c',
  'k',
  'e',
  't',
  ' ',
  'n',
  'o',
  'n',
  'b',
  'l',
  'o',
  'c',
  'k',
  'i',
  'n',
  'g',
  ' ',
  'b',
  'u',
  't',
  ' ',
  'o',
  'p',
  'e',
  'r',
  'a',
  't',
  'i',
  'o',
  'n',
  ' ',
  'w',
  'o',
  'u',
  'l',
  'd',
  ' ',
  'b',
  'l',
  'o',
  'c',
  'k',
  '.',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\xE6',
  '\xD8',
  '\xFF',
  '\xFF',
  '8',
  '\'',
  '\0',
  '\0',
  'D',
  'a',
  't',
  'a',
  'g',
  'r',
  'a',
  'm',
  ' ',
  't',
  'o',
  ' ',
  'l',
  'a',
  'r',
  'g',
  'e',
  ' ',
  't',
  'o',
  ' ',
  'f',
  'i',
  't',
  ' ',
  'i',
  'n',
  ' ',
  'b',
  'u',
  'f',
  'f',
  'e',
  'r',
  '.',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\xE5',
  '\xD8',
  '\xFF',
  '\xFF',
  '&',
  '\'',
  '\0',
  '\0',
  'I',
  'n',
  'v',
  'a',
  'l',
  'i',
  'd',
  ' ',
  'a',
  'r',
  'g',
  'u',
  'm',
  'e',
  'n',
  't',
  '.',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\xE4',
  '\xD8',
  '\xFF',
  '\xFF',
  'E',
  '\'',
  '\0',
  '\0',
  'V',
  'i',
  'r',
  't',
  'u',
  'a',
  'l',
  ' ',
  'c',
  'i',
  'r',
  'c',
  'u',
  'i',
  't',
  ' ',
  'a',
  'b',
  'o',
  'r',
  't',
  'e',
  'd',
  ':',
  ' ',
  't',
  'i',
  'm',
  'e',
  'o',
  'u',
  't',
  ' ',
  'o',
  'r',
  ' ',
  'f',
  'a',
  'i',
  'l',
  'u',
  'r',
  'e',
  '.',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\xE3',
  '\xD8',
  '\xFF',
  '\xFF',
  'F',
  '\'',
  '\0',
  '\0',
  'V',
  'i',
  'r',
  't',
  'u',
  'a',
  'l',
  ' ',
  'c',
  'i',
  'r',
  'c',
  'u',
  'i',
  't',
  ' ',
  'w',
  'a',
  's',
  ' ',
  'r',
  'e',
  's',
  'e',
  't',
  ' ',
  'b',
  'y',
  ' ',
  'o',
  't',
  'h',
  'e',
  'r',
  ' ',
  's',
  'i',
  'd',
  'e',
  '.',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\xE2',
  '\xD8',
  '\xFF',
  '\xFF',
  '\x1D',
  '\'',
  '\0',
  '\0',
  'P',
  'e',
  'r',
  'm',
  'i',
  's',
  's',
  'i',
  'o',
  'n',
  ' ',
  'd',
  'e',
  'n',
  'i',
  'e',
  'd',
  '.',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\xE1',
  '\xD8',
  '\xFF',
  '\xFF',
  '\x1E',
  '\'',
  '\0',
  '\0',
  'B',
  'a',
  'd',
  ' ',
  'a',
  'd',
  'd',
  'r',
  'e',
  's',
  's',
  '.',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\xE0',
  '\xD8',
  '\xFF',
  '\xFF',
  'D',
  '\'',
  '\0',
  '\0',
  'C',
  'o',
  'n',
  'n',
  'e',
  'c',
  't',
  'i',
  'o',
  'n',
  ' ',
  'm',
  'u',
  's',
  't',
  ' ',
  'b',
  'e',
  ' ',
  'r',
  'e',
  's',
  'e',
  't',
  ':',
  ' ',
  's',
  'o',
  'c',
  'k',
  'e',
  't',
  's',
  ' ',
  'd',
  'r',
  'o',
  'p',
  'p',
  'e',
  'd',
  ' ',
  'i',
  't',
  '.',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\xDF',
  '\xD8',
  '\xFF',
  '\xFF',
  'G',
  '\'',
  '\0',
  '\0',
  'N',
  'o',
  ' ',
  'b',
  'u',
  'f',
  'f',
  'e',
  'r',
  ' ',
  's',
  'p',
  'a',
  'c',
  'e',
  ' ',
  'a',
  'v',
  'a',
  'i',
  'l',
  'a',
  'b',
  'l',
  'e',
  '.',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\xDE',
  '\xD8',
  '\xFF',
  '\xFF',
  '@',
  '\'',
  '\0',
  '\0',
  'T',
  'h',
  'e',
  ' ',
  'a',
  'd',
  'd',
  'r',
  'e',
  's',
  's',
  ' ',
  'i',
  's',
  ' ',
  'a',
  'l',
  'r',
  'e',
  'a',
  'd',
  'y',
  ' ',
  'i',
  'n',
  ' ',
  'u',
  's',
  'e',
  '.',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\xDD',
  '\xD8',
  '\xFF',
  '\xFF',
  'A',
  '\'',
  '\0',
  '\0',
  'T',
  'h',
  'e',
  ' ',
  'a',
  'd',
  'd',
  'r',
  'e',
  's',
  's',
  ' ',
  'i',
  's',
  ' ',
  'n',
  'o',
  't',
  ' ',
  'a',
  'v',
  'a',
  'i',
  'l',
  'a',
  'b',
  'l',
  'e',
  ' ',
  'f',
  'r',
  'o',
  'm',
  ' ',
  'l',
  'o',
  'c',
  'a',
  'l',
  ' ',
  'c',
  'o',
  'm',
  'p',
  'u',
  't',
  'e',
  'r',
  '.',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\xDC',
  '\xD8',
  '\xFF',
  '\xFF',
  '?',
  '\'',
  '\0',
  '\0',
  'T',
  'h',
  'e',
  ' ',
  'a',
  'd',
  'r',
  'e',
  's',
  's',
  'e',
  's',
  ' ',
  'c',
  'a',
  'n',
  'n',
  'o',
  't',
  ' ',
  'b',
  'e',
  ' ',
  'u',
  's',
  'e',
  'd',
  ' ',
  'w',
  'i',
  't',
  'h',
  ' ',
  't',
  'h',
  'i',
  's',
  ' ',
  's',
  'o',
  'c',
  'k',
  'e',
  't',
  '.',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\xDB',
  '\xD8',
  '\xFF',
  '\xFF',
  'M',
  '\'',
  '\0',
  '\0',
  'T',
  'h',
  'e',
  ' ',
  'a',
  't',
  't',
  'e',
  'm',
  'p',
  't',
  ' ',
  't',
  'o',
  ' ',
  'c',
  'o',
  'n',
  'n',
  'e',
  'c',
  't',
  ' ',
  'w',
  'a',
  's',
  ' ',
  'f',
  'o',
  'r',
  'c',
  'e',
  'f',
  'u',
  'l',
  'l',
  'y',
  ' ',
  'r',
  'e',
  'j',
  'e',
  'c',
  't',
  'e',
  'd',
  '.',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\xDA',
  '\xD8',
  '\xFF',
  '\xFF',
  '7',
  '\'',
  '\0',
  '\0',
  'A',
  ' ',
  'd',
  'e',
  's',
  't',
  'i',
  'n',
  'a',
  't',
  'i',
  'o',
  'n',
  ' ',
  'a',
  'd',
  'd',
  'r',
  'e',
  's',
  's',
  ' ',
  'i',
  's',
  ' ',
  'r',
  'e',
  'q',
  'u',
  'i',
  'r',
  'e',
  'd',
  '.',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\xD9',
  '\xD8',
  '\xFF',
  '\xFF',
  'H',
  '\'',
  '\0',
  '\0',
  'T',
  'h',
  'e',
  ' ',
  's',
  'o',
  'c',
  'k',
  'e',
  't',
  ' ',
  'i',
  's',
  ' ',
  'a',
  'l',
  'r',
  'e',
  'a',
  'd',
  'y',
  ' ',
  'c',
  'o',
  'n',
  'n',
  'e',
  'c',
  't',
  'e',
  'd',
  '.',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\xD8',
  '\xD8',
  '\xFF',
  '\xFF',
  '(',
  '\'',
  '\0',
  '\0',
  'N',
  'o',
  ' ',
  'm',
  'o',
  'r',
  'e',
  ' ',
  'f',
  'i',
  'l',
  'e',
  ' ',
  'd',
  'e',
  's',
  'c',
  'r',
  'i',
  'p',
  't',
  'o',
  'r',
  's',
  ' ',
  'a',
  'v',
  'a',
  'i',
  'l',
  'a',
  'b',
  'l',
  'e',
  '.',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\xD7',
  '\xD8',
  '\xFF',
  '\xFF',
  'C',
  '\'',
  '\0',
  '\0',
  'T',
  'h',
  'e',
  ' ',
  'n',
  'e',
  't',
  'w',
  'o',
  'r',
  'k',
  ' ',
  'c',
  'a',
  'n',
  'n',
  'o',
  't',
  ' ',
  'b',
  'e',
  ' ',
  'r',
  'e',
  'a',
  'c',
  'h',
  'e',
  'd',
  '.',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\xD6',
  '\xD8',
  '\xFF',
  '\xFF',
  'L',
  '\'',
  '\0',
  '\0',
  'C',
  'o',
  'n',
  'n',
  'e',
  'c',
  't',
  ' ',
  't',
  'i',
  'm',
  'e',
  'd',
  ' ',
  'o',
  'u',
  't',
  ' ',
  'w',
  'i',
  't',
  'h',
  'o',
  'u',
  't',
  ' ',
  'c',
  'o',
  'n',
  'n',
  'e',
  'c',
  't',
  'i',
  'o',
  'n',
  '.',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\xD5',
  '\xD8',
  '\xFF',
  '\xFF',
  '9',
  '\'',
  '\0',
  '\0',
  'T',
  'h',
  'e',
  ' ',
  'p',
  'r',
  'o',
  't',
  'o',
  'c',
  'o',
  'l',
  ' ',
  'i',
  's',
  ' ',
  'w',
  'r',
  'o',
  'n',
  'g',
  ' ',
  'f',
  'o',
  'r',
  ' ',
  't',
  'h',
  'i',
  's',
  ' ',
  's',
  'o',
  'c',
  'k',
  'e',
  't',
  '.',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\xD4',
  '\xD8',
  '\xFF',
  '\xFF',
  ':',
  '\'',
  '\0',
  '\0',
  'T',
  'h',
  'e',
  ' ',
  'o',
  'p',
  't',
  'i',
  'o',
  'n',
  ' ',
  'i',
  's',
  ' ',
  'u',
  'n',
  'k',
  'n',
  'o',
  'w',
  'n',
  ' ',
  'o',
  'r',
  ' ',
  'u',
  'n',
  's',
  'u',
  'p',
  'p',
  'o',
  'r',
  't',
  'e',
  'd',
  '.',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\xD3',
  '\xD8',
  '\xFF',
  '\xFF',
  'k',
  '\'',
  '\0',
  '\0',
  'N',
  'e',
  't',
  'w',
  'o',
  'r',
  'k',
  ' ',
  's',
  'y',
  's',
  't',
  'e',
  'm',
  ' ',
  'u',
  'n',
  'a',
  'v',
  'a',
  'i',
  'l',
  'a',
  'b',
  'l',
  'e',
  '.',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\xD2',
  '\xD8',
  '\xFF',
  '\xFF',
  '5',
  '\'',
  '\0',
  '\0',
  'N',
  'o',
  'n',
  '-',
  'b',
  'l',
  'o',
  'c',
  'k',
  'i',
  'n',
  'g',
  ' ',
  'o',
  'p',
  'e',
  'r',
  'a',
  't',
  'i',
  'o',
  'n',
  ' ',
  'a',
  'l',
  'r',
  'e',
  'a',
  'd',
  'y',
  ' ',
  'i',
  'n',
  ' ',
  'p',
  'r',
  'o',
  'g',
  'r',
  'e',
  's',
  's',
  '.',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\xD1',
  '\xD8',
  '\xFF',
  '\xFF',
  ';',
  '\'',
  '\0',
  '\0',
  'P',
  'r',
  'o',
  't',
  'o',
  'c',
  'o',
  'l',
  ' ',
  'n',
  'o',
  't',
  ' ',
  's',
  'u',
  'p',
  'p',
  'o',
  'r',
  't',
  'e',
  'd',
  '.',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\xD0',
  '\xD8',
  '\xFF',
  '\xFF',
  '<',
  '\'',
  '\0',
  '\0',
  'S',
  'o',
  'c',
  'k',
  'e',
  't',
  ' ',
  't',
  'y',
  'p',
  'e',
  ' ',
  'n',
  'o',
  't',
  ' ',
  's',
  'u',
  'p',
  'p',
  'o',
  'r',
  't',
  'e',
  'd',
  '.',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\xCF',
  '\xD8',
  '\xFF',
  '\xFF',
  '>',
  '\'',
  '\0',
  '\0',
  'P',
  'r',
  'o',
  't',
  'o',
  'c',
  'o',
  'l',
  ' ',
  'f',
  'a',
  'm',
  'i',
  'l',
  'y',
  ' ',
  'n',
  'o',
  't',
  ' ',
  's',
  'u',
  'p',
  'p',
  'o',
  'r',
  't',
  'e',
  'd',
  '.',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\xCE',
  '\xD8',
  '\xFF',
  '\xFF',
  'P',
  '\'',
  '\0',
  '\0',
  'H',
  'o',
  's',
  't',
  ' ',
  'i',
  's',
  ' ',
  'd',
  'o',
  'w',
  'n',
  '.',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\xCD',
  '\xD8',
  '\xFF',
  '\xFF',
  'Q',
  '\'',
  '\0',
  '\0',
  'N',
  'o',
  ' ',
  'r',
  'o',
  'u',
  't',
  'e',
  ' ',
  't',
  'o',
  ' ',
  'h',
  'o',
  's',
  't',
  '.',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\xCC',
  '\xD8',
  '\xFF',
  '\xFF',
  'S',
  '\'',
  '\0',
  '\0',
  'T',
  'o',
  'o',
  ' ',
  'm',
  'a',
  'n',
  'y',
  ' ',
  'p',
  'r',
  'o',
  'c',
  'e',
  's',
  's',
  'e',
  's',
  '.',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\xCB',
  '\xD8',
  '\xFF',
  '\xFF',
  'u',
  '\'',
  '\0',
  '\0',
  'G',
  'r',
  'a',
  'c',
  'e',
  'f',
  'u',
  'l',
  ' ',
  's',
  'h',
  'u',
  't',
  'd',
  'o',
  'w',
  'n',
  ' ',
  'i',
  'n',
  ' ',
  'p',
  'r',
  'o',
  'g',
  'r',
  'e',
  's',
  's',
  '.',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\xCA',
  '\xD8',
  '\xFF',
  '\xFF',
  'l',
  '\'',
  '\0',
  '\0',
  'W',
  'i',
  'n',
  's',
  'o',
  'c',
  'k',
  ' ',
  'v',
  'e',
  'r',
  's',
  'i',
  'o',
  'n',
  ' ',
  'n',
  'o',
  't',
  ' ',
  's',
  'u',
  'p',
  'p',
  'o',
  'r',
  't',
  'e',
  'd',
  '.',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\xC9',
  '\xD8',
  '\xFF',
  '\xFF',
  '\xF9',
  '*',
  '\0',
  '\0',
  'H',
  'o',
  's',
  't',
  ' ',
  'n',
  'o',
  't',
  ' ',
  'f',
  'o',
  'u',
  'n',
  'd',
  '.',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\xC8',
  '\xD8',
  '\xFF',
  '\xFF',
  '\xFA',
  '*',
  '\0',
  '\0',
  'N',
  'o',
  'n',
  'a',
  'u',
  't',
  'h',
  'o',
  'r',
  'i',
  't',
  'a',
  't',
  'i',
  'v',
  'e',
  ' ',
  'h',
  'o',
  's',
  't',
  ' ',
  'n',
  'o',
  't',
  ' ',
  'f',
  'o',
  'u',
  'n',
  'd',
  '.',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\xC7',
  '\xD8',
  '\xFF',
  '\xFF',
  '\xFB',
  '*',
  '\0',
  '\0',
  'N',
  'o',
  'n',
  'r',
  'e',
  'c',
  'o',
  'v',
  'e',
  'r',
  'a',
  'b',
  'l',
  'e',
  ' ',
  'e',
  'r',
  'r',
  'o',
  'r',
  '.',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\xC6',
  '\xD8',
  '\xFF',
  '\xFF',
  '\xFC',
  '*',
  '\0',
  '\0',
  'V',
  'a',
  'l',
  'i',
  'd',
  ' ',
  'n',
  'a',
  'm',
  'e',
  ',',
  ' ',
  'n',
  'o',
  ' ',
  'd',
  'a',
  't',
  'a',
  ' ',
  'r',
  'e',
  'c',
  'o',
  'r',
  'd',
  ' ',
  'o',
  'f',
  ' ',
  'r',
  'e',
  'q',
  'u',
  'e',
  's',
  't',
  'e',
  'd',
  ' ',
  't',
  'y',
  'p',
  'e',
  '.',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // weak
char aBltime[7] = "BLTIME"; // weak
char aTimeGettimestr[19] = "TIME_GetTimeString"; // weak
char aTimeGetdatestr[19] = "TIME_GetDateString"; // weak
__int16 word_1004A1A4[] = { 1 }; // weak
int OpenFlag[9] = { 32768, 2, 33025, 3, 32770, 4, 33034, 8, 33538 }; // weak
char aBaselibIo[11] = "BASELIB IO"; // weak
char aInitbl[7] = "InitBL"; // weak
char aOpenfile[9] = "OpenFile"; // weak
char aClosefile[10] = "CloseFile"; // weak
char aReadfile[9] = "ReadFile"; // weak
char aWritefile[10] = "WriteFile"; // weak
char aLengthfile[11] = "LengthFile"; // weak
char aInstanceFourI4_0[42] = "Instance Four i4:, PHASE software library"; // weak
char aCCopyright1996_0[69] = "(c) Copyright 1996-2004 Instance Four, Germany. All rights reserved."; // weak
char a08Apr2004Libra[31] = "08-APR-2004, Library version 2"; // weak
char aIdBlCV16200404[49] = "$Id: bl.c,v 1.6 2004/04/08 13:52:08 bewers Exp $"; // weak
int dword_1004A8D8[260] =
{
  0,
  1996959894,
  -301047508,
  -1727442502,
  124634137,
  1886057615,
  -379345611,
  -1637575261,
  249268274,
  2044508324,
  -522852066,
  -1747789432,
  162941995,
  2125561021,
  -407360249,
  -1866523247,
  498536548,
  1789927666,
  -205950648,
  -2067906082,
  450548861,
  1843258603,
  -187386543,
  -2083289657,
  325883990,
  1684777152,
  -43845254,
  -1973040660,
  335633487,
  1661365465,
  -99664541,
  -1928851979,
  997073096,
  1281953886,
  -715111964,
  -1570279054,
  1006888145,
  1258607687,
  -770865667,
  -1526024853,
  901097722,
  1119000684,
  -608450090,
  -1396901568,
  853044451,
  1172266101,
  -589951537,
  -1412350631,
  651767980,
  1373503546,
  -925412992,
  -1076862698,
  565507253,
  1454621731,
  -809855591,
  -1195530993,
  671266974,
  1594198024,
  -972236366,
  -1324619484,
  795835527,
  1483230225,
  -1050600021,
  -1234817731,
  1994146192,
  31158534,
  -1731059524,
  -271249366,
  1907459465,
  112637215,
  -1614814043,
  -390540237,
  2013776290,
  251722036,
  -1777751922,
  -519137256,
  2137656763,
  141376813,
  -1855689577,
  -429695999,
  1802195444,
  476864866,
  -2056965928,
  -228458418,
  1812370925,
  453092731,
  -2113342271,
  -183516073,
  1706088902,
  314042704,
  -1950435094,
  -54949764,
  1658658271,
  366619977,
  -1932296973,
  -69972891,
  1303535960,
  984961486,
  -1547960204,
  -725929758,
  1256170817,
  1037604311,
  -1529756563,
  -740887301,
  1131014506,
  879679996,
  -1385723834,
  -631195440,
  1141124467,
  855842277,
  -1442165665,
  -586318647,
  1342533948,
  654459306,
  -1106571248,
  -921952122,
  1466479909,
  544179635,
  -1184443383,
  -832445281,
  1591671054,
  702138776,
  -1328506846,
  -942167884,
  1504918807,
  783551873,
  -1212326853,
  -1061524307,
  -306674912,
  -1698712650,
  62317068,
  1957810842,
  -355121351,
  -1647151185,
  81470997,
  1943803523,
  -480048366,
  -1805370492,
  225274430,
  2053790376,
  -468791541,
  -1828061283,
  167816743,
  2097651377,
  -267414716,
  -2029476910,
  503444072,
  1762050814,
  -144550051,
  -2140837941,
  426522225,
  1852507879,
  -19653770,
  -1982649376,
  282753626,
  1742555852,
  -105259153,
  -1900089351,
  397917763,
  1622183637,
  -690576408,
  -1580100738,
  953729732,
  1340076626,
  -776247311,
  -1497606297,
  1068828381,
  1219638859,
  -670225446,
  -1358292148,
  906185462,
  1090812512,
  -547295293,
  -1469587627,
  829329135,
  1181335161,
  -882789492,
  -1134132454,
  628085408,
  1382605366,
  -871598187,
  -1156888829,
  570562233,
  1426400815,
  -977650754,
  -1296233688,
  733239954,
  1555261956,
  -1026031705,
  -1244606671,
  752459403,
  1541320221,
  -1687895376,
  -328994266,
  1969922972,
  40735498,
  -1677130071,
  -351390145,
  1913087877,
  83908371,
  -1782625662,
  -491226604,
  2075208622,
  213261112,
  -1831694693,
  -438977011,
  2094854071,
  198958881,
  -2032938284,
  -237706686,
  1759359992,
  534414190,
  -2118248755,
  -155638181,
  1873836001,
  414664567,
  -2012718362,
  -15766928,
  1711684554,
  285281116,
  -1889165569,
  -127750551,
  1634467795,
  376229701,
  -1609899400,
  -686959890,
  1308918612,
  956543938,
  -1486412191,
  -799009033,
  1231636301,
  1047427035,
  -1362007478,
  -640263460,
  1088359270,
  936918000,
  -1447252397,
  -558129467,
  1202900863,
  817233897,
  -1111625188,
  -893730166,
  1404277552,
  615818150,
  -1160759803,
  -841546093,
  1423857449,
  601450431,
  -1285129682,
  -1000256840,
  1567103746,
  711928724,
  -1274298825,
  -1022587231,
  1510334235,
  755167117,
  1163149636,
  1162692948,
  0,
  1162692948
}; // weak
char byte_1004ACE8[55] =
{
  'R',
  '\0',
  '\0',
  '\0',
  'J',
  'A',
  'N',
  '\0',
  'F',
  'E',
  'B',
  '\0',
  'M',
  'A',
  'R',
  '\0',
  'A',
  'P',
  'R',
  '\0',
  'M',
  'A',
  'Y',
  '\0',
  'J',
  'U',
  'N',
  '\0',
  'J',
  'U',
  'L',
  '\0',
  'A',
  'U',
  'G',
  '\0',
  'S',
  'E',
  'P',
  '\0',
  'O',
  'C',
  'T',
  '\0',
  'N',
  'O',
  'V',
  '\0',
  'D',
  'E',
  'C',
  '\0',
  'X',
  'X',
  'X'
}; // weak
char byte_1004AD1F[11] =
{
  '\0',
  '\x1F',
  '\x1C',
  '\x1F',
  '\x1E',
  '\x1F',
  '\x1E',
  '\x1F',
  '\x1F',
  '\x1E',
  '\x1F'
}; // weak
__int16 word_1004AD2A[] = { 7966 }; // weak
__int16 word_1004AD2C[] = { 31 }; // weak
__int16 word_1004AD2E[] = { 59 }; // weak
__int16 word_1004AD30[] = { 90 }; // weak
__int16 word_1004AD32[] = { 120 }; // weak
__int16 word_1004AD34[] = { 151 }; // weak
__int16 word_1004AD36[5] = { 181, 212, 243, 273, 304 }; // weak
__int16 word_1004AD40[] = { 334 }; // weak
__int16 word_1004AD42[] = { 365 }; // weak
__int16 word_1004AD44[] = { 31 }; // weak
__int16 word_1004AD46[] = { 60 }; // weak
__int16 word_1004AD48[] = { 91 }; // weak
__int16 word_1004AD4A[] = { 121 }; // weak
__int16 word_1004AD4C[] = { 152 }; // weak
__int16 word_1004AD4E[93] =
{
  182,
  213,
  244,
  274,
  305,
  335,
  366,
  21581,
  24408,
  19537,
  21321,
  84,
  0,
  21324,
  17236,
  19521,
  76,
  17730,
  17481,
  0,
  0,
  10304,
  10531,
  18720,
  14948,
  24864,
  29298,
  31073,
  25390,
  28784,
  30252,
  12576,
  12590,
  8243,
  12338,
  13104,
  12335,
  12082,
  13618,
  12320,
  14896,
  12338,
  12602,
  8244,
  26989,
  26723,
  25953,
  8300,
  30789,
  112,
  0,
  21584,
  16722,
  22866,
  0,
  26956,
  29811,
  0,
  0,
  18758,
  17740,
  0,
  0,
  10304,
  10531,
  18720,
  14948,
  26912,
  25972,
  24946,
  28532,
  11890,
  28771,
  11376,
  8310,
  11825,
  8246,
  12338,
  12848,
  12335,
  12089,
  14641,
  12832,
  14898,
  14642,
  13370,
  8242,
  26989,
  26723,
  25953,
  8300,
  30789,
  112
}; // weak
int (__cdecl *off_1004AE0C)(_DWORD) = &sub_10024E90; // weak
int (__cdecl *off_1004AE14)(_DWORD, _DWORD, _DWORD) = &sub_10024F00; // weak
int (__cdecl *off_1004AE18)(_DWORD) = &sub_10024E20; // weak
int (__cdecl *off_1004AE9C)(_DWORD, _DWORD, _DWORD, _DWORD) = &sub_10025DB0; // weak
int (__cdecl *off_1004AEA0)(_DWORD, _DWORD) = &sub_10025E50; // weak
int (__cdecl *off_1004AEA4)(_DWORD, _DWORD) = &sub_10025EA0; // weak
int (__cdecl *off_1004AEA8)(_DWORD, _DWORD) = &sub_10025EF0; // weak
void *off_1004AEB8 = &loc_10026090; // weak
int (*off_1004AED0)(void) = &sub_100262A0; // weak
int (__cdecl *off_1004AED4)(_DWORD, _DWORD) = &sub_100262F0; // weak
int (__cdecl *off_1004AED8)(_DWORD, _DWORD) = &sub_10026350; // weak
int (__cdecl *off_1004AEE4)(_DWORD, _DWORD) = &sub_10026460; // weak
int (__cdecl *off_1004AEEC)(_DWORD, _DWORD) = &sub_100264F0; // weak
int (__cdecl *off_1004AF00)(_DWORD) = &sub_10024B30; // weak
FILE stru_1004B120 = { &unk_1004DD00, 0, &unk_1004DD00, 257, 0, 0, 4096, NULL }; // idb
FILE File = { NULL, 0, NULL, 2, 1, 0, 0, NULL }; // idb
FILE Stream = { NULL, 0, NULL, 2, 2, 0, 0, NULL }; // idb
void *off_1004B4BC = &unk_1004B468; // idb
_UNKNOWN unk_1004BF78; // weak
_UNKNOWN unk_1004BF90; // weak
char byte_1004C280[4] = { '\0', '\0', '\0', '\0' }; // weak
int dword_1004C284 = 0; // weak
int dword_1004C288 = 0; // weak
int dword_1004C28C = 0; // weak
char byte_1004C290[1024] =
{
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // idb
char Buffer[1028] =
{
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_1004CA94 = 0; // weak
int dword_1004CA98 = 0; // weak
int dword_1004CA9C = 0; // weak
HANDLE dword_1004CAA0[2] = { NULL, NULL }; // weak
_UNKNOWN unk_1004CAA8; // weak
int dword_1004CAC8 = 0; // weak
__int16 word_1004CACC = 0; // weak
__int16 word_1004CAD0 = 0; // weak
__int16 word_1004CAD4 = 0; // weak
int dword_1004CAD8 = 0; // weak
int dword_1004CADC[] = { 0 }; // weak
int dword_1004CAE0[] = { 0 }; // weak
int dword_1004CAE4[] = { 0 }; // weak
int dword_1004CAE8[] = { 0 }; // weak
int dword_1004CAEC[] = { 0 }; // weak
int dword_1004CAF0[] = { 0 }; // weak
int dword_1004CAF4[25] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }; // weak
_UNKNOWN unk_1004CB58; // weak
int dword_1004CF78 = 0; // weak
int dword_1004D090; // weak
int dword_1004D540; // weak
__int16 word_1004D544; // weak
__int16 word_1004D548[]; // weak
int FileHandle[101]; // weak
char byte_1004D6E0[512]; // idb
char Buf[100]; // idb


//----- (10001000) --------------------------------------------------------
__int16 __thiscall sub_10001000(int this, int a2, int a3, int a4, int a5, int a6)
{
  *(_DWORD *)(this + 8) = 0;
  *(_DWORD *)(this + 12) = 0;
  *(_DWORD *)(this + 16) = 0;
  *(_DWORD *)(this + 20) = 0;
  *(_WORD *)(this + 24) = 0;
  *(_DWORD *)(this + 28) = 0;
  *(_DWORD *)(this + 32) = 10;
  *(_DWORD *)(this + 36) = 5000;
  sub_100220A0((WORD *)(this + 40));
  *(_DWORD *)(this + 8) = a3;
  *(_DWORD *)(this + 12) = a4;
  *(_DWORD *)(this + 16) = a4;
  *(_DWORD *)(this + 60) = 0;
  *(_DWORD *)(this + 64) = 0;
  *(_DWORD *)(this + 68) = 0;
  *(_DWORD *)(this + 72) = 0;
  *(_WORD *)(this + 24) = 0;
  *(_DWORD *)(this + 32) = a6;
  *(_DWORD *)(this + 20) = a5;
  *(_DWORD *)(this + 28) = a2;
  return 0;
}

//----- (10001070) --------------------------------------------------------
int __thiscall sub_10001070(int this)
{
  int result; // eax

  result = 0;
  *(_DWORD *)(this + 8) = 0;
  *(_DWORD *)(this + 12) = 0;
  *(_DWORD *)(this + 16) = 0;
  *(_DWORD *)(this + 20) = 0;
  *(_WORD *)(this + 24) = 0;
  *(_DWORD *)(this + 28) = 0;
  *(_DWORD *)(this + 32) = 10;
  *(_DWORD *)(this + 36) = 5000;
  return result;
}

//----- (100010A0) --------------------------------------------------------
__int16 __thiscall sub_100010A0(_DWORD *this, _DWORD *Block, __int16 a3, int a4, WORD a5)
{
  char *v8; // ebp
  char *v9; // eax
  _DWORD *v10; // esi
  int v11; // eax
  _DWORD *v12; // eax
  int v13; // [esp-48h] [ebp-60h]
  int v14; // [esp-44h] [ebp-5Ch]
  int v15; // [esp-1Ch] [ebp-34h]
  int v16; // [esp-18h] [ebp-30h]
  int v17; // [esp-14h] [ebp-2Ch]
  int v18; // [esp-10h] [ebp-28h]
  int v19; // [esp-Ch] [ebp-24h]
  char *v20; // [esp-8h] [ebp-20h]
  char *v21; // [esp+8h] [ebp-10h]
  char v22[12]; // [esp+Ch] [ebp-Ch] BYREF
  char *Blocka; // [esp+1Ch] [ebp+4h]

  strcpy(v22, "NetworkInit");
  Blocka = sub_10006E00(Block, 1u, 1);
  if ( !Blocka || (v21 = sub_10006E00(Block, 0, 1)) == 0 )
  {
    sub_100031F0(-6);
    v20 = sub_10003240();
    sub_1000C6F0(0, 4, "%s::%s: Neterror: %s", aNetflow, v22, v20);
    return -1;
  }
  v8 = sub_10006E00(Block, 2u, 1);
  if ( !v8 )
  {
    sub_100031F0(-6);
    v9 = sub_10003240();
    sub_1000C6F0(0, 4, "%s::%s: Neterror: %s", aNetflow, v22, v9);
    return -1;
  }
  this[20] = Block;
  v10 = (_DWORD *)(*(int (__thiscall **)(_DWORD *))(*Block + 52))(Block);
  v19 = v10[29];
  v18 = v10[28];
  v17 = v10[27];
  v16 = (*(int (__thiscall **)(_DWORD *))(*v10 + 40))(v10);
  v15 = (*(int (__thiscall **)(_DWORD *))(*v10 + 36))(v10);
  v14 = (*(int (__thiscall **)(_DWORD *))(*v10 + 112))(v10);
  v13 = (*(int (__thiscall **)(_DWORD *))(*v10 + 108))(v10);
  v11 = (*(int (__thiscall **)(_DWORD *))(*v10 + 116))(v10);
  v12 = sub_100029E0(
          (int)Block,
          v11,
          a5,
          v13,
          v14,
          a4,
          (_BYTE *)4,
          (_BYTE *)4,
          (_BYTE *)4,
          Blocka,
          v21,
          v8,
          100,
          a3,
          v15,
          v16,
          v17,
          v18,
          v19);
  this[19] = v12;
  if ( !v12 )
    return -1;
  v12[14] = 1;
  this[2] |= 1u;
  sub_1000BBF0(Blocka);
  sub_1000BBF0(v21);
  sub_1000BBF0(v8);
  return 0;
}
// 100010A0: using guessed type int arg_8;

//----- (10001230) --------------------------------------------------------
__int16 __thiscall sub_10001230(int **this)
{
  int v2; // eax
  int v3; // eax

  v2 = (*(int (__thiscall **)(int *))(*this[20] + 52))(this[20]);
  v3 = (*(int (__thiscall **)(int))(*(_DWORD *)v2 + 120))(v2);
  return sub_10001DC0(this[19], v3);
}

//----- (10001260) --------------------------------------------------------
__int16 __thiscall sub_10001260(int this)
{
  int v2; // eax
  char v3; // bl
  int v4; // edx

  v2 = *(_DWORD *)(this + 28);
  if ( v2 )
  {
    v3 = sub_1000C930(*(_DWORD *)(v2 + 4), 2);
    if ( (v3 & 0x20) != 0 )
    {
      sub_1000C6B0(0, 4, "MAIN_LOOP got terminate flag.");
      *(_WORD *)(this + 24) = 1;
    }
    if ( (v3 & 8) != 0 )
    {
      v4 = *(_DWORD *)(this + 20);
      *(_DWORD *)(this + 16) = *(_DWORD *)(this + 12);
      *(_DWORD *)(this + 12) = v4;
      return 0;
    }
    if ( (v3 & 0x10) != 0 )
      *(_DWORD *)(this + 12) = *(_DWORD *)(this + 16);
  }
  return 0;
}

//----- (100012C0) --------------------------------------------------------
int __thiscall sub_100012C0(char **this, unsigned int a2)
{
  int v2; // ebp
  int v4; // eax
  void **v5; // edi
  int v6; // eax
  char *v7; // eax
  char *v8; // eax
  char *v9; // eax
  int v11; // [esp-10h] [ebp-1Ch]
  int v12; // [esp-Ch] [ebp-18h]
  char *v13; // [esp-Ch] [ebp-18h]
  char *v14; // [esp-Ch] [ebp-18h]
  char *v15; // [esp-Ch] [ebp-18h]
  char *v16; // [esp-8h] [ebp-14h]
  int v17; // [esp+8h] [ebp-4h] BYREF

  v2 = 0;
  if ( a2 )
  {
    while ( 1 )
    {
      v4 = sub_10022B10(*((_DWORD *)this[19] + 1), &v17);
      v5 = (void **)v4;
      if ( !v4 )
        return v2;
      switch ( *(_DWORD *)(v4 + 24) )
      {
        case 1:
          v6 = (int)this[19];
          if ( *(_WORD *)v6 == 2 )
          {
            v16 = "MAIN: MessageLoop got TIMESYNC msg.";
            v12 = 2;
            v11 = 8;
            goto LABEL_46;
          }
          sub_1000C620(*(_DWORD *)(v6 + 204), 8, 2, "MAIN: MessageLoop: Server got wrong SYNCTIME msg !!!");
          goto LABEL_47;
        case 2:
          v13 = this[19];
          if ( *(_WORD *)v13 == 2 )
          {
            if ( sub_10004EA0((int)v13, v4) == -1 )
            {
              v16 = "MAIN: MessageLoop distritbute CUSTOMDATA failed.";
              v12 = 1;
              v11 = 16;
              goto LABEL_45;
            }
          }
          else if ( sub_10004E10((int)v13, v4) == -1 )
          {
            sub_1000C620(*((_DWORD *)this[19] + 51), 16, 1, "MAIN: MessageLoop distritbute CUSTOMDATA failed.");
          }
          goto LABEL_47;
        case 3:
          v6 = (int)this[19];
          if ( *(_WORD *)v6 != 1 )
          {
            v16 = "MAIN: MessageLoop: Client got wrong LOGMEON msg !!!";
            v12 = 2;
            v11 = 8;
            goto LABEL_46;
          }
          if ( sub_10005660(v6, (int)v5) )
            sub_1000C620(*((_DWORD *)this[19] + 51), 16, 1, "MAIN: MessageLoop could not log on client.");
          goto LABEL_47;
        case 4:
          v6 = (int)this[19];
          if ( *(_WORD *)v6 != 1 )
          {
            v16 = "MAIN: MessageLoop: Client got wrong LOGMEOFF msg !!!";
            v12 = 2;
            v11 = 8;
            goto LABEL_46;
          }
          if ( sub_100057D0(v6, (int)v5) )
            sub_1000C620(*((_DWORD *)this[19] + 51), 16, 1, "MAIN: MessageLoop could not log client off.");
          goto LABEL_47;
        case 5:
          v7 = this[19];
          if ( *(_WORD *)v7 == 2 )
          {
            sub_1000C620(*((_DWORD *)v7 + 51), 4, 8, "MAIN: MessageLoop got LOGONACCEPTED.");
            if ( sub_10004AA0(this[19], (int)v5) == -1 )
              sub_1000C620(*((_DWORD *)this[19] + 51), 16, 1, "MAIN: MessageLoop LOGONACCEPTED failed.");
          }
          else
          {
            sub_1000C620(*((_DWORD *)v7 + 51), 8, 2, "MAIN: MessageLoop: Server got wrong LOGONACCEPTED msg !!!");
          }
          goto LABEL_47;
        case 6:
          v8 = this[19];
          if ( *(_WORD *)v8 == 2 )
          {
            sub_1000C620(*((_DWORD *)v8 + 51), 4, 8, "MAIN: MessageLoop got LOGOFFACCEPTED.");
            if ( sub_10004BD0((int)this[19], (int)v5) == -1 )
            {
              v16 = "MAIN: MessageLoop LOGOFFACCEPTED failed.";
              v12 = 1;
              v11 = 16;
              goto LABEL_45;
            }
          }
          else
          {
            sub_1000C620(*((_DWORD *)v8 + 51), 8, 2, "MAIN: MessageLoop: Server got wrong LOGOFFACCEPTED msg !!!");
          }
          goto LABEL_47;
        case 8:
          if ( sub_10005940((int)this[19], *(_DWORD *)(v4 + 40)) )
          {
            v16 = "MAIN: MessageLoop could not remove user.";
            v12 = 1;
            v11 = 16;
            goto LABEL_45;
          }
          goto LABEL_47;
        case 9:
          if ( sub_10004C80((int *)this[19], *(SOCKET **)(v4 + 44)) )
            sub_1000C620(*((_DWORD *)this[19] + 51), 16, 1, "MAIN: MessageLoop could not init user.");
          goto LABEL_47;
        case 0xB:
          v9 = this[19];
          if ( *((_WORD *)v9 + 121) == 2 )
            sub_1000C620(*((_DWORD *)v9 + 51), 4, 8, "MAIN: MessageLoop got STAYINGALIVE msg.");
          goto LABEL_47;
        case 0xC:
          v15 = this[19];
          if ( *(_WORD *)v15 != 2 )
          {
            if ( sub_10004ED0((int)v15, (_DWORD *)v4) != -1 )
              goto LABEL_47;
LABEL_36:
            sub_1000C620(*((_DWORD *)this[19] + 51), 16, 1, "MAIN: MessageLoop distritbute FILE failed.");
            goto LABEL_47;
          }
          if ( sub_10004F60((int)v15, (_DWORD *)v4) == -1 )
            goto LABEL_36;
LABEL_47:
          sub_1000CAD0(v5);
          if ( ++v2 >= a2 )
            return v2;
          break;
        case 0xE:
          v14 = this[19];
          if ( *(_WORD *)v14 == 2 )
          {
            if ( sub_10004FC0((int)v14, v4) == -1 )
              sub_1000C620(*((_DWORD *)this[19] + 51), 16, 1, "MAIN: MessageLoop: Distribute GROUPDATA failed.");
          }
          else if ( sub_10003FC0((int)v14, v4) == -1 )
          {
            v16 = "MAIN: MessageLoop: Distribute GROUPDATA failed.";
            v12 = 1;
            v11 = 16;
            goto LABEL_45;
          }
          goto LABEL_47;
        default:
          v16 = "MAIN: MessageLoop got UNKNOWN msg type !!!";
          v12 = 2;
          v11 = 8;
LABEL_45:
          v6 = (int)this[19];
LABEL_46:
          sub_1000C620(*(_DWORD *)(v6 + 204), v11, v12, v16);
          goto LABEL_47;
      }
    }
  }
  return 0;
}

//----- (10001660) --------------------------------------------------------
int __thiscall sub_10001660(int this, unsigned int a2, unsigned int a3, int a4)
{
  int result; // eax
  unsigned int v6; // eax

  if ( a4 )
  {
    sub_100220A0((WORD *)(this + 40));
    v6 = *(unsigned __int16 *)(this + 50);
    if ( v6 > a2 || v6 == a2 && *(unsigned __int16 *)(this + 52) > a3 )
      sub_10022110((WORD *)(this + 40), 1);
    if ( sub_100220B0((WORD *)(this + 40), a2) && sub_100220E0((WORD *)(this + 40), a3) )
    {
      *(_QWORD *)(this + 64) = sub_10021FF0((unsigned __int16 *)(this + 40));
      result = 1;
      *(_DWORD *)(this + 72) = a4;
      *(_DWORD *)(this + 60) = 1;
    }
    else
    {
      return 0;
    }
  }
  else
  {
    *(_DWORD *)(this + 60) = 0;
    return 1;
  }
  return result;
}

//----- (100016F0) --------------------------------------------------------
void __thiscall sub_100016F0(int this)
{
  int v2; // eax
  WORD v3[10]; // [esp+4h] [ebp-14h] BYREF

  sub_100227B0(v3);
  if ( *(_DWORD *)(this + 60) )
  {
    if ( *(_DWORD *)(this + 76) )
    {
      sub_100220A0(v3);
      if ( (unsigned __int64)sub_10021FF0(v3) >= *(_QWORD *)(this + 64) )
      {
        if ( sub_10022140((WORD *)(this + 40), *(_DWORD *)(this + 72)) )
        {
          *(_QWORD *)(this + 64) = sub_10021FF0((unsigned __int16 *)(this + 40));
          v2 = sub_1000C150(0);
          sub_1000C1A0(v2);
          sub_1000C1A0(*(_DWORD *)(*(_DWORD *)(this + 76) + 208));
          sub_1000C1A0(*(_DWORD *)(*(_DWORD *)(this + 76) + 212));
          sub_1000C1A0(*(_DWORD *)(*(_DWORD *)(this + 76) + 204));
        }
        else
        {
          sub_1000C620(0, 16, -1, "PROGFLOW_NET::LOG_ProcessRotate: FAILED TO UPDATE TIMER, STOPPED LOG ROTATE !");
          *(_DWORD *)(this + 60) = 0;
        }
      }
    }
  }
  sub_10021FE0(v3);
}
// 100016F0: using guessed type WORD var_14[10];

//----- (100017E0) --------------------------------------------------------
int __thiscall sub_100017E0(void *this)
{
  int v2; // edi
  int v4; // [esp+8h] [ebp-4h]

  if ( (*((_BYTE *)this + 12) & 1) != 0 )
    sub_10001260((int)this);
  sub_10004790(*((_DWORD *)this + 19));
  sub_10022D20(*(_DWORD *)(*((_DWORD *)this + 19) + 200), *(_DWORD *)(*((_DWORD *)this + 19) + 56), 1);
  if ( (*((_BYTE *)this + 12) & 2) != 0 )
  {
    v2 = (*(int (__thiscall **)(void *, _DWORD))(*(_DWORD *)this + 16))(this, *((_DWORD *)this + 8));
    sub_100016F0((int)this);
    return v2;
  }
  else
  {
    sub_100016F0((int)this);
    return v4;
  }
}
// 1000183D: variable 'v4' is possibly undefined

//----- (10001850) --------------------------------------------------------
__int16 __cdecl sub_10001850(int a1, DWORD dwMilliseconds)
{
  int v3; // ecx
  __int16 i; // ax
  int v5; // edi
  int v6; // esi
  int v7; // eax

  if ( sub_1000E090(**(_DWORD **)(a1 + 192), 0xFFFFFFFF) )
  {
    v3 = *(_DWORD *)(*(_DWORD *)(a1 + 192) + 4);
    for ( i = *(_WORD *)(v3 + 12); i != -1; i = *(_WORD *)(*(_DWORD *)(v3 + 8) + v5 + 4) )
    {
      v5 = 12 * i;
      v6 = *(_DWORD *)(*(_DWORD *)(v3 + 8) + v5 + 8);
      if ( sub_1000E090(*(_DWORD *)(v6 + 4), 0xFFFFFFFF) )
      {
        if ( sub_10005CC0((_BYTE *)v6) && (sub_1000C930(*(_DWORD *)(*(_DWORD *)(v6 + 8) + 40), 1) & 0x800) != 0 )
        {
          if ( *(_WORD *)(a1 + 240) == 2 )
            sub_1000C620(*(_DWORD *)(a1 + 204), 4, 16, "Server Thread: lost connection from reader reported.");
          v7 = *(_DWORD *)(v6 + 12);
          if ( v7 )
            sub_1000C8D0(*(_DWORD *)(v7 + 40), 8, 1);
          if ( sub_100039F0(a1, (_BYTE *)v6) )
            sub_1000C620(*(_DWORD *)(a1 + 204), 16, 1, "Server Thread: Cannot send usr remove msg.");
        }
        if ( sub_1000E0E0(*(_DWORD *)(v6 + 4)) == -1 )
          sub_1000C7C0(
            "NETDRV::NETDRV_ServerLookForFlags(): unlocking usr->mutex failed (%p)!",
            *(_DWORD *)(*(_DWORD *)(v6 + 4) + 4));
      }
      else
      {
        sub_1000C7C0(
          "NETDRV:: NETDRV_ServerLookForFlags() ...locking mutx usr->mutex (%p) failed !",
          *(_DWORD *)(*(_DWORD *)(v6 + 4) + 4));
      }
      v3 = *(_DWORD *)(*(_DWORD *)(a1 + 192) + 4);
    }
    if ( sub_1000E0E0(**(_DWORD **)(a1 + 192)) == -1 )
      sub_1000C7C0(
        "NETDRV::NETDRV_ServerLookForFlags(): unlocking drv->usrlst->mutex (%p) failed !",
        *(const void **)(**(_DWORD **)(a1 + 192) + 4));
    sub_1000DDA0(dwMilliseconds);
    return 0;
  }
  else
  {
    sub_1000C7C0("NETDRV::NETDRV_ServerLookForFlags() ...locking drv->usrlst->mutex failed !");
    return 0;
  }
}

//----- (100019E0) --------------------------------------------------------
__int16 __cdecl sub_100019E0(HANDLE **Block)
{
  HANDLE **v1; // esi
  int v2; // eax
  void **i; // eax

  v1 = Block;
  v2 = (int)Block[21];
  if ( v2 )
  {
    for ( i = (void **)sub_10022B10(v2, &Block); i; i = (void **)sub_10022B10((int)v1[21], &Block) )
      sub_1000CAD0(i);
    sub_10022A00((int *)v1[21], 1);
    v1[21] = 0;
  }
  sub_1000E2A0(v1[23]);
  if ( (unsigned __int16)sub_1000E1E0(*v1) == 0xFFFF )
  {
    sub_1000C7C0("NETDRV_RemoveCondataStruct: start removeing...mutx destoy - failed !");
    return -1;
  }
  else
  {
    j__free(v1);
    return 0;
  }
}

//----- (10001A70) --------------------------------------------------------
__int16 __cdecl sub_10001A70(char *Format, int ArgList)
{
  int v2; // edx
  __int16 result; // ax
  int v4; // [esp-4h] [ebp-8h]

  sub_1000E090(*(_DWORD *)Format, 0xFFFFFFFF);
  v2 = *((_DWORD *)Format + 7) + 1;
  *((_DWORD *)Format + 6) += ArgList;
  *((_DWORD *)Format + 7) = v2;
  sub_10022500((int *)Format + 2);
  v4 = *(_DWORD *)Format;
  *((_DWORD *)Format + 26) |= 1u;
  result = sub_1000E0E0(v4);
  if ( result == -1 )
    return sub_1000C7C0(
             "NETDRV_UpdateCondataStatistics: unlocking mutx(%p) - failed ! ",
             *(const void **)(*(_DWORD *)Format + 4));
  return result;
}

//----- (10001AD0) --------------------------------------------------------
int __cdecl sub_10001AD0(int a1)
{
  unsigned int v1; // edi

  v1 = sub_10005F70(a1);
  if ( sub_1000E090(*(_DWORD *)(a1 + 132), 0xFFFFFFFF) )
  {
    if ( !*(_DWORD *)(a1 + 144) || v1 >= *(_DWORD *)(a1 + 136) && *(_WORD *)(a1 + 140) == 1 )
    {
      sub_1000E0E0(*(_DWORD *)(a1 + 132));
      return 0;
    }
    else
    {
      if ( sub_1000E0E0(*(_DWORD *)(a1 + 132)) == -1 )
        sub_1000C7C0("NETDRV::NETDRV_ServerLookForFlags(): unlocking varblock mutex failed !");
      return 1;
    }
  }
  else
  {
    sub_1000C7C0("NETDRV::NETDRV_CheckAcceptConnections() ...locking varblock mutex failed !");
    return 0;
  }
}

//----- (10001B80) --------------------------------------------------------
__int16 __cdecl sub_10001B80(char *Format)
{
  __int16 result; // ax
  int v2; // [esp-4h] [ebp-8h]

  if ( !sub_1000E090(*((_DWORD *)Format + 33), 0xFFFFFFFF) )
    return sub_1000C7C0("NETDRV::NETDRV_IncomingConnections_Start() ...locking varblock mutex failed !");
  v2 = *((_DWORD *)Format + 33);
  *((_DWORD *)Format + 36) = 1;
  result = sub_1000E0E0(v2);
  if ( result == -1 )
    return sub_1000C7C0("NETDRV::NETDRV_IncomingConnections_Start(): unlocking varblock mutex failed !");
  return result;
}

//----- (10001BE0) --------------------------------------------------------
__int16 __cdecl sub_10001BE0(char *Format)
{
  __int16 result; // ax
  int v2; // [esp-4h] [ebp-8h]

  if ( !sub_1000E090(*((_DWORD *)Format + 33), 0xFFFFFFFF) )
    return sub_1000C7C0("NETDRV::NETDRV_IncomingConnections_Stop() ...locking varblock mutex failed !");
  v2 = *((_DWORD *)Format + 33);
  *((_DWORD *)Format + 36) = 0;
  result = sub_1000E0E0(v2);
  if ( result == -1 )
    return sub_1000C7C0("NETDRV::NETDRV_IncomingConnections_Stop(): unlocking varblock mutex failed !");
  return result;
}

//----- (10001C40) --------------------------------------------------------
__int16 __cdecl sub_10001C40(int a1, unsigned int a2, __int16 a3)
{
  __int16 result; // ax
  unsigned int v4; // eax
  unsigned int *v5; // edx

  if ( !sub_1000E090(*(_DWORD *)(a1 + 132), 0xFFFFFFFF) )
    return sub_1000C7C0("NETDRV::NETDRV_IncomingConnections_Stop() ...locking varblock mutex failed !");
  v4 = a2;
  if ( a2 != -1 )
  {
    v5 = *(unsigned int **)(*(_DWORD *)(a1 + 192) + 12);
    if ( a2 > *v5 )
      v4 = *v5;
    *(_DWORD *)(a1 + 136) = v4;
  }
  if ( a3 != 2 )
    *(_WORD *)(a1 + 140) = a3;
  result = sub_1000E0E0(*(_DWORD *)(a1 + 132));
  if ( result == -1 )
    return sub_1000C7C0("NETDRV::NETDRV_IncomingConnections_Stop(): unlocking varblock mutex failed !");
  return result;
}

//----- (10001CC0) --------------------------------------------------------
__int16 __cdecl sub_10001CC0(void *Block)
{
  void *v1; // eax
  void *v2; // edi
  void *v3; // eax
  int *v4; // eax

  v1 = (void *)*((_DWORD *)Block + 54);
  *((_DWORD *)Block + 58) = 0;
  if ( v1 )
    sub_1000CA80(v1);
  v2 = (void *)*((_DWORD *)Block + 59);
  if ( v2 )
  {
    sub_10003570(*((void **)Block + 59));
    j__free(v2);
  }
  v3 = (void *)*((_DWORD *)Block + 50);
  if ( v3 )
    sub_10022EA0(v3, 1);
  if ( *((_DWORD *)Block + 48) )
    sub_10006630((int)Block);
  v4 = (int *)*((_DWORD *)Block + 1);
  if ( v4 )
    sub_10022A00(v4, 1);
  if ( *((_DWORD *)Block + 49) )
    sub_100230C0(*((void ***)Block + 49));
  if ( *((_DWORD *)Block + 51) )
    sub_1000C300(*((void **)Block + 51));
  if ( *((_DWORD *)Block + 52) )
    sub_1000C300(*((void **)Block + 52));
  if ( *((_DWORD *)Block + 53) )
    sub_1000C300(*((void **)Block + 53));
  if ( *((_DWORD *)Block + 2) )
    sub_1000E1E0(*((HANDLE **)Block + 2));
  if ( *((_DWORD *)Block + 33) )
    sub_1000E1E0(*((HANDLE **)Block + 33));
  return sub_1000BBF0(Block);
}

//----- (10001DC0) --------------------------------------------------------
__int16 __cdecl sub_10001DC0(int *a1, int a2)
{
  sub_1000C620(a1[51], 4, 4, "Net Driver: removing...");
  sub_100062C0((int)a1);
  sub_1000C620(a1[51], 4, 4, "Net Driver: deleting master thread.");
  sub_1000E3E0((int)(a1 + 3), a2 + 5000);
  sub_1000E440((int)(a1 + 3));
  sub_10001CC0(a1);
  sub_1000C620(0, 4, 4, "Net Driver: REMOVED !");
  return 0;
}

//----- (10001E40) --------------------------------------------------------
__int16 __cdecl sub_10001E40(int a1, int a2)
{
  __int16 v2; // bx
  SOCKET *v4; // edi
  _DWORD *v5; // eax

  v2 = 0;
  if ( !sub_10001AD0(a1) )
    return 0;
  v4 = sub_1000CF10(*(_DWORD *)(a1 + 220), a2, *(_DWORD *)(a1 + 204));
  if ( !v4 )
    return v2;
  if ( *(_DWORD *)(a1 + 184) == 1 && !sub_1000D130(*v4, *(_DWORD *)(a1 + 204), 1) )
  {
    sub_1000C620(*(_DWORD *)(a1 + 204), 16, 1, "NETDRV_ServerLookForNewConnection: cannot disable nagle.");
    sub_1000CD60(v4);
    return 0;
  }
  v5 = sub_1000CAA0(0, 0);
  if ( v5 )
  {
    v5[6] = 9;
    v5[8] = 0;
    v5[7] = 0;
    v5[10] = 0;
    v5[11] = v4;
    sub_10022A90(*(_DWORD **)(a1 + 4), (int)v5, 0);
    return 1;
  }
  sub_1000C620(*(_DWORD *)(a1 + 204), 16, 1, "NETDRV_ServerLookForNewConnection: cannot create msg.");
  sub_1000CD60(v4);
  return -1;
}

//----- (10001F30) --------------------------------------------------------
__int16 __cdecl sub_10001F30(int a1, HANDLE **Block)
{
  __int16 v2; // di

  v2 = 0;
  if ( (unsigned __int16)sub_1000E3E0((int)(Block + 9), *(_DWORD *)(a1 + 60)) )
  {
    sub_1000C7C0("NETDRV::NETDRV_RemoveReaderThread()...failed !");
    v2 = -1;
  }
  sub_1000E440((int)(Block + 9));
  if ( sub_100019E0(Block) )
    return -1;
  else
    return v2;
}

//----- (10001F90) --------------------------------------------------------
void __stdcall __noreturn StartAddress(_DWORD *lpThreadParameter)
{
  _DWORD *v1; // edi
  int v2; // ebx
  int v3; // esi
  _BOOL2 v4; // bp
  char v5; // al
  void **v7; // eax
  void **v8; // edi
  int v9; // edx
  int v10; // [esp-8h] [ebp-1Ch]
  char *v11; // [esp-4h] [ebp-18h]
  int v12; // [esp-4h] [ebp-18h]
  int v13; // [esp+10h] [ebp-4h]

  v1 = lpThreadParameter;
  v2 = lpThreadParameter[2];
  v3 = *lpThreadParameter;
  v4 = (lpThreadParameter[3] & 1) == 0;
  sub_1000C8D0(*(_DWORD *)(v2 + 40), 64, 2);
  if ( *(_WORD *)(v3 + 240) == 2 )
    sub_1000C620(*(_DWORD *)(v3 + 204), 1, 4, "Reader thread: running.");
  v10 = *(_DWORD *)(v2 + 40);
  v13 = *(_DWORD *)(v3 + 164);
  ++*(_DWORD *)(v2 + 4);
  v5 = sub_1000C930(v10, 2);
  if ( (v5 & 0x20) != 0 )
  {
LABEL_13:
    if ( *(_WORD *)(v3 + 240) == 2 )
    {
      sub_1000C620(*(_DWORD *)(v3 + 204), 1, 4, "Reader thread: got TERMINATE signal.");
      if ( *(_WORD *)(v3 + 240) == 2 )
        sub_1000C620(*(_DWORD *)(v3 + 204), 1, 4, "Reader thread: exiting...");
    }
    sub_1000E3B0(v1[1], 0);
  }
  while ( 1 )
  {
    if ( (v5 & 8) != 0 )
    {
      if ( *(_WORD *)(v3 + 240) == 2 )
        sub_1000C620(*(_DWORD *)(v3 + 204), 4, 4, "Reader thread: got STOP signal.");
      v4 = 0;
    }
    else
    {
      if ( (v5 & 0x10) != 0 )
      {
        if ( *(_WORD *)(v3 + 240) == 2 )
          sub_1000C620(*(_DWORD *)(v3 + 204), 4, 4, "Reader thread: got RESUME signal.");
        v4 = 1;
LABEL_22:
        v7 = (void **)sub_1000CC50(*(SOCKET **)(v2 + 100), *(_DWORD *)(v3 + 228), *(_DWORD *)(v3 + 204));
        v8 = v7;
        if ( v7 )
        {
          switch ( *(_WORD *)v7 )
          {
            case 1:
              sub_1000C620(*(_DWORD *)(v3 + 204), 8, 2, "Reader detected: socket error, STOP!");
              goto LABEL_35;
            case 2:
              v11 = "Reader detected: connection lost, STOP!";
              goto LABEL_34;
            case 3:
              sub_1000C620(*(_DWORD *)(v3 + 204), 8, 2, "Reader detected: no memory for packet, STOP!");
              goto LABEL_35;
            case 4:
              v7[10] = *(void **)(v2 + 96);
              v7[11] = *(void **)(v2 + 100);
              sub_10022A90(*(_DWORD **)(v3 + 4), (int)v7, 0);
              sub_1000C8D0(*(_DWORD *)(v2 + 40), 1024, 2);
              sub_10001A70((char *)v2, (int)v8[2]);
              if ( sub_1000E090(*(_DWORD *)(v3 + 132), 0xFFFFFFFF) )
              {
                v9 = *(_DWORD *)(v3 + 160) + 1;
                v12 = *(_DWORD *)(v3 + 132);
                *(_DWORD *)(v3 + 156) += v8[2];
                *(_DWORD *)(v3 + 160) = v9;
                sub_1000E0E0(v12);
              }
              goto LABEL_9;
            case 5:
              sub_1000C620(*(_DWORD *)(v3 + 204), 8, 2, "Reader detected: stray data. no effect.");
              goto LABEL_9;
            case 6:
              sub_1000C620(*(_DWORD *)(v3 + 204), 8, 2, "Reader detected: foreign packet. no effect.");
              goto LABEL_9;
            case 7:
              sub_1000C620(*(_DWORD *)(v3 + 204), 8, 2, "Reader detected: packet not complete, no effect");
              goto LABEL_9;
            default:
              v11 = "Reader detected: unknown error, STOP!";
              goto LABEL_34;
          }
        }
        v11 = "Reader thread: got empty envelope, receive failed.";
LABEL_34:
        sub_1000C620(*(_DWORD *)(v3 + 204), 8, 2, v11);
LABEL_35:
        if ( *(_WORD *)(v3 + 240) == 2 )
          sub_1000C620(*(_DWORD *)(v3 + 204), 4, 4, "Reader thread: detected problems with client connection.");
        sub_1000C8D0(*(_DWORD *)(lpThreadParameter[1] + 4), 2048, 2);
        if ( v8 )
          sub_1000CAD0(v8);
        v4 = 0;
        goto LABEL_9;
      }
      if ( v4 )
        goto LABEL_22;
    }
    sub_1000DDA0(*(_DWORD *)(v3 + 108));
LABEL_9:
    if ( v13-- == 0 )
    {
      v13 = *(_DWORD *)(v3 + 164);
      sub_1000E480();
    }
    ++*(_DWORD *)(v2 + 4);
    v5 = sub_1000C930(*(_DWORD *)(v2 + 40), 2);
    if ( (v5 & 0x20) != 0 )
    {
      v1 = lpThreadParameter;
      goto LABEL_13;
    }
  }
}

//----- (100022D0) --------------------------------------------------------
__int16 __cdecl sub_100022D0(int a1, void *Block)
{
  __int16 v2; // bx

  v2 = 0;
  if ( *((_DWORD *)Block + 23) )
  {
    sub_1000C8D0(*((_DWORD *)Block + 10), 8, 1);
    sub_1000E2D0(*((HANDLE **)Block + 23));
  }
  if ( (unsigned __int16)sub_1000E3E0((int)Block + 36, *(_DWORD *)(a1 + 60)) )
  {
    sub_1000C7C0("NETDRV::NETDRV_RemoveWriterThread()...failed !");
    v2 = -1;
  }
  sub_1000E440((int)Block + 36);
  if ( !sub_100019E0((HANDLE **)Block) )
    return v2;
  sub_1000C7C0("NETDRV::NETDRV_RemoveWriterThread()...NETDRV_RemoveCondataStruct(%p)... failed!", Block);
  return -1;
}

//----- (10002360) --------------------------------------------------------
void __stdcall __noreturn sub_10002360(_DWORD *lpThreadParameter)
{
  _DWORD *v1; // ebx
  int v2; // esi
  int v3; // edi
  int v4; // ecx
  char v5; // al
  void **v6; // ebx
  __int16 v7; // bp
  int v8; // ebp
  int v9; // edx
  int v10; // ebp
  HANDLE *v11; // [esp-4h] [ebp-20h]
  int v12; // [esp-4h] [ebp-20h]
  int v13; // [esp-4h] [ebp-20h]
  _BOOL2 v14; // [esp+10h] [ebp-Ch]
  int v15; // [esp+14h] [ebp-8h] BYREF
  int v16; // [esp+18h] [ebp-4h]

  v1 = lpThreadParameter;
  v2 = lpThreadParameter[2];
  v3 = *lpThreadParameter;
  v14 = (lpThreadParameter[3] & 1) == 0;
  sub_1000C8D0(*(_DWORD *)(lpThreadParameter[1] + 4), 64, 2);
  if ( *(_WORD *)(v3 + 240) == 2 )
    sub_1000C620(*(_DWORD *)(v3 + 204), 1, 4, "Writer thread: running.");
  v4 = *(_DWORD *)(v3 + 168);
  ++*(_DWORD *)(v2 + 4);
  v11 = *(HANDLE **)(v2 + 92);
  v16 = v4;
  sub_1000E310(v11);
  v5 = sub_1000C930(*(_DWORD *)(v2 + 40), 2);
  if ( (v5 & 0x20) != 0 )
  {
LABEL_10:
    if ( *(_WORD *)(v3 + 240) == 2 )
    {
      sub_1000C620(*(_DWORD *)(v3 + 204), 4, 4, "Writer thread: got TERMINATE signal.");
      if ( *(_WORD *)(v3 + 240) == 2 )
        sub_1000C620(*(_DWORD *)(v3 + 204), 1, 4, "Writer thread: exiting...");
    }
    sub_1000E3B0(v1[1], 0);
  }
  while ( 1 )
  {
    if ( (v5 & 8) != 0 )
    {
      if ( *(_WORD *)(v3 + 240) == 2 )
        sub_1000C620(*(_DWORD *)(v3 + 204), 4, 4, "Writer thread: got STOP signal.");
      v14 = 0;
    }
    else
    {
      if ( (v5 & 0x10) != 0 )
      {
        v14 = 1;
LABEL_17:
        v6 = (void **)sub_10022B10(*(_DWORD *)(v2 + 84), &v15);
        if ( v6 )
        {
          while ( 1 )
          {
            v7 = sub_1000CBC0(*(SOCKET **)(v2 + 100), (int)v6, *(_DWORD *)(v3 + 228), *(_DWORD *)(v3 + 204));
            sub_1000CAD0(v6);
            if ( v7 )
            {
              sub_1000C620(*(_DWORD *)(v3 + 204), 8, 2, "Writer thread: error sending data !");
            }
            else
            {
              v8 = v15;
              sub_1000E090(*(_DWORD *)v2, 0xFFFFFFFF);
              v9 = v8 + *(_DWORD *)(v2 + 24);
              ++*(_DWORD *)(v2 + 28);
              *(_DWORD *)(v2 + 24) = v9;
              sub_10022500((int *)(v2 + 8));
              v12 = *(_DWORD *)v2;
              *(_DWORD *)(v2 + 104) |= 1u;
              if ( sub_1000E0E0(v12) == -1 )
                sub_1000C7C0(
                  "NETDRV_UpdateCondataStatistics: unlocking mutx(%p) - failed ! ",
                  *(const void **)(*(_DWORD *)v2 + 4));
              if ( sub_1000E090(*(_DWORD *)(v3 + 132), 0xFFFFFFFF) )
              {
                v10 = *(_DWORD *)(v3 + 152);
                *(_DWORD *)(v3 + 148) += v15;
                v13 = *(_DWORD *)(v3 + 132);
                *(_DWORD *)(v3 + 152) = v10 + 1;
                sub_1000E0E0(v13);
              }
            }
            if ( !--v16 )
              break;
            v6 = (void **)sub_10022B10(*(_DWORD *)(v2 + 84), &v15);
            if ( !v6 )
              goto LABEL_26;
          }
          sub_1000E480();
        }
        else
        {
LABEL_26:
          sub_1000E2F0(*(HANDLE **)(v2 + 92));
        }
        v1 = lpThreadParameter;
        v16 = *(_DWORD *)(v3 + 168);
        goto LABEL_9;
      }
      if ( v14 )
        goto LABEL_17;
    }
    sub_1000DDA0(*(_DWORD *)(v3 + 116));
LABEL_9:
    ++*(_DWORD *)(v2 + 4);
    sub_1000E310(*(HANDLE **)(v2 + 92));
    v5 = sub_1000C930(*(_DWORD *)(v2 + 40), 2);
    if ( (v5 & 0x20) != 0 )
      goto LABEL_10;
  }
}
// 100025E0: conditional instruction was optimized away because ebx.4!=0

//----- (10002610) --------------------------------------------------------
int *__cdecl sub_10002610(__int16 a1, int a2)
{
  int *v2; // eax
  int *v3; // esi
  _DWORD *v4; // eax
  _DWORD *v6; // eax
  _DWORD *v7; // eax

  v2 = (int *)operator new(0x6Cu);
  v3 = v2;
  if ( !v2 )
    return 0;
  sub_10022170(v2 + 2);
  sub_10022170(v3 + 4);
  v4 = sub_1000E120(2);
  *v3 = (int)v4;
  if ( !v4 )
  {
    j__free(v3);
    return 0;
  }
  v6 = sub_1000E240(1, 0);
  v3[23] = (int)v6;
  if ( !v6 )
    goto LABEL_8;
  sub_10022500(v3 + 2);
  sub_10022500(v3 + 4);
  v3[6] = 0;
  v3[7] = 0;
  v3[1] = 0;
  v3[26] = 0;
  *((_WORD *)v3 + 16) = a1;
  *((_WORD *)v3 + 17) = 0;
  v3[25] = a2;
  if ( a1 == 3535 )
  {
    v7 = sub_100229A0();
    v3[21] = (int)v7;
    if ( !v7 )
    {
LABEL_8:
      sub_1000E1E0((HANDLE *)*v3);
      j__free(v3);
      return 0;
    }
  }
  else
  {
    v3[21] = 0;
  }
  return v3;
}

//----- (100026E0) --------------------------------------------------------
void __stdcall __noreturn sub_100026E0(int *lpThreadParameter)
{
  int v1; // esi
  SOCKET *v2; // eax
  int v3; // edi
  SOCKET *v4; // eax
  int v5; // eax

  v1 = *lpThreadParameter;
  if ( *(_WORD *)*lpThreadParameter == 1 )
  {
    v2 = sub_1000CD90(*(_WORD *)(*(_DWORD *)(v1 + 216) + 400), *(_DWORD *)(v1 + 204));
    *(_DWORD *)(v1 + 220) = v2;
    if ( !v2 )
    {
      sub_1000C620(*(_DWORD *)(v1 + 204), 16, 1, "Server thread: Cannot start read connection for incoming.");
      sub_1000E3B0(lpThreadParameter[1], 0xFFFFFFFF);
    }
  }
  sub_1000C8D0(*(_DWORD *)(lpThreadParameter[1] + 4), 64, 2);
  sub_1000C620(*(_DWORD *)(v1 + 204), 4, 4, "Server thread: running.");
  v3 = 1;
  while ( 1 )
  {
    sub_10001850(v1, *(_DWORD *)(v1 + 76));
    if ( *(_WORD *)v1 != 1 )
      goto LABEL_12;
    if ( !v3 )
      goto LABEL_9;
    if ( !sub_10001AD0(v1) )
      break;
LABEL_11:
    sub_10001E40(v1, *(_DWORD *)(v1 + 64));
LABEL_12:
    if ( sub_1000E460(lpThreadParameter[1]) )
    {
      sub_1000C620(*(_DWORD *)(v1 + 204), 4, 4, "Server thread: got terminate signal.");
      goto LABEL_17;
    }
    if ( *(_WORD *)(v1 + 128) )
      sub_1000DDA0(*(_DWORD *)(v1 + 124));
  }
  v3 = 0;
  sub_1000CD60(*(SOCKET **)(v1 + 220));
  *(_DWORD *)(v1 + 220) = 0;
LABEL_9:
  if ( sub_10001AD0(v1) )
  {
    v3 = 1;
    v4 = sub_1000CD90(*(_WORD *)(*(_DWORD *)(v1 + 216) + 400), *(_DWORD *)(v1 + 204));
    *(_DWORD *)(v1 + 220) = v4;
    if ( !v4 )
    {
      sub_1000C620(*(_DWORD *)(v1 + 204), 16, 1, "Server thread: Cannot start read connection for incoming.");
LABEL_17:
      if ( *(_WORD *)v1 == 1 && *(_DWORD *)(v1 + 220) )
        sub_1000CD60(*(SOCKET **)(v1 + 220));
      v5 = *(_DWORD *)(v1 + 204);
      *(_DWORD *)(v1 + 220) = 0;
      sub_1000C620(v5, 4, 4, "Server thread: exiting...");
      sub_1000E3B0(lpThreadParameter[1], 0);
    }
  }
  goto LABEL_11;
}

//----- (100028A0) --------------------------------------------------------
HANDLE **__cdecl sub_100028A0(int a1, int a2, __int16 a3)
{
  int *v3; // eax
  HANDLE **v4; // esi

  v3 = sub_10002610(1212, a2);
  v4 = (HANDLE **)v3;
  if ( v3 )
  {
    v3[25] = a2;
    v3[13] = a1;
    v3[14] = (int)(v3 + 9);
    v3[15] = (int)v3;
    *((_WORD *)v3 + 32) = a3;
    if ( sub_1000E340((int)(v3 + 9), (LPTHREAD_START_ROUTINE)StartAddress, v3 + 13, 1, *(_DWORD *)(a1 + 172)) == -1 )
    {
      sub_1000C620(*(_DWORD *)(a1 + 204), 16, 1, "Start reader thread: create thread failed !");
      sub_100019E0(v4);
      return 0;
    }
    else
    {
      return v4;
    }
  }
  else
  {
    sub_1000C620(*(_DWORD *)(a1 + 204), 16, 1, "Start reader thread: cannot alloc condata struct !");
    return 0;
  }
}

//----- (10002940) --------------------------------------------------------
HANDLE **__cdecl sub_10002940(int a1, int a2, __int16 a3)
{
  int *v3; // eax
  HANDLE **v4; // esi

  v3 = sub_10002610(3535, a2);
  v4 = (HANDLE **)v3;
  if ( v3 )
  {
    v3[25] = a2;
    v3[17] = a1;
    v3[18] = (int)(v3 + 9);
    v3[19] = (int)v3;
    *((_WORD *)v3 + 40) = a3;
    if ( sub_1000E340((int)(v3 + 9), (LPTHREAD_START_ROUTINE)sub_10002360, v3 + 17, 1, *(_DWORD *)(a1 + 176)) == -1 )
    {
      sub_1000C620(*(_DWORD *)(a1 + 204), 16, 1, "Start writer thread: create thread failed !");
      sub_100019E0(v4);
      return 0;
    }
    else
    {
      return v4;
    }
  }
  else
  {
    sub_1000C620(*(_DWORD *)(a1 + 204), 16, 1, "Start writer thread: no connect struct !");
    return 0;
  }
}

//----- (100029E0) --------------------------------------------------------
_DWORD *__cdecl sub_100029E0(
        int a1,
        int a2,
        WORD a3,
        int a4,
        int a5,
        int a6,
        _BYTE *ArgList,
        _BYTE *a8,
        _BYTE *a9,
        const char *a10,
        const char *a11,
        const char *a12,
        __int16 a13,
        __int16 a14,
        int a15,
        int a16,
        int a17,
        int a18,
        int a19)
{
  _DWORD *v19; // esi
  char *v20; // eax
  _DWORD *v22; // eax
  char *v23; // eax
  _BYTE *v24; // ebp
  const char *v25; // edi
  _DWORD *v26; // eax
  char *v27; // eax
  char *v28; // edi
  int v29; // ebp
  _DWORD *v30; // eax
  char *v31; // edi
  int v32; // ebp
  _DWORD *v33; // eax
  _DWORD *v34; // eax
  _DWORD *v35; // eax
  DNameNode *v36; // eax
  DNameNode *v37; // eax
  _DWORD *v38; // eax
  _DWORD *v39; // eax
  _DWORD *v40; // eax
  struct WSAData *v41; // eax
  __int16 v42; // di
  _DWORD *v43; // eax
  _DWORD *v44; // eax
  _WORD *v45; // eax
  _WORD *v46; // eax
  SIZE_T v47; // [esp-28h] [ebp-A0h]
  char *v48; // [esp-18h] [ebp-90h]
  char *v49; // [esp-18h] [ebp-90h]
  char *v50; // [esp-18h] [ebp-90h]
  char *v51; // [esp-18h] [ebp-90h]
  char *v52; // [esp-18h] [ebp-90h]
  char *v53; // [esp-10h] [ebp-88h]
  char *v54; // [esp-10h] [ebp-88h]
  char *v55; // [esp-10h] [ebp-88h]
  int v56; // [esp-Ch] [ebp-84h]
  int v57; // [esp-Ch] [ebp-84h]
  char v58[12]; // [esp+8h] [ebp-70h] BYREF
  char Buffer[100]; // [esp+14h] [ebp-64h] BYREF

  strcpy(v58, "NETDRV_Init");
  v19 = sub_1000BB40(248);
  if ( !v19 )
  {
    sub_100031F0(-7);
    v20 = sub_10003240();
    sub_1000C6F0(0, 4, "%s::%s: Neterror: %s", aNetdrv, v58, v20);
    return 0;
  }
  *(_WORD *)v19 = a14;
  v19[57] = a5;
  v19[41] = a15;
  v19[42] = a16;
  v19[58] = a1;
  v19[43] = a17;
  v19[51] = 0;
  v19[52] = 0;
  v19[53] = 0;
  v19[49] = 0;
  v19[50] = 0;
  v19[48] = 0;
  v19[1] = 0;
  v19[2] = 0;
  v19[54] = 0;
  v19[59] = 0;
  v19[47] = 0;
  v19[46] = 0;
  v19[44] = a18;
  v19[45] = a19;
  v19[33] = 0;
  v19[36] = 0;
  v19[34] = a6;
  *((_WORD *)v19 + 70) = 0;
  v19[39] = 0;
  v19[40] = 0;
  v19[37] = 0;
  v19[38] = 0;
  v22 = sub_1000E120(2);
  v19[33] = v22;
  if ( !v22 )
  {
    sub_100031F0(-13);
    v23 = sub_10003240();
    sub_1000C6F0(0, 4, "%s::%s: Neterror: %s", aNetdrv, v58, v23);
    sub_10001CC0(v19);
    return 0;
  }
  v24 = ArgList;
  v25 = a10;
  v26 = sub_1000BEB0(1024, ArgList, a10);
  v19[51] = v26;
  if ( !v26 )
    goto LABEL_6;
  v28 = asc_10047068;
  v29 = 6;
  do
  {
    sub_1000C6D0(v19[51], v28);
    v28 += 84;
    --v29;
  }
  while ( v29 );
  sub_1000C620(v19[51], 4, 4, "Net Driver: Starting new driver.");
  v25 = a11;
  v24 = a8;
  v30 = sub_1000BEB0(1024, a8, a11);
  v19[52] = v30;
  if ( !v30 )
    goto LABEL_6;
  v31 = asc_10047068;
  v32 = 6;
  do
  {
    sub_1000C6D0(v19[52], v31);
    v31 += 84;
    --v32;
  }
  while ( v32 );
  *(_DWORD *)(v19[51] + 16) |= 8u;
  sub_1000C620(v19[51], 64, 4, "Net Driver: Starting up...");
  v25 = a12;
  v24 = a9;
  v33 = sub_1000BEB0(1024, a9, a12);
  v19[53] = v33;
  if ( !v33 )
  {
LABEL_6:
    sub_10003210(-8, "output: %d filename: %s", v24, v25);
    v27 = sub_10003240();
    sub_1000C6F0(0, 4, "%s::%s: Neterror: %s", aNetdrv, v58, v27);
    sub_10001CC0(v19);
    return 0;
  }
  v19[25] = *(_DWORD *)(a2 + 40);
  v19[24] = *(_DWORD *)(a2 + 36);
  v19[26] = *(_DWORD *)(a2 + 44);
  v19[23] = *(_DWORD *)(a2 + 32);
  v19[19] = *(_DWORD *)(a2 + 16);
  v19[17] = *(_DWORD *)(a2 + 8);
  v19[18] = *(_DWORD *)(a2 + 12);
  v19[16] = *(_DWORD *)(a2 + 4);
  v19[20] = *(_DWORD *)(a2 + 20);
  v19[21] = *(_DWORD *)(a2 + 24);
  v19[22] = *(_DWORD *)(a2 + 28);
  v19[27] = *(_DWORD *)(a2 + 48);
  *((_WORD *)v19 + 56) = *(_WORD *)(a2 + 52);
  v19[29] = *(_DWORD *)(a2 + 56);
  *((_WORD *)v19 + 60) = *(_WORD *)(a2 + 60);
  v19[31] = *(_DWORD *)(a2 + 64);
  *((_WORD *)v19 + 64) = *(_WORD *)(a2 + 68);
  v19[15] = *(_DWORD *)a2;
  *((_WORD *)v19 + 120) = 1;
  *((_WORD *)v19 + 121) = 1;
  *((_WORD *)v19 + 122) = 1;
  *((_WORD *)v19 + 123) = 1;
  v34 = sub_10023060(4 * a6 + 154);
  v19[49] = v34;
  v56 = 4 * a6 + 154;
  if ( !v34 )
  {
    sub_10003210(-8, "count: %lu", v56);
LABEL_49:
    v52 = sub_10003240();
    sub_1000C6F0(0, 4, "%s::%s: Neterror: %s", aNetdrv, v58, v52);
    goto LABEL_50;
  }
  sprintf(Buffer, "Net Driver: ID system initialized (%d entries).", v56);
  sub_1000C620(v19[51], 64, 4, Buffer);
  v35 = sub_10022BB0(2 * a6 + 52, v19[49]);
  v19[50] = v35;
  v57 = 2 * a6 + 52;
  if ( !v35 )
  {
    sub_10003210(-10, "count: %lu", v57);
    v48 = sub_10003240();
    sub_1000C6F0(0, 4, "%s::%s: Neterror: %s", aNetdrv, v58, v48);
LABEL_50:
    sub_10001CC0(v19);
    return 0;
  }
  v19[14] = 0;
  sprintf(Buffer, "Net Driver: Callbackhandler ready (%d calls reserved).", v57);
  sub_1000C620(v19[51], 64, 4, Buffer);
  v36 = (DNameNode *)operator new(0x20u);
  if ( v36 )
    v37 = sub_10023130(v36);
  else
    v37 = 0;
  v19[47] = v37;
  if ( !v37 )
  {
    sub_100031F0(-39);
LABEL_22:
    v53 = sub_10003240();
    sub_1000C6F0(0, 4, "%s::%s: Neterror: %s", aNetdrv, v58, v53);
LABEL_23:
    sub_10001CC0(v19);
    return 0;
  }
  v38 = sub_10006530((int)v19, a6);
  v19[48] = v38;
  if ( !v38 )
  {
    sub_10003210(-11, "listmax: %lu", a6);
    v49 = sub_10003240();
    sub_1000C6F0(0, 4, "%s::%s: Neterror: %s", aNetdrv, v58, v49);
    goto LABEL_50;
  }
  sprintf(Buffer, "Net Driver: User list for >> %lu << user created.", a6);
  sub_1000C620(v19[51], 64, 4, Buffer);
  v39 = sub_100229A0();
  v19[1] = v39;
  if ( !v39 )
  {
    sub_100031F0(-12);
    v54 = sub_10003240();
    sub_1000C6F0(0, 4, "%s::%s: Neterror: %s", aNetdrv, v58, v54);
    goto LABEL_23;
  }
  v40 = sub_1000E120(2);
  v19[2] = v40;
  if ( !v40 )
  {
    sub_100031F0(-13);
    goto LABEL_22;
  }
  sub_1000C620(v19[51], 64, 4, "Net Driver: Server read queue created.");
  v41 = sub_1000CA10(a3, v19[51]);
  v19[54] = v41;
  if ( !v41 )
  {
    sub_10003210(-14, "port: %u", a3);
    v50 = sub_10003240();
    sub_1000C6F0(0, 4, "%s::%s: Neterror: %s", aNetdrv, v58, v50);
    goto LABEL_50;
  }
  sprintf(Buffer, "Net Driver: Network service initialised, using port: >> %d <<.", a3);
  sub_1000C620(v19[51], 64, 4, Buffer);
  v47 = v19[45];
  v19[7] = v19;
  v19[8] = v19 + 3;
  if ( sub_1000E340((int)(v19 + 3), (LPTHREAD_START_ROUTINE)sub_100026E0, v19 + 7, 1, v47) == -1 )
  {
    sub_100031F0(-15);
    goto LABEL_22;
  }
  sub_1000C620(v19[51], 64, 4, "Net Driver: Server thread started.");
  if ( *(_WORD *)v19 == 1 )
  {
    v42 = 0;
    v43 = sub_10003A60((int)v19, 0);
    if ( v43 )
    {
      sub_10022F30(v19[50], (int)sub_100059F0, (int)v43, v19[21], 100, 1, 1);
      v42 = 1;
    }
    v44 = sub_10003A60((int)v19, 0);
    if ( v44 )
    {
      sub_10022F30(v19[50], (int)sub_10004FF0, (int)v44, v19[22], 100, 1, 1);
      ++v42;
    }
    if ( v42 != 2 )
    {
      sub_100031F0(-16);
      v55 = sub_10003240();
      sub_1000C6F0(0, 4, "%s::%s: Neterror: %s", aNetdrv, v58, v55);
      goto LABEL_23;
    }
    sub_1000C620(v19[51], 64, 4, "Net Driver: Callbacks started.");
    sub_1000C620(v19[51], 64, 4, "Net Driver: Driver functions installed.");
  }
  v45 = operator new(0x10u);
  if ( v45 )
    v46 = sub_100034E0(v45, a13);
  else
    v46 = 0;
  v19[59] = v46;
  if ( !v46 )
  {
    sub_10003210(-17, "maxgroup: %u", a13);
    v51 = sub_10003240();
    sub_1000C6F0(0, 4, "%s::%s: Neterror: %s", aNetdrv, v58, v51);
    goto LABEL_50;
  }
  if ( !v46[2] )
  {
    sub_10003210(-17, "maxgroup: %u", a13);
    goto LABEL_49;
  }
  sprintf(Buffer, "Net Driver: Group handler for >> %d << groups initialized.", a13);
  sub_1000C620(v19[51], 64, 4, Buffer);
  sub_1000C620(v19[51], 64, 4, "Net Driver: READY!");
  sub_10004110((int)v19);
  *(_DWORD *)v19[51] |= 0x40u;
  *(_DWORD *)v19[51] &= ~0x20u;
  *(_DWORD *)(v19[51] + 16) = ArgList;
  v19[36] = 1;
  return v19;
}
// 10004FF0: using guessed type int sub_10004FF0();
// 100029E0: using guessed type int arg_14;
// 100029E0: using guessed type _BYTE *ArgList;

//----- (10003170) --------------------------------------------------------
int sub_10003170()
{
  return nullsub_1(byte_1004C280);
}
// 100261F0: using guessed type int nullsub_1(const char *, ...);

//----- (10003180) --------------------------------------------------------
int sub_10003180()
{
  return sub_1000B9B0((int)byte_1004C280);
}

//----- (10003190) --------------------------------------------------------
int sub_10003190()
{
  return sub_1000B9E0((int)byte_1004C280);
}

//----- (100031A0) --------------------------------------------------------
int __cdecl sub_100031A0(int a1)
{
  if ( a1 > -10043 && a1 < -10000 )
    return dword_1004C28C + ((a1 + 10043) << 6);
  if ( a1 <= dword_1004C284 || a1 >= dword_1004C288 )
    return 0;
  return dword_1004C28C + ((43 - dword_1004C284 + a1) << 6);
}
// 1004C284: using guessed type int dword_1004C284;
// 1004C288: using guessed type int dword_1004C288;
// 1004C28C: using guessed type int dword_1004C28C;

//----- (100031F0) --------------------------------------------------------
int __cdecl sub_100031F0(int a1)
{
  return sub_1000B9F0((int)byte_1004C280, a1);
}

//----- (10003210) --------------------------------------------------------
_DWORD *sub_10003210(int a1, char *Format, ...)
{
  va_list va; // [esp+Ch] [ebp+Ch] BYREF

  va_start(va, Format);
  vsprintf(byte_1004C290, Format, va);
  return sub_1000B9D0(byte_1004C280, a1);
}

//----- (10003240) --------------------------------------------------------
char *sub_10003240()
{
  int v0; // eax
  int v1; // eax
  const char *v3; // [esp-8h] [ebp-8h]

  v0 = sub_1000B9E0((int)byte_1004C280);
  v3 = (const char *)sub_100031A0(v0);
  v1 = sub_1000B9E0((int)byte_1004C280);
  sprintf(Buffer, "CODE %d: %s.(%s)", v1, v3, byte_1004C290);
  return Buffer;
}

//----- (10003280) --------------------------------------------------------
int sub_10003280()
{
  sub_1000B9B0((int)byte_1004C280);
  return sub_1000BA10((int)byte_1004C280, -43, 4, (int)aSocketLowwater);
}

//----- (100032B0) --------------------------------------------------------
int __thiscall sub_100032B0(void *this)
{
  (*(void (__thiscall **)(void *))(*(_DWORD *)this + 4))(this);
  return (**(int (__thiscall ***)(void *, int))this)(this, 1);
}

//----- (10003300) --------------------------------------------------------
_DWORD *__thiscall sub_10003300(_DWORD *this, char *Source, __int16 a3, int a4, int a5)
{
  char *v6; // eax

  *this = &off_1003C238;
  sub_10023E40(this + 2);
  this[7] = 0;
  *((_WORD *)this + 18) = 0;
  this[7] = 1;
  if ( !Source )
  {
    this[1] = aCommonTalk;
LABEL_5:
    *((_WORD *)this + 12) = a3;
    *((_WORD *)this + 13) = 0;
    this[8] = a4;
    *((_WORD *)this + 18) = 1;
    return this;
  }
  v6 = (char *)sub_1000BB40(32);
  this[1] = v6;
  if ( v6 )
  {
    strncpy(v6, Source, 0x20u);
    *(_BYTE *)(this[1] + 31) = 0;
    this[7] |= 0x200u;
    goto LABEL_5;
  }
  return this;
}
// 1003C238: using guessed type int (*off_1003C238)();

//----- (10003390) --------------------------------------------------------
_DWORD *__thiscall sub_10003390(int this, int a2)
{
  _DWORD *v3; // eax
  _DWORD *v4; // esi

  v3 = operator new(0x10u);
  v4 = v3;
  if ( !v3 )
    return 0;
  sub_10023E00(v3);
  *v4 = off_1003C230;
  v4[3] = a2;
  sub_10023E50((_DWORD *)(this + 8), (int)v4);
  ++*(_WORD *)(this + 26);
  return v4;
}
// 1003C230: using guessed type int (__stdcall *off_1003C230[2])(int);

//----- (100033E0) --------------------------------------------------------
__int16 __thiscall sub_100033E0(int *this, int a2)
{
  _DWORD *v3; // esi
  int v4; // eax

  v3 = this + 2;
  v4 = sub_10023E90(this + 2);
  if ( !v4 )
    return -1;
  while ( *(_DWORD *)(v4 + 12) != a2 )
  {
    v4 = sub_10023EA0(v3);
    if ( !v4 )
      return -1;
  }
  (*(void (__thiscall **)(int *, int))(*this + 8))(this, v4);
  return 0;
}

//----- (10003430) --------------------------------------------------------
int __thiscall sub_10003430(void *this, int a2, int a3, _BYTE *a4, signed int a5)
{
  int result; // eax

  for ( result = (*(int (__thiscall **)(void *))(*(_DWORD *)this + 20))(this);
        result;
        result = (*(int (__thiscall **)(void *))(*(_DWORD *)this + 24))(this) )
  {
    sub_10003C10(a2, a3, *(_DWORD *)(result + 12), 0, 14, a4, a5);
  }
  return result;
}

//----- (10003480) --------------------------------------------------------
int __thiscall sub_10003480(int *this)
{
  return sub_10023E90(this + 2);
}

//----- (10003490) --------------------------------------------------------
int __thiscall sub_10003490(_DWORD *this)
{
  return sub_10023EA0(this + 2);
}

//----- (100034A0) --------------------------------------------------------
int __thiscall sub_100034A0(int this, int a2)
{
  int result; // eax

  result = a2;
  *(_DWORD *)a2 = *(_DWORD *)(this + 32);
  *(_WORD *)(a2 + 4) = *(_WORD *)(this + 26);
  *(_WORD *)(a2 + 6) = *(_WORD *)(this + 24);
  *(_DWORD *)(a2 + 8) = *(_DWORD *)(this + 28);
  strcpy((char *)(a2 + 12), *(const char **)(this + 4));
  return result;
}

//----- (100034E0) --------------------------------------------------------
_WORD *__thiscall sub_100034E0(_WORD *this, __int16 a2)
{
  _DWORD *v3; // esi
  _DWORD *v4; // eax
  void (__thiscall ***v5)(_DWORD, int); // ecx

  *(_DWORD *)this = &off_1003C258;
  this[2] = 0;
  v3 = operator new(0x18u);
  if ( v3 )
  {
    *v3 = &off_1003C220;
    v3[5] = 0;
    v3[4] = 0;
    sub_10023B50(v3, a2, 1);
  }
  else
  {
    v3 = 0;
  }
  *((_DWORD *)this + 2) = v3;
  if ( v3 )
  {
    v4 = sub_10023060(a2);
    *((_DWORD *)this + 3) = v4;
    if ( v4 )
    {
      this[2] = 1;
    }
    else
    {
      v5 = (void (__thiscall ***)(_DWORD, int))*((_DWORD *)this + 2);
      if ( v5 )
      {
        (**v5)(v5, 1);
        return this;
      }
    }
  }
  return this;
}
// 1003C220: using guessed type void *off_1003C220;
// 1003C258: using guessed type int (__stdcall *off_1003C258)(char *Source, __int16, int);

//----- (10003570) --------------------------------------------------------
__int16 __thiscall sub_10003570(void *this)
{
  void **v2; // eax
  int (__thiscall ***v3)(_DWORD, int); // ecx

  v2 = (void **)*((_DWORD *)this + 3);
  *(_DWORD *)this = &off_1003C258;
  *((_WORD *)this + 2) = 0;
  if ( v2 )
    LOWORD(v2) = sub_100230C0(v2);
  v3 = (int (__thiscall ***)(_DWORD, int))*((_DWORD *)this + 2);
  if ( v3 )
    LOWORD(v2) = (**v3)(v3, 1);
  return (__int16)v2;
}
// 1003C258: using guessed type int (__stdcall *off_1003C258)(char *Source, __int16, int);

//----- (100035A0) --------------------------------------------------------
void *__thiscall sub_100035A0(void *Block, char a2)
{
  int v3; // eax

  v3 = *((_DWORD *)Block + 7);
  *(_DWORD *)Block = &off_1003C238;
  *((_WORD *)Block + 18) = 0;
  if ( (v3 & 0x200) != 0 && *((_DWORD *)Block + 1) )
    sub_1000BBF0(*((void **)Block + 1));
  sub_10023EC0((_DWORD *)Block + 2);
  if ( (a2 & 1) != 0 )
    j__free(Block);
  return Block;
}
// 1003C238: using guessed type int (*off_1003C238)();

//----- (100035F0) --------------------------------------------------------
int __thiscall sub_100035F0(_DWORD *this, int a2)
{
  int v2; // ecx
  int result; // eax
  int v4; // esi
  int v5; // edx
  _DWORD *v6; // edi
  _DWORD *i; // ecx

  v2 = this[2];
  result = -1;
  if ( (*(_BYTE *)(v2 + 20) & 2) == 0 )
    return -1;
  v4 = *(_DWORD *)(v2 + 4);
  v5 = 0;
  if ( v4 > 0 )
  {
    v6 = *(_DWORD **)(v2 + 16);
    for ( i = v6; *i; ++i )
    {
      if ( ++v5 >= v4 )
        return result;
    }
    result = v5;
    if ( v5 != -1 )
      v6[v5] = a2;
  }
  return result;
}

//----- (10003600) --------------------------------------------------------
__int16 __thiscall sub_10003600(_DWORD **this, int a2, __int16 a3)
{
  int v4; // eax
  void *v5; // edi
  __int16 v7; // si

  v4 = ((int (__thiscall *)(_DWORD **, int))(*this)[5])(this, a2);
  v5 = (void *)v4;
  if ( !v4 )
    return -1;
  v7 = sub_10023C30(this[2], v4);
  if ( a3 )
    sub_100035A0(v5, 1);
  return v7;
}

//----- (10003650) --------------------------------------------------------
__int16 __thiscall sub_10003650(_DWORD **this, void *Block, __int16 a3)
{
  __int16 v3; // di
  int v4; // eax

  v3 = sub_10023C30(this[2], (int)Block);
  if ( a3 && Block )
  {
    v4 = *((_DWORD *)Block + 7);
    *(_DWORD *)Block = &off_1003C238;
    *((_WORD *)Block + 18) = 0;
    if ( (v4 & 0x200) != 0 && *((_DWORD *)Block + 1) )
      sub_1000BBF0(*((void **)Block + 1));
    sub_10023EC0((_DWORD *)Block + 2);
    j__free(Block);
  }
  return v3;
}
// 1003C238: using guessed type int (*off_1003C238)();

//----- (100036B0) --------------------------------------------------------
int (__thiscall ***__thiscall sub_100036B0(_DWORD *this, int a2))(_DWORD)
{
  int (__thiscall ***v3)(_DWORD); // esi

  *(_DWORD *)(this[2] + 12) = *(_DWORD *)(this[2] + 8);
  v3 = (int (__thiscall ***)(_DWORD))(*(int (__thiscall **)(_DWORD *))(*this + 32))(this);
  if ( v3 )
  {
    while ( (**v3)(v3) != a2 )
    {
      v3 = (int (__thiscall ***)(_DWORD))(*(int (__thiscall **)(_DWORD *))(*this + 36))(this);
      if ( !v3 )
        goto LABEL_4;
    }
    *(_DWORD *)(this[2] + 8) = *(_DWORD *)(this[2] + 12);
    return v3;
  }
  else
  {
LABEL_4:
    *(_DWORD *)(this[2] + 8) = *(_DWORD *)(this[2] + 12);
    return 0;
  }
}

//----- (10003710) --------------------------------------------------------
int __thiscall sub_10003710(_DWORD *this, int a2)
{
  int v2; // ecx
  int result; // eax
  int v4; // edx
  _DWORD *i; // ecx

  v2 = this[2];
  if ( (*(_BYTE *)(v2 + 20) & 2) == 0 )
    return -1;
  v4 = *(_DWORD *)(v2 + 4);
  result = 0;
  if ( v4 <= 0 )
    return -1;
  for ( i = *(_DWORD **)(v2 + 16); *i != a2; ++i )
  {
    if ( ++result >= v4 )
      return -1;
  }
  return result;
}

//----- (10003720) --------------------------------------------------------
int __thiscall sub_10003720(void *this, int a2, int a3)
{
  int v3; // eax

  v3 = (*(int (__thiscall **)(void *, int))(*(_DWORD *)this + 20))(this, a2);
  if ( v3 )
    return (*(int (__thiscall **)(int, int))(*(_DWORD *)v3 + 4))(v3, a3);
  else
    return 0;
}

//----- (10003750) --------------------------------------------------------
__int16 __thiscall sub_10003750(void *this, int a2, int a3)
{
  int v3; // eax

  v3 = (*(int (__thiscall **)(void *, int))(*(_DWORD *)this + 20))(this, a2);
  if ( v3 )
    return (*(int (__thiscall **)(int, int))(*(_DWORD *)v3 + 12))(v3, a3);
  else
    return -1;
}

//----- (10003780) --------------------------------------------------------
int __thiscall sub_10003780(_DWORD *this)
{
  _DWORD *v1; // ecx
  int v2; // esi
  int result; // eax
  int v4; // edi
  int v5; // edx

  v1 = (_DWORD *)this[2];
  v1[2] = 0;
  v2 = v1[1];
  if ( v2 < 1 || v1[2] >= v2 )
    return 0;
  v4 = (v1[5] >> 1) & 1;
  while ( 1 )
  {
    v5 = v1[2];
    if ( v4 )
    {
      if ( v5 >= 0 && v5 < v2 )
      {
        result = *(_DWORD *)(v1[4] + 4 * v5);
        if ( result )
          break;
      }
    }
    v1[2] = v5 + 1;
    if ( v5 + 1 >= v2 )
      return 0;
  }
  ++v1[2];
  return result;
}

//----- (10003790) --------------------------------------------------------
int __thiscall sub_10003790(_DWORD *this)
{
  int v1; // ecx
  int v2; // esi

  v1 = this[2];
  v2 = *(_DWORD *)(v1 + 4);
  if ( v2 >= 1 && *(_DWORD *)(v1 + 8) < v2 )
    JUMPOUT(0x10023D30);
  return 0;
}
// 10023D2B: control flows out of bounds to 10023D30

//----- (100037A0) --------------------------------------------------------
int __thiscall sub_100037A0(void *this, int a2, int a3, int a4, int a5, int a6)
{
  int result; // eax

  result = (*(int (__thiscall **)(void *, int))(*(_DWORD *)this + 20))(this, a4);
  if ( result )
    return (*(int (__thiscall **)(int, int, int, int, int))(*(_DWORD *)result + 16))(result, a2, a3, a5, a6);
  return result;
}

//----- (100037D0) --------------------------------------------------------
_DWORD *__thiscall sub_100037D0(int **this, char *Source, __int16 a3, int a4)
{
  _DWORD *result; // eax
  int v6; // edi
  _DWORD *v7; // eax
  _DWORD *v8; // esi

  result = (_DWORD *)sub_100230E0(this[3]);
  v6 = (int)result;
  if ( result )
  {
    v7 = operator new(0x28u);
    if ( v7 && (v8 = sub_10003300(v7, Source, a3, v6, a4)) != 0 )
    {
      if ( ((int (__thiscall *)(int **, _DWORD *))(*this)[1])(this, v8) == -1 )
      {
        sub_10023110(this[3], v6);
        sub_100035A0(v8, 1);
        return 0;
      }
      else
      {
        return v8;
      }
    }
    else
    {
      sub_10023110(this[3], v6);
      return 0;
    }
  }
  return result;
}

//----- (10003860) --------------------------------------------------------
void __thiscall sub_10003860(_DWORD *this, _DWORD *Block)
{
  sub_10023ED0(this + 2, (int)Block);
  if ( Block )
  {
    sub_10023E20(Block);
    j__free(Block);
  }
}

//----- (10003890) --------------------------------------------------------
void *__cdecl sub_10003890(const char *a1, const char *a2)
{
  void *v2; // esi
  char *v3; // eax
  char *v5; // eax

  v2 = sub_1000BB40(16);
  if ( v2 )
  {
    *((_DWORD *)v2 + 1) = 0;
    v3 = (char *)sub_1000BB40(strlen(a1) + 1);
    *((_DWORD *)v2 + 2) = v3;
    if ( !v3 )
    {
      sub_1000BBF0(v2);
      return 0;
    }
    strcpy(v3, a1);
    v5 = (char *)sub_1000BB40(strlen(a2) + 1);
    *((_DWORD *)v2 + 3) = v5;
    if ( !v5 )
    {
      sub_1000BBF0(*((void **)v2 + 2));
      sub_1000BBF0(v2);
      return 0;
    }
    strcpy(v5, a2);
  }
  return v2;
}

//----- (10003940) --------------------------------------------------------
__int16 __cdecl sub_10003940(void **Block)
{
  __int16 result; // ax

  if ( Block )
  {
    if ( Block[2] )
      sub_1000BBF0(Block[2]);
    if ( Block[3] )
      sub_1000BBF0(Block[3]);
    return sub_1000BBF0(Block);
  }
  return result;
}

//----- (10003980) --------------------------------------------------------
int __cdecl sub_10003980(int a1, int a2)
{
  int result; // eax
  void **v3; // esi

  result = (*(int (__thiscall **)(_DWORD, int))(**(_DWORD **)(a1 + 188) + 84))(*(_DWORD *)(a1 + 188), a2);
  v3 = (void **)result;
  if ( result )
  {
    sub_1000CD60(*(SOCKET **)(result + 4));
    (*(void (__thiscall **)(_DWORD, void *))(**(_DWORD **)(a1 + 188) + 40))(*(_DWORD *)(a1 + 188), *v3);
    if ( v3[2] )
      sub_1000BBF0(v3[2]);
    if ( v3[3] )
      sub_1000BBF0(v3[3]);
    sub_1000BBF0(v3);
    return 1;
  }
  return result;
}

//----- (100039F0) --------------------------------------------------------
__int16 __cdecl sub_100039F0(int a1, _BYTE *a2)
{
  _DWORD *v2; // eax

  if ( (*a2 & 0x40) != 0 )
    return 0;
  v2 = sub_1000CAA0(0, 0);
  if ( v2 )
  {
    v2[6] = 8;
    v2[8] = 0;
    v2[7] = 0;
    v2[10] = a2;
    sub_10022A90(*(_DWORD **)(a1 + 4), (int)v2, 0);
    *(_DWORD *)a2 |= 0x40u;
    return 0;
  }
  sub_1000C620(*(_DWORD *)(a1 + 204), 16, 1, "KRNL_SendUsrRemoveMessage: Cannot allocate envelope.");
  return -1;
}

//----- (10003A60) --------------------------------------------------------
_DWORD *__cdecl sub_10003A60(int a1, int a2)
{
  _DWORD *result; // eax

  result = sub_1000BB40(16);
  if ( result )
  {
    *result = a1;
    result[1] = *(_DWORD *)(a1 + 192);
    result[2] = a2;
  }
  return result;
}

//----- (10003A90) --------------------------------------------------------
__int16 __cdecl sub_10003A90(int a1, int a2, int a3, int a4, __int16 a5, void *Block, int a7)
{
  _DWORD *v7; // eax

  v7 = sub_1000CAA0((int)Block, a7);
  if ( v7 )
  {
    v7[6] = a5;
    v7[8] = a7;
    v7[4] = a2;
    v7[5] = a3;
    sub_10022A90(*(_DWORD **)(*(_DWORD *)(a4 + 12) + 84), (int)v7, a7);
    sub_1000E2D0(*(HANDLE **)(*(_DWORD *)(a4 + 12) + 92));
    return 0;
  }
  else
  {
    sub_1000C620(*(_DWORD *)(a1 + 204), 16, 1, "Server game tick: SendSingleMessage: No Memory for envelope.");
    sub_1000BBF0(Block);
    return -1;
  }
}

//----- (10003B20) --------------------------------------------------------
__int16 __cdecl sub_10003B20(int a1, int a2, int a3, int a4, _BYTE *a5, signed int Size)
{
  __int16 v6; // bp
  int v7; // edx
  int v8; // esi
  _DWORD *v9; // eax
  _BYTE *v10; // edi
  __int16 v12; // [esp+8h] [ebp-4h]

  v12 = 0;
  sub_1000E090(**(_DWORD **)(a1 + 192), 0xFFFFFFFF);
  v6 = *(_WORD *)(*(_DWORD *)(*(_DWORD *)(a1 + 192) + 4) + 12);
  if ( v6 != -1 )
  {
    while ( 1 )
    {
      v7 = *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(a1 + 192) + 4) + 8);
      v8 = *(_DWORD *)(v7 + 12 * v6 + 8);
      v6 = *(_WORD *)(v7 + 12 * v6 + 4);
      v9 = *(_DWORD **)(v8 + 24);
      if ( v9 )
      {
        if ( *v9 != a2 )
        {
          v10 = sub_1000BB40(Size);
          if ( !v10 )
            goto LABEL_9;
          sub_1000BC60(a5, v10, Size);
          if ( sub_10003A90(a1, a2, **(_DWORD **)(v8 + 24), v8, 2, v10, Size) == -1 )
            break;
        }
      }
      if ( v6 == -1 )
        goto LABEL_10;
    }
    sub_1000BBF0(v10);
LABEL_9:
    v12 = -1;
  }
LABEL_10:
  sub_1000E0E0(**(_DWORD **)(a1 + 192));
  return v12;
}

//----- (10003C10) --------------------------------------------------------
__int16 __cdecl sub_10003C10(int a1, int a2, int a3, int a4, int a5, _BYTE *a6, signed int Size)
{
  int v8; // edi
  _BYTE *v9; // eax
  void *v10; // esi

  if ( a3 == -268435491 && *(_WORD *)a1 == 1 )
  {
    if ( sub_10003B20(a1, a2, -268435491, a5, a6, Size) == -1 )
    {
      sub_1000C620(*(_DWORD *)(a1 + 204), 16, 1, "Server game tick: SendSingleMessage: Send to USR_ALL failed.");
      return -1;
    }
    return 0;
  }
  if ( a2 == -268435508 )
  {
    v8 = sub_10005EF0(a1, a3);
    if ( !v8 )
      return -1;
  }
  else
  {
    v8 = sub_10005EF0(a1, a2);
    if ( !v8 )
      return -1;
  }
  v9 = sub_1000BB40(Size);
  v10 = v9;
  if ( !v9 )
    return -1;
  sub_1000BC60(a6, v9, Size);
  if ( sub_10003A90(a1, a2, a3, v8, a5, v10, Size) == -1 )
  {
    sub_1000BBF0(v10);
    return -1;
  }
  return 0;
}

//----- (10003D10) --------------------------------------------------------
__int16 __cdecl sub_10003D10(int a1, char *Source, int a3, int a4)
{
  int v4; // eax
  signed int v6; // edi
  char *v7; // esi
  unsigned int v8; // eax
  char *v9; // edi
  int v11; // [esp+0h] [ebp-284h] BYREF
  char Destination[127]; // [esp+4h] [ebp-280h] BYREF
  char v13; // [esp+83h] [ebp-201h] BYREF
  char v14[512]; // [esp+84h] [ebp-200h] BYREF

  _errno();
  strncpy(Destination, Source, 0x80u);
  v13 = 0;
  v4 = sub_1000E810(Destination);
  v11 = v4;
  if ( v4 < 0 )
    return -1;
  v6 = v4 + 136;
  v7 = (char *)sub_1000BB40(v4 + 136);
  if ( !v7 )
    return -1;
  strcpy(v7, Destination);
  *((_DWORD *)v7 + 32) = 136;
  *((_DWORD *)v7 + 33) = v11;
  if ( !sub_10023F30(Destination, v7 + 136, (unsigned int *)&v11) )
    return -1;
  if ( sub_10003C10(a1, a3, a4, 0, 12, v7, v6) == -1 )
  {
    sub_1000BBF0(v7);
    return -1;
  }
  else
  {
    sub_1000BBF0(v7);
    strcpy(v14, "FILE SENT: ");
    v8 = strlen(Destination) + 1;
    v9 = &v13;
    while ( *++v9 )
      ;
    qmemcpy(v9, Destination, v8);
    sub_1000C620(*(_DWORD *)(a1 + 204), 4, 4, v14);
    return 0;
  }
}

//----- (10003EA0) --------------------------------------------------------
__int16 __cdecl sub_10003EA0(int a1, int a2)
{
  int v2; // esi
  unsigned int v3; // eax
  unsigned int v4; // eax
  char *v5; // edi
  char v8; // [esp+3h] [ebp-201h] BYREF
  char v9[512]; // [esp+4h] [ebp-200h] BYREF

  v2 = *(_DWORD *)(a2 + 4);
  v3 = sub_10024020((char *)v2, (void *)(v2 + *(_DWORD *)(v2 + 128)), *(_DWORD *)(v2 + 132));
  if ( v3 != -1 )
  {
    strcpy(v9, "FILE RECEIVED: ");
    v4 = strlen((const char *)v2) + 1;
    v5 = &v8;
    while ( *++v5 )
      ;
    qmemcpy(v5, (const void *)v2, v4);
    sub_1000C620(*(_DWORD *)(a1 + 204), 4, 16, v9);
    LOWORD(v3) = 0;
  }
  return v3;
}

//----- (10003F60) --------------------------------------------------------
__int16 __cdecl sub_10003F60(int a1, int a2, int Block, char *a4, int a5)
{
  int v5; // esi
  _BYTE *v6; // eax

  v5 = a5;
  v6 = (_BYTE *)sub_1000BCE0(&Block, 4, a4, a5, 0);
  if ( v6 )
    return (sub_10003C10(a1, a2, -268435508, 0, 14, v6, v5 + 4) != -1) - 1;
  else
    return -1;
}

//----- (10003FC0) --------------------------------------------------------
__int16 __cdecl sub_10003FC0(int a1, int a2)
{
  (*(void (__thiscall **)(_DWORD, int, int, _DWORD, int, int))(**(_DWORD **)(a1 + 236) + 40))(
    *(_DWORD *)(a1 + 236),
    a1,
    -268435508,
    **(_DWORD **)(a2 + 4),
    *(_DWORD *)(a2 + 4) + 4,
    *(_DWORD *)(a2 + 8) - 4);
  return 0;
}

//----- (10004000) --------------------------------------------------------
int __cdecl sub_10004000(int *a1)
{
  int v1; // esi
  _BYTE *v2; // edi

  v1 = *a1;
  v2 = (_BYTE *)a1[2];
  if ( sub_10005BE0(*a1, (int)v2) )
  {
    if ( (*v2 & 1) != 0 )
    {
      sub_1000C620(*(_DWORD *)(v1 + 204), 4, 4, "Logon check: connection is ok.");
    }
    else
    {
      sub_1000C620(*(_DWORD *)(v1 + 204), 4, 4, "Logon check: Remove connection !");
      sub_100039F0(v1, v2);
    }
    return 0;
  }
  else
  {
    sub_1000C620(*(_DWORD *)(v1 + 204), 4, 4, "Logon check: Connection already removed.");
    return 0;
  }
}

//----- (10004080) --------------------------------------------------------
int __cdecl sub_10004080(int *a1)
{
  int v1; // ebx
  int v2; // edi
  void *v3; // eax
  void *v4; // esi

  v1 = a1[2];
  v2 = *a1;
  v3 = sub_1000BB40(2);
  v4 = v3;
  if ( v3 )
  {
    if ( sub_10003A90(v2, **(_DWORD **)(v1 + 24), -268435508, v1, 11, v3, 2) )
    {
      sub_1000BBF0(v4);
      sub_1000C620(*(_DWORD *)(v2 + 204), 16, 1, "SendAliveMessage: Cannot send message.");
      return 1;
    }
    else
    {
      return 0;
    }
  }
  else
  {
    sub_1000C620(*(_DWORD *)(v2 + 204), 16, 1, "SendAliveMessage: Cannot alloc message.");
    return 1;
  }
}

//----- (10004110) --------------------------------------------------------
__int16 __cdecl sub_10004110(int a1)
{
  __int16 result; // ax
  unsigned int v2; // eax
  char *v3; // edi
  char *v5; // edi
  int v7; // eax
  unsigned int v8; // eax
  char *v9; // edi
  int v11; // edx
  int v12[2]; // [esp+4h] [ebp-68h] BYREF
  char Buffer[31]; // [esp+Ch] [ebp-60h] BYREF
  char v14; // [esp+2Bh] [ebp-41h] BYREF
  char v15[64]; // [esp+2Ch] [ebp-40h] BYREF

  result = (unsigned __int16)sub_10022170(v12);
  if ( *(_WORD *)a1 == 1 )
  {
    strcpy(v15, "- ALIVE   ");
    sub_10022500(v12);
    sub_100228F0(v12, Buffer);
    v2 = strlen(Buffer) + 1;
    v3 = &v14;
    while ( *++v3 )
      ;
    qmemcpy(v3, Buffer, v2);
    v5 = &v14;
    while ( *++v5 )
      ;
    v7 = *(_DWORD *)(a1 + 192);
    *(_WORD *)v5 = 32;
    sprintf(Buffer, "USER ONLINE: %d", **(_DWORD **)(v7 + 4));
    v8 = strlen(Buffer) + 1;
    v9 = &v14;
    while ( *++v9 )
      ;
    v11 = *(_DWORD *)(a1 + 208);
    qmemcpy(v9, Buffer, v8);
    return sub_1000C620(v11, 4, 4, v15);
  }
  return result;
}

//----- (10004220) --------------------------------------------------------
__int16 __cdecl sub_10004220(int a1, _DWORD *a2)
{
  __int16 result; // ax
  int *v3; // eax
  int v4; // eax
  int v5; // ecx
  char *v6; // eax
  int v7; // [esp-14h] [ebp-2D4h]
  int v8; // [esp-10h] [ebp-2D0h]
  int v9; // [esp-Ch] [ebp-2CCh]
  int v10; // [esp-8h] [ebp-2C8h]
  const char *v11; // [esp-4h] [ebp-2C4h]
  int v12[2]; // [esp+8h] [ebp-2B8h] BYREF
  int v13; // [esp+10h] [ebp-2B0h] BYREF
  char v14[32]; // [esp+18h] [ebp-2A8h] BYREF
  char v15[32]; // [esp+38h] [ebp-288h] BYREF
  char v16[48]; // [esp+58h] [ebp-268h] BYREF
  __int16 v17; // [esp+88h] [ebp-238h]
  char v18[48]; // [esp+8Ch] [ebp-234h] BYREF
  __int16 v19; // [esp+BCh] [ebp-204h]
  char Buffer[512]; // [esp+C0h] [ebp-200h] BYREF

  sub_10022170(v12);
  memset(Buffer, 0, sizeof(Buffer));
  memset(v18, 0, sizeof(v18));
  v19 = 0;
  result = 0;
  memset(v16, 0, sizeof(v16));
  v17 = 0;
  if ( a1 && a2 && *(_WORD *)a1 == 1 )
  {
    sub_1000DDF0(v18);
    sub_1000DDC0(v16);
    sub_10022500(v12);
    v3 = sub_10022710(v12, &v13, (_DWORD *)(a2[2] + 16));
    v12[0] = *v3;
    v12[1] = v3[1];
    sub_100227F0(v12, v15);
    sub_100227F0((_DWORD *)(a2[2] + 16), v14);
    v4 = a2[3];
    v5 = a2[2];
    v11 = (const char *)a2[8];
    v10 = *(_DWORD *)(v4 + 24);
    v9 = *(_DWORD *)(v4 + 28);
    v8 = *(_DWORD *)(v5 + 24);
    v7 = *(_DWORD *)(v5 + 28);
    v6 = inet_ntoa(*(struct in_addr *)(a2[4] + 528));
    sprintf(Buffer, "%s,%s,%s,%s,%s,%lu,%lu,%lu,%lu,%s,", v18, v16, v6, v14, v15, v7, v8, v9, v10, v11);
    return sub_1000C620(*(_DWORD *)(a1 + 212), 128, 1, Buffer);
  }
  return result;
}

//----- (10004360) --------------------------------------------------------
__int16 __cdecl sub_10004360(int a1, int a2)
{
  int *v2; // eax

  v2 = *(int **)(a2 + 24);
  if ( v2 )
    LOWORD(v2) = sub_10008160(*(int **)(a1 + 232), *v2);
  return (__int16)v2;
}

//----- (10004380) --------------------------------------------------------
int *__cdecl sub_10004380(int a1, char *Source, char *a3, u_short hostshort, char a5, char a6, char a7, char a8)
{
  _DWORD *v8; // edi
  _DWORD *v9; // ebx
  char *v10; // eax
  int v12; // eax
  int v13; // ecx
  SOCKET *v14; // ebp
  char *v15; // eax
  int *v16; // esi
  char *v17; // eax
  char *v18; // eax
  char *v19; // eax
  char *v20; // [esp-38h] [ebp-58h]
  char v21[24]; // [esp+8h] [ebp-18h] BYREF

  v8 = (_DWORD *)a1;
  strcpy(v21, "KRNL_SendLogonRequest");
  sub_1000C620(*(_DWORD *)(a1 + 204), 4, 4, "SendLogonRequest: Connecting to site...");
  v9 = sub_1000BB40(52);
  if ( v9 )
  {
    v12 = v8[51];
    v13 = v8[17];
    a1 = -20;
    v14 = sub_1000D9E0(hostshort, a5, a6, a7, a8, v13, v12, &a1);
    if ( v14 && (v8[46] != 1 || sub_1000D130(*v14, v8[51], 1)) )
    {
      v16 = sub_10005FA0((int)v8, (int)v14, v8[23]);
      if ( v16 )
      {
        sub_1000C620(v8[51], 4, 4, "SendLogonRequest: Connection established.");
        sub_1000C8D0(*(_DWORD *)(v16[2] + 40), 16, 1);
        sub_1000C8D0(*(_DWORD *)(v16[3] + 40), 16, 1);
        v18 = Source;
        *v16 |= 0x10u;
        v20 = a3;
        *v9 = -625280017;
        sub_10005E10((int)(v9 + 1), v18, v20, -268435474);
        if ( sub_10003A90((int)v8, -268435474, -268435508, (int)v16, 3, v9, 52) )
        {
          sub_1000CD60(v14);
          sub_1000C8D0(*(_DWORD *)(v16[2] + 40), 32, 1);
          sub_1000C8D0(*(_DWORD *)(v16[3] + 40), 32, 1);
          sub_10006200((int)v8, (int)v16);
          sub_1000BBF0(v9);
          sub_100031F0(-22);
          v19 = sub_10003240();
          sub_1000C6F0(0, 4, "%s::%s: Neterror: %s", aNetkrnl, v21, v19);
          return 0;
        }
        else
        {
          sub_1000C620(v8[51], 4, 4, "SendLogonRequest: Sended LOGMEON to server.");
          return v16;
        }
      }
      else
      {
        sub_1000CD60(v14);
        sub_1000BBF0(v9);
        sub_100031F0(-21);
        v17 = sub_10003240();
        sub_1000C6F0(0, 4, "%s::%s: Neterror: %s", aNetkrnl, v21, v17);
        return 0;
      }
    }
    else
    {
      sub_100031F0(a1);
      v15 = sub_10003240();
      sub_1000C6F0(0, 4, "%s::%s: Neterror: %s", aNetkrnl, v21, v15);
      sub_1000BBF0(v9);
      return 0;
    }
  }
  else
  {
    sub_100031F0(-19);
    v10 = sub_10003240();
    sub_1000C6F0(0, 4, "%s::%s: Neterror: %s", aNetkrnl, v21, v10);
    return 0;
  }
}

//----- (10004650) --------------------------------------------------------
void *__cdecl sub_10004650(
        int a1,
        const char *a2,
        const char *a3,
        u_short hostshort,
        char a5,
        char a6,
        char a7,
        char a8)
{
  void *v8; // esi
  SOCKET *v9; // eax
  char *v10; // eax
  char *v12; // eax
  int v13; // [esp-8h] [ebp-30h]
  int v14; // [esp+8h] [ebp-20h] BYREF
  char v15[28]; // [esp+Ch] [ebp-1Ch] BYREF

  strcpy(v15, "KRNL_SendAsyncLogonRequest");
  v8 = sub_10003890(a2, a3);
  if ( !v8 )
    return 0;
  v13 = *(_DWORD *)(a1 + 204);
  v14 = -20;
  v9 = sub_1000D1C0(hostshort, a5, a6, a7, a8, v13, &v14);
  *((_DWORD *)v8 + 1) = v9;
  if ( v9 )
  {
    if ( *(_DWORD *)(a1 + 184) != 1 || sub_1000D130(*v9, *(_DWORD *)(a1 + 204), 1) )
    {
      *(_DWORD *)v8 = (***(int (__thiscall ****)(_DWORD, void *))(a1 + 188))(*(_DWORD *)(a1 + 188), v8);
      return v8;
    }
    sub_100031F0(v14);
    v12 = sub_10003240();
    sub_1000C6F0(0, 4, "%s::%s: Neterror: %s", aNetkrnl, v15, v12);
    sub_10003940((void **)v8);
    return 0;
  }
  sub_100031F0(v14);
  v10 = sub_10003240();
  sub_1000C6F0(0, 4, "%s::%s: Neterror: %s", aNetkrnl, v15, v10);
  if ( *((_DWORD *)v8 + 2) )
    sub_1000BBF0(*((void **)v8 + 2));
  if ( *((_DWORD *)v8 + 3) )
    sub_1000BBF0(*((void **)v8 + 3));
  sub_1000BBF0(v8);
  return 0;
}

//----- (10004790) --------------------------------------------------------
int __cdecl sub_10004790(int a1)
{
  int *i; // esi
  __int16 v3; // ax
  char *v4; // eax
  SOCKET *v5; // ebp
  _DWORD *v6; // ebx
  int *v7; // esi
  char *v8; // eax
  char *v10; // [esp-14h] [ebp-54h]
  char *v11; // [esp-14h] [ebp-54h]
  int v12; // [esp+8h] [ebp-38h]
  _DWORD *v13[6]; // [esp+Ch] [ebp-34h] BYREF
  char v14[28]; // [esp+24h] [ebp-1Ch] BYREF
  int v15; // [esp+44h] [ebp+4h]

  strcpy(v14, "KRNL_ProcessPendingConnects");
  v12 = 0;
  sub_10024350(v13, *(_DWORD **)(a1 + 188));
  for ( i = (int *)sub_10024240(v13); i; i = (int *)sub_10024270(v13) )
  {
    ++v12;
    v3 = sub_1000DBC0((char *)i[1], 0, *(_DWORD *)(a1 + 204));
    if ( v3 >= 0 )
    {
      if ( !v3 )
      {
        v5 = (SOCKET *)i[1];
        v6 = sub_1000BB40(52);
        if ( v6 )
        {
          sub_10005E10((int)(v6 + 1), (char *)i[2], (char *)i[3], -268435474);
          v15 = *i;
          (*(void (__thiscall **)(_DWORD, int))(**(_DWORD **)(a1 + 188) + 40))(*(_DWORD *)(a1 + 188), *i);
          if ( i[2] )
            sub_1000BBF0((void *)i[2]);
          if ( i[3] )
            sub_1000BBF0((void *)i[3]);
          sub_1000BBF0(i);
          v7 = sub_10005FA0(a1, (int)v5, *(_DWORD *)(a1 + 92));
          if ( v7 )
          {
            sub_1000C620(*(_DWORD *)(a1 + 204), 4, 4, "SendLogonRequest: Connection established.");
            sub_1000C8D0(*(_DWORD *)(v7[2] + 40), 16, 1);
            sub_1000C8D0(*(_DWORD *)(v7[3] + 40), 16, 1);
            *v7 |= 0x10u;
            *v6 = -625280017;
            if ( sub_10003A90(a1, -268435474, -268435508, (int)v7, 3, v6, 52) )
            {
              sub_1000CD60(v5);
              sub_1000C8D0(*(_DWORD *)(v7[2] + 40), 32, 1);
              sub_1000C8D0(*(_DWORD *)(v7[3] + 40), 32, 1);
              sub_10006200(a1, (int)v7);
              sub_1000BBF0(v6);
              sub_100031F0(-22);
              v8 = sub_10003240();
              sub_1000C6F0(0, 4, "%s::%s: Neterror: %s", aNetkrnl, v14, v8);
            }
            else
            {
              sub_1000C620(*(_DWORD *)(a1 + 204), 4, 4, "SendLogonRequest: Sended LOGMEON to server.");
              sub_100080C0(*(_DWORD *)(a1 + 232), v15);
            }
          }
          else
          {
            sub_1000CD60(v5);
            sub_100031F0(-21);
            v11 = sub_10003240();
            sub_1000C6F0(0, 4, "%s::%s: Neterror: %s", aNetkrnl, v14, v11);
          }
        }
        else
        {
          sub_1000CD60(v5);
          (*(void (__thiscall **)(_DWORD, int))(**(_DWORD **)(a1 + 188) + 40))(*(_DWORD *)(a1 + 188), *i);
          if ( i[2] )
            sub_1000BBF0((void *)i[2]);
          if ( i[3] )
            sub_1000BBF0((void *)i[3]);
          sub_1000BBF0(i);
          sub_100031F0(-19);
          v10 = sub_10003240();
          sub_1000C6F0(0, 4, "%s::%s: Neterror: %s", aNetkrnl, v14, v10);
        }
      }
    }
    else
    {
      i[1] = 0;
      if ( v3 < -1 )
      {
        sub_100031F0(v3);
        v4 = sub_10003240();
        sub_1000C6F0(0, 4, "%s::%s: Neterror: %s", aNetkrnl, v14, v4);
      }
      sub_10008030(*(_DWORD *)(a1 + 232), *i);
      (*(void (__thiscall **)(_DWORD, int))(**(_DWORD **)(a1 + 188) + 40))(*(_DWORD *)(a1 + 188), *i);
      if ( i[2] )
        sub_1000BBF0((void *)i[2]);
      if ( i[3] )
        sub_1000BBF0((void *)i[3]);
      sub_1000BBF0(i);
    }
  }
  sub_100243A0(v13);
  return v12;
}

//----- (10004AA0) --------------------------------------------------------
__int16 __cdecl sub_10004AA0(char *Source, int a2)
{
  int v3; // esi
  _DWORD *v4; // ebx
  _DWORD *v6; // eax
  int *v7; // eax
  int v8; // [esp+10h] [ebp-44h]
  char Buffer[64]; // [esp+14h] [ebp-40h] BYREF
  char *Sourcea; // [esp+58h] [ebp+4h]

  v8 = *(_DWORD *)(a2 + 40);
  sub_1000C620(*((_DWORD *)Source + 51), 4, 4, "Server game tick: Server accepted LOGMEON.");
  v3 = *(_DWORD *)(a2 + 4) + 4;
  Sourcea = (char *)(*(_DWORD *)(a2 + 4) + 8);
  v4 = (_DWORD *)sub_10006480(*(_DWORD *)(*((_DWORD *)Source + 48) + 12), Sourcea, (char *)(*(_DWORD *)(a2 + 4) + 40));
  if ( v4 )
  {
    sub_10005E10((int)v4, Sourcea, (char *)(v3 + 36), *(_DWORD *)v3);
    *(_DWORD *)(v8 + 24) = v4;
    sprintf(Buffer, "YOUR ID IS: << %ld >>", *v4);
    sub_1000C620(*((_DWORD *)Source + 51), 4, 4, Buffer);
    v6 = sub_1000BB40(16);
    if ( v6 )
    {
      *v6 = Source;
      v6[1] = *((_DWORD *)Source + 48);
      v6[2] = v8;
      sub_10022F30(*((_DWORD *)Source + 50), (int)sub_10004080, (int)v6, *((_DWORD *)Source + 22), 100, 1, 1);
    }
    sub_1000C620(*((_DWORD *)Source + 51), 4, 4, "Server game tick: LOGON completed.");
    v7 = *(int **)(*(_DWORD *)(a2 + 40) + 24);
    if ( v7 )
      sub_10008160(*((int **)Source + 58), *v7);
    return 0;
  }
  else
  {
    sub_1000C620(*((_DWORD *)Source + 51), 16, 1, "Server game tick: ServerAcceptedLOGON: Insert usradr failed.");
    return -1;
  }
}

//----- (10004BD0) --------------------------------------------------------
__int16 __cdecl sub_10004BD0(int a1, int a2)
{
  int *v2; // eax

  sub_1000C620(*(_DWORD *)(a1 + 204), 4, 4, "Server game tick: Server accepted LOGMEOFF.");
  v2 = *(int **)(*(_DWORD *)(a2 + 40) + 24);
  if ( v2 )
    sub_10008210(*(_DWORD *)(a1 + 232), *v2);
  return 0;
}

//----- (10004C10) --------------------------------------------------------
__int16 __cdecl sub_10004C10(_DWORD *a1, _BYTE *a2, int a3)
{
  _DWORD *v3; // eax

  if ( (*a2 & 0x40) != 0 )
    return 0;
  v3 = sub_1000BB40(16);
  if ( v3 )
  {
    *v3 = a1;
    v3[1] = a1[48];
    v3[2] = a2;
    sub_10022F30(a1[50], (int)sub_10004000, (int)v3, a3, 34, 1, 1);
    return 0;
  }
  sub_1000C620(a1[51], 16, 1, "LogClientOff: Alloc Parameter failed.");
  return -1;
}

//----- (10004C80) --------------------------------------------------------
__int16 __cdecl sub_10004C80(int *a1, SOCKET *Block)
{
  unsigned int v3; // edi
  int *v4; // eax
  int v5; // edi
  _DWORD *v6; // eax

  if ( sub_1000E090(a1[33], 0xFFFFFFFF) )
  {
    v3 = a1[34];
    if ( sub_1000E0E0(a1[33]) == -1 )
    {
      sub_1000C620(a1[51], 16, 1, "KRNL_InitUser: unlocking varblock mutex failed.");
      sub_1000CD60(Block);
      return -1;
    }
    else if ( sub_10005F70((int)a1) < v3 )
    {
      v4 = sub_10005FA0((int)a1, (int)Block, a1[23]);
      v5 = (int)v4;
      if ( v4 )
      {
        v6 = sub_10003A60((int)a1, (int)v4);
        if ( v6 )
        {
          sub_10022F30(a1[50], (int)sub_10004000, (int)v6, a1[25], 34, 1, 1);
          sub_1000C8D0(*(_DWORD *)(*(_DWORD *)(v5 + 8) + 40), 16, 1);
          sub_1000C8D0(*(_DWORD *)(*(_DWORD *)(v5 + 12) + 40), 16, 1);
          return 0;
        }
        else
        {
          sub_1000C620(a1[51], 16, 1, "KRNL_InitUser: Cannot alloc parameter.");
          sub_10006200((int)a1, v5);
          sub_1000CD60(Block);
          return -1;
        }
      }
      else
      {
        sub_1000C620(a1[51], 16, 1, "KRNL_InitUser: Cannot init user.");
        sub_1000CD60(Block);
        return -1;
      }
    }
    else
    {
      sub_1000C620(a1[51], 16, 1, "KRNL_InitUser: Cannot init user, maximum reached.");
      sub_1000CD60(Block);
      return 0;
    }
  }
  else
  {
    sub_1000C620(a1[51], 16, 1, "KRNL_InitUser: locking varblock mutex failed.");
    sub_1000CD60(Block);
    return -1;
  }
}

//----- (10004E10) --------------------------------------------------------
__int16 __cdecl sub_10004E10(int a1, int a2)
{
  int v2; // eax
  __int16 result; // ax

  v2 = *(_DWORD *)(a2 + 20);
  if ( v2 == -268435508 )
  {
    sub_10009720(
      *(_DWORD *)(a1 + 232),
      -268435508,
      *(_DWORD *)(a2 + 16),
      *(unsigned __int16 **)(a2 + 4),
      *(_DWORD *)(a2 + 8));
    return 0;
  }
  else
  {
    result = sub_10003C10(
               a1,
               *(_DWORD *)(a2 + 16),
               v2,
               *(_DWORD *)(a2 + 28),
               2,
               *(_BYTE **)(a2 + 4),
               *(_DWORD *)(a2 + 8));
    if ( result != -1 )
    {
      if ( *(_DWORD *)(a2 + 20) == -268435491 )
        sub_10009720(
          *(_DWORD *)(a1 + 232),
          -268435491,
          *(_DWORD *)(a2 + 16),
          *(unsigned __int16 **)(a2 + 4),
          *(_DWORD *)(a2 + 8));
      return 0;
    }
  }
  return result;
}

//----- (10004EA0) --------------------------------------------------------
__int16 __cdecl sub_10004EA0(int a1, int a2)
{
  sub_10009720(
    *(_DWORD *)(a1 + 232),
    *(_DWORD *)(a2 + 20),
    *(_DWORD *)(a2 + 16),
    *(unsigned __int16 **)(a2 + 4),
    *(_DWORD *)(a2 + 8));
  return 0;
}

//----- (10004ED0) --------------------------------------------------------
__int16 __cdecl sub_10004ED0(int a1, _DWORD *a2)
{
  int v2; // eax
  _BYTE *v3; // edi

  v2 = a2[5];
  v3 = (_BYTE *)a2[1];
  if ( v2 == -268435508 )
  {
    if ( sub_10003EA0(a1, (int)a2) == -1 )
    {
      sub_100084D0(*(int **)(a1 + 232), a2[5], a2[4], (int)v3);
      return -1;
    }
    sub_10008430(*(_DWORD *)(a1 + 232), a2[5], a2[4], (int)v3);
    return 0;
  }
  else
  {
    if ( sub_10003C10(a1, a2[4], v2, a2[7], 12, v3, a2[2]) == -1 )
      return -1;
    return 0;
  }
}

//----- (10004F60) --------------------------------------------------------
__int16 __cdecl sub_10004F60(int a1, _DWORD *a2)
{
  int v2; // edi

  v2 = a2[1];
  if ( sub_10003EA0(a1, (int)a2) == -1 )
  {
    sub_100084D0(*(int **)(a1 + 232), a2[5], a2[4], v2);
    return -1;
  }
  else
  {
    sub_10008430(*(_DWORD *)(a1 + 232), a2[5], a2[4], v2);
    return 0;
  }
}

//----- (10004FC0) --------------------------------------------------------
__int16 __cdecl sub_10004FC0(int a1, int a2)
{
  sub_10008550(
    *(int **)(a1 + 232),
    *(_DWORD *)(a2 + 20),
    *(_DWORD *)(a2 + 16),
    **(_DWORD **)(a2 + 4),
    *(_DWORD *)(a2 + 4) + 4,
    *(_DWORD *)(a2 + 8) - 4);
  return 0;
}

//----- (10005010) --------------------------------------------------------
void __cdecl sub_10005010(int a1, _DWORD *a2)
{
  bool v2; // zf
  _BYTE *v3; // eax
  char v4; // cl
  char v5; // dl
  char v6; // bl
  int v7; // [esp+4h] [ebp-54h] BYREF
  char v8; // [esp+8h] [ebp-50h]
  char v9; // [esp+9h] [ebp-4Fh]
  char v10; // [esp+Ah] [ebp-4Eh]
  char v11; // [esp+Bh] [ebp-4Dh]
  char *v12[3]; // [esp+Ch] [ebp-4Ch] BYREF
  char Buffer[64]; // [esp+18h] [ebp-40h] BYREF

  sub_10024660(v12);
  v2 = *(_WORD *)a1 == 1;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v7 = 1;
  if ( v2 )
  {
    sub_10024620(v12, "- LOGIN   ");
    sub_100228F0((int *)(a2[2] + 16), Buffer);
    sub_10024640(v12, Buffer);
    sub_10024640(v12, (char *)&word_1003C428);
    v3 = (_BYTE *)a2[4];
    v4 = v3[531];
    v5 = v3[530];
    v6 = v3[529];
    LOBYTE(v3) = v3[528];
    v11 = v4;
    v8 = (char)v3;
    v9 = v6;
    v10 = v5;
    v7 = 1;
    sub_10024420((unsigned __int8 *)&v7, Buffer);
    sub_10024640(v12, Buffer);
    sub_10024640(v12, (char *)&word_1003C428);
    sub_10024640(v12, (char *)(a2[6] + 4));
    sub_1000C620(*(_DWORD *)(a1 + 208), 4, 4, v12[0]);
    sub_10024450((int)v12);
  }
  else
  {
    sub_10024450((int)v12);
  }
}
// 1003C428: using guessed type __int16 word_1003C428;

//----- (10005120) --------------------------------------------------------
__int16 __cdecl sub_10005120(int a1, _DWORD *a2)
{
  __int16 result; // ax
  unsigned int v3; // eax
  char *v4; // edi
  char *v6; // edi
  _BYTE *v8; // eax
  char v9; // cl
  char v10; // dl
  char v11; // bl
  unsigned int v12; // eax
  char *v13; // edi
  int v15; // edx
  int *v16; // eax
  char *v17; // edi
  unsigned int v19; // eax
  char *v20; // edi
  char *v22; // edi
  int v24; // edx
  unsigned int v25; // eax
  char *v26; // edi
  int v28; // edx
  unsigned int v29; // eax
  char *v30; // edi
  int v32; // edx
  unsigned int v33; // eax
  char *v34; // edi
  int v36; // edx
  unsigned int v37; // eax
  char *v38; // edi
  int v40; // [esp+4h] [ebp-F8h] BYREF
  char v41; // [esp+8h] [ebp-F4h]
  char v42; // [esp+9h] [ebp-F3h]
  char v43; // [esp+Ah] [ebp-F2h]
  char v44; // [esp+Bh] [ebp-F1h]
  int v45[2]; // [esp+Ch] [ebp-F0h] BYREF
  char v46[32]; // [esp+14h] [ebp-E8h] BYREF
  int v47; // [esp+34h] [ebp-C8h] BYREF
  char Buffer[63]; // [esp+3Ch] [ebp-C0h] BYREF
  char v49; // [esp+7Bh] [ebp-81h] BYREF
  char v50[128]; // [esp+7Ch] [ebp-80h] BYREF

  v41 = 0;
  v42 = 0;
  v43 = 0;
  v44 = 0;
  v40 = 1;
  sub_10022170(v45);
  result = a1;
  if ( *(_WORD *)a1 == 1 )
  {
    strcpy(v50, "- LOGOUT  ");
    sub_10022500(v45);
    sub_100228F0(v45, v46);
    v3 = strlen(v46) + 1;
    v4 = &v49;
    while ( *++v4 )
      ;
    qmemcpy(v4, v46, v3);
    v6 = &v49;
    while ( *++v6 )
      ;
    *(_WORD *)v6 = 32;
    v8 = (_BYTE *)a2[4];
    v9 = v8[531];
    v10 = v8[530];
    v11 = v8[529];
    LOBYTE(v8) = v8[528];
    v44 = v9;
    v41 = (char)v8;
    v42 = v11;
    v43 = v10;
    v40 = 1;
    sub_10024420((unsigned __int8 *)&v40, v46);
    v12 = strlen(v46) + 1;
    v13 = &v49;
    while ( *++v13 )
      ;
    v15 = a2[2];
    qmemcpy(v13, v46, v12);
    v16 = sub_10022710(v45, &v47, (_DWORD *)(v15 + 16));
    v45[0] = *v16;
    v45[1] = v16[1];
    v17 = &v49;
    while ( *++v17 )
      ;
    strcpy(v17, " ONLINE: ");
    sub_100227F0(v45, v46);
    v19 = strlen(v46) + 1;
    v20 = &v49;
    while ( *++v20 )
      ;
    qmemcpy(v20, v46, v19);
    v22 = &v49;
    while ( *++v22 )
      ;
    v24 = a2[2];
    *(_WORD *)v22 = 32;
    sprintf(Buffer, "IN: %ld - ", *(_DWORD *)(v24 + 24));
    v25 = strlen(Buffer) + 1;
    v26 = &v49;
    while ( *++v26 )
      ;
    v28 = a2[2];
    qmemcpy(v26, Buffer, v25);
    sprintf(Buffer, "%ld ", *(_DWORD *)(v28 + 28));
    v29 = strlen(Buffer) + 1;
    v30 = &v49;
    while ( *++v30 )
      ;
    v32 = a2[3];
    qmemcpy(v30, Buffer, v29);
    sprintf(Buffer, "OUT: %ld - ", *(_DWORD *)(v32 + 24));
    v33 = strlen(Buffer) + 1;
    v34 = &v49;
    while ( *++v34 )
      ;
    v36 = a2[3];
    qmemcpy(v34, Buffer, v33);
    sprintf(Buffer, "%ld ", *(_DWORD *)(v36 + 28));
    v37 = strlen(Buffer) + 1;
    v38 = &v49;
    while ( *++v38 )
      ;
    qmemcpy(v38, Buffer, v37);
    return sub_1000C620(*(_DWORD *)(a1 + 208), 4, 4, v50);
  }
  return result;
}
// 1003C428: using guessed type __int16 word_1003C428;

//----- (10005480) --------------------------------------------------------
__int16 __cdecl sub_10005480(int a1, int a2)
{
  __int16 result; // ax
  unsigned int v3; // eax
  char *v4; // edi
  char *v6; // edi
  _BYTE *v8; // eax
  char v9; // cl
  char v10; // dl
  char v11; // bl
  unsigned int v12; // eax
  char *v13; // edi
  int v15; // edx
  char *v16; // edi
  unsigned int v18; // eax
  char *v19; // edi
  int v21; // [esp+4h] [ebp-B0h] BYREF
  char v22; // [esp+8h] [ebp-ACh]
  char v23; // [esp+9h] [ebp-ABh]
  char v24; // [esp+Ah] [ebp-AAh]
  char v25; // [esp+Bh] [ebp-A9h]
  int v26[2]; // [esp+Ch] [ebp-A8h] BYREF
  char Buffer[31]; // [esp+14h] [ebp-A0h] BYREF
  char v28; // [esp+33h] [ebp-81h] BYREF
  char v29[128]; // [esp+34h] [ebp-80h] BYREF

  v22 = 0;
  v23 = 0;
  v24 = 0;
  v25 = 0;
  v21 = 1;
  sub_10022170(v26);
  result = a1;
  if ( *(_WORD *)a1 == 1 )
  {
    strcpy(v29, "- TIMEOUT ");
    sub_10022500(v26);
    sub_100228F0(v26, Buffer);
    v3 = strlen(Buffer) + 1;
    v4 = &v28;
    while ( *++v4 )
      ;
    qmemcpy(v4, Buffer, v3);
    v6 = &v28;
    while ( *++v6 )
      ;
    *(_WORD *)v6 = 32;
    v8 = *(_BYTE **)(a2 + 16);
    v9 = v8[531];
    v10 = v8[530];
    v11 = v8[529];
    LOBYTE(v8) = v8[528];
    v25 = v9;
    v22 = (char)v8;
    v23 = v11;
    v24 = v10;
    v21 = 1;
    sub_10024420((unsigned __int8 *)&v21, Buffer);
    v12 = strlen(Buffer) + 1;
    v13 = &v28;
    while ( *++v13 )
      ;
    v15 = *(_DWORD *)(a2 + 8);
    qmemcpy(v13, Buffer, v12);
    v26[0] = *(_DWORD *)(v15 + 8);
    v26[1] = *(_DWORD *)(v15 + 12);
    v16 = &v28;
    while ( *++v16 )
      ;
    strcpy(v16, " LAST MSG: ");
    sub_100227F0(v26, Buffer);
    v18 = strlen(Buffer) + 1;
    v19 = &v28;
    while ( *++v19 )
      ;
    qmemcpy(v19, Buffer, v18);
    return sub_1000C620(*(_DWORD *)(a1 + 208), 4, 4, v29);
  }
  return result;
}

//----- (10005660) --------------------------------------------------------
__int16 __cdecl sub_10005660(int a1, int a2)
{
  int v2; // esi
  _DWORD *v4; // eax
  void *v5; // ebx

  if ( *(_WORD *)(a1 + 242) == 2 )
    sub_1000C620(*(_DWORD *)(a1 + 204), 1, 4, "Server game tick: Log on Client.");
  v2 = *(_DWORD *)(a2 + 40);
  if ( sub_10005BE0(a1, v2) )
  {
    if ( sub_100064E0(
           *(_DWORD *)(*(_DWORD *)(a1 + 192) + 12),
           v2,
           (char *)(*(_DWORD *)(a2 + 4) + 8),
           (char *)(*(_DWORD *)(a2 + 4) + 40)) )
    {
      sub_1000C620(*(_DWORD *)(a1 + 204), 16, 1, "Server game tick: LogClientOn: ID System refused Logon.");
      return -1;
    }
    else
    {
      *(_DWORD *)v2 |= 1u;
      v4 = sub_1000BB40(52);
      v5 = v4;
      if ( v4 )
      {
        *v4 = -625280017;
        sub_10005E10((int)(v4 + 1), (char *)(*(_DWORD *)(v2 + 24) + 4), "-", **(_DWORD **)(v2 + 24));
        if ( sub_10003A90(a1, -268435508, **(_DWORD **)(v2 + 24), v2, 5, v5, 52) )
        {
          *(_DWORD *)v2 &= ~1u;
          sub_1000BBF0(v5);
          sub_1000C620(
            *(_DWORD *)(a1 + 204),
            16,
            1,
            "Server game tick: LogClientOn: Send message NET_MSGTYPE_LOGONACCEPTED failed.");
          return -1;
        }
        else
        {
          sub_10006390(*(_DWORD *)(a1 + 200), v2);
          sub_10005010(a1, (_DWORD *)v2);
          sub_10004360(a1, v2);
          return 0;
        }
      }
      else
      {
        *(_DWORD *)v2 &= ~1u;
        sub_1000C620(*(_DWORD *)(a1 + 204), 16, 1, "Server game tick: LogClientOn: Cannot alloc message.");
        return -1;
      }
    }
  }
  else
  {
    sub_1000C620(*(_DWORD *)(a1 + 204), 4, 4, "KRNL_LogClientOn: User not found, already removed ?");
    return -1;
  }
}

//----- (100057D0) --------------------------------------------------------
__int16 __cdecl sub_100057D0(int a1, int a2)
{
  int v2; // esi
  int *v4; // eax
  _DWORD *v5; // eax
  void *v6; // ebx
  int v7; // [esp-28h] [ebp-30h]

  if ( *(_WORD *)(a1 + 242) == 2 )
    sub_1000C620(*(_DWORD *)(a1 + 204), 1, 4, "Server game tick: LogClientOff.");
  v2 = *(_DWORD *)(a2 + 40);
  if ( sub_10005BE0(a1, v2) && (v4 = *(int **)(v2 + 24)) != 0 )
  {
    sub_10008210(*(_DWORD *)(a1 + 232), *v4);
    v5 = sub_1000BB40(52);
    v6 = v5;
    if ( v5 )
    {
      *v5 = -625280017;
      if ( sub_10003A90(a1, -268435508, **(_DWORD **)(v2 + 24), v2, 6, v5, 52) )
      {
        sub_1000BBF0(v6);
        sub_1000C620(
          *(_DWORD *)(a1 + 204),
          16,
          1,
          "Server game tick: LogClientOff: Send message NET_MSGTYPE_LOGOFFACCEPTED failed.");
        return -1;
      }
      else
      {
        sub_1000E090(*(_DWORD *)(v2 + 4), 0xFFFFFFFF);
        sub_1000C8D0(*(_DWORD *)(*(_DWORD *)(v2 + 8) + 40), 8, 1);
        sub_10004C10((_DWORD *)a1, (_BYTE *)v2, *(_DWORD *)(a1 + 72));
        v7 = *(_DWORD *)(v2 + 4);
        *(_DWORD *)v2 &= ~1u;
        sub_1000E0E0(v7);
        sub_1000C620(*(_DWORD *)(a1 + 204), 4, 4, "Server game tick: LogClientOff completed.");
        return 0;
      }
    }
    else
    {
      sub_1000C620(*(_DWORD *)(a1 + 204), 16, 1, "Server game tick: LogClientOff: Cannot alloc message.");
      return -1;
    }
  }
  else
  {
    sub_1000C620(*(_DWORD *)(a1 + 204), 4, 4, "KRNL_LogClientOff: User not found, already removed ?");
    return -1;
  }
}

//----- (10005940) --------------------------------------------------------
__int16 __cdecl sub_10005940(int a1, int a2)
{
  int *v2; // eax

  sub_1000C620(*(_DWORD *)(a1 + 204), 4, 16, "KRNL_RemoveUser: Removing user.");
  if ( sub_10005BE0(a1, a2) )
  {
    sub_10005120(a1, (_DWORD *)a2);
    sub_10004220(a1, (_DWORD *)a2);
    v2 = *(int **)(a2 + 24);
    if ( v2 )
      sub_10008350(*(int **)(a1 + 232), *v2);
    sub_10006390(*(_DWORD *)(a1 + 200), a2);
    if ( *(_DWORD *)(a2 + 24) )
    {
      sub_10005E90(*(_DWORD *)(*(_DWORD *)(a1 + 192) + 12), *(unsigned int **)(a2 + 24));
      *(_DWORD *)(a2 + 24) = 0;
    }
    sub_10006200(a1, a2);
  }
  return 0;
}

//----- (100059F0) --------------------------------------------------------
int __cdecl sub_100059F0(int *a1)
{
  int v1; // esi
  int v2; // ecx
  __int16 i; // ax
  int v4; // ebx
  int v5; // edi
  int v6; // eax
  int *v7; // eax
  int v9[2]; // [esp+10h] [ebp-10h] BYREF
  int v10[2]; // [esp+18h] [ebp-8h] BYREF

  v1 = *a1;
  sub_10022170(v10);
  sub_10022170(v9);
  sub_1000E090(**(_DWORD **)(v1 + 192), 0xFFFFFFFF);
  sub_10022500(v10);
  v2 = *(_DWORD *)(*(_DWORD *)(v1 + 192) + 4);
  for ( i = *(_WORD *)(v2 + 12); i != -1; i = *(_WORD *)(*(_DWORD *)(v2 + 8) + v4 + 4) )
  {
    v4 = 12 * i;
    v5 = *(_DWORD *)(*(_DWORD *)(v2 + 8) + v4 + 8);
    if ( v5 )
    {
      v6 = *(_DWORD *)(v5 + 8);
      v9[0] = *(_DWORD *)(v6 + 8);
      v9[1] = *(_DWORD *)(v6 + 12);
      sub_100226A0(v9, *(_DWORD *)(v1 + 80));
      if ( sub_10021EA0(v9, v10) )
      {
        sub_10005480(v1, v5);
        sub_1000E0E0(**(_DWORD **)(v1 + 192));
        sub_1000C620(*(_DWORD *)(v1 + 204), 4, 16, "Server game tick: CONNECTION LOST.");
        sub_1000C720("*** KRNL_ConnectionLost");
        v7 = *(int **)(v5 + 24);
        if ( v7 )
          sub_100082B0(*(_DWORD *)(v1 + 232), *v7);
        sub_100039F0(v1, (_BYTE *)v5);
        sub_1000E090(**(_DWORD **)(v1 + 192), 0xFFFFFFFF);
      }
    }
    else
    {
      sub_1000C620(*(_DWORD *)(v1 + 204), 8, 1, "KRNL_PTR_CheckDeadConnections: No usr set.");
    }
    v2 = *(_DWORD *)(*(_DWORD *)(v1 + 192) + 4);
  }
  sub_1000E0E0(**(_DWORD **)(v1 + 192));
  return 0;
}

//----- (10005B50) --------------------------------------------------------
__int16 __cdecl sub_10005B50(int a1, int a2, int a3)
{
  int v3; // esi
  DWORD v4; // ebp

  v3 = 0;
  v4 = GetTickCount() + a2;
  while ( 1 )
  {
    if ( (sub_1000C930(*(_DWORD *)(*(_DWORD *)(a1 + 8) + 40), 1) & a3) != 0 )
      ++v3;
    if ( (sub_1000C930(*(_DWORD *)(*(_DWORD *)(a1 + 12) + 40), 1) & a3) != 0 )
      ++v3;
    if ( GetTickCount() > v4 )
      break;
    if ( (__int16)v3 < 2 )
      sub_1000DDA0(0x32u);
    sub_1000E480();
    if ( (__int16)v3 >= 2 )
      return 0;
  }
  sub_1000C7C0("NETUSR::NETUSR_WaitForUserThreads()...timeout !");
  return -1;
}

//----- (10005BE0) --------------------------------------------------------
__int16 __cdecl sub_10005BE0(int a1, int a2)
{
  __int16 v2; // di
  int *v3; // esi
  int v4; // ecx
  __int16 v5; // ax
  int v6; // ecx
  int v7; // eax
  int v8; // ebx
  int v9; // eax

  v2 = 0;
  sub_1000E090(**(_DWORD **)(a1 + 192), 0xFFFFFFFF);
  v3 = *(int **)(a1 + 192);
  v4 = v3[1];
  v5 = *(_WORD *)(v4 + 12);
  if ( v5 != -1 )
  {
    v6 = *(_DWORD *)(v4 + 8);
    while ( 1 )
    {
      v7 = 3 * v5;
      v8 = *(_DWORD *)(v6 + 4 * v7 + 8);
      v9 = v6 + 4 * v7;
      if ( a2 == v8 )
        break;
      v5 = *(_WORD *)(v9 + 4);
      if ( v5 == -1 )
      {
        sub_1000E0E0(*v3);
        return 0;
      }
    }
    v2 = 1;
  }
  sub_1000E0E0(*v3);
  return v2;
}

//----- (10005C60) --------------------------------------------------------
int __cdecl sub_10005C60(int a1)
{
  int v1; // esi
  int *v2; // edi
  int v3; // ecx
  int v4; // eax
  int v5; // ecx
  int v6; // eax

  v1 = 0;
  sub_1000E090(**(_DWORD **)(a1 + 192), 0xFFFFFFFF);
  v2 = *(int **)(a1 + 192);
  v3 = v2[1];
  v4 = *(_DWORD *)(v3 + 12);
  if ( v4 != -1 )
  {
    v5 = *(_DWORD *)(v3 + 8);
    do
    {
      v1 = *(_DWORD *)(v5 + 12 * v4 + 8);
      v6 = v5 + 12 * v4;
      if ( v1 )
        break;
      v4 = *(_DWORD *)(v6 + 4);
    }
    while ( v4 != -1 );
  }
  sub_1000E0E0(*v2);
  return v1;
}

//----- (10005CC0) --------------------------------------------------------
BOOL __cdecl sub_10005CC0(_BYTE *a1)
{
  return (*a1 & 0x11) != 0;
}

//----- (10005CE0) --------------------------------------------------------
BOOL __cdecl sub_10005CE0(int a1, int a2)
{
  return *(_DWORD *)(a1 + 8) == *(_DWORD *)(a2 + 8);
}

//----- (10005D00) --------------------------------------------------------
__int16 __cdecl sub_10005D00(int a1, unsigned __int16 a2, int a3)
{
  __int16 result; // ax

  if ( a2 < 3u )
  {
    if ( a3 )
      result = sub_1000E090(*(_DWORD *)(a1 + 4), 0xFFFFFFFF);
    *(_DWORD *)(a1 + 4 * a2 + 28) = 0;
    if ( a3 )
      return sub_1000E0E0(*(_DWORD *)(a1 + 4));
  }
  return result;
}

//----- (10005D50) --------------------------------------------------------
int __cdecl sub_10005D50(int a1, unsigned __int16 a2, int a3)
{
  if ( a2 >= 3u )
    return 0;
  sub_1000E090(*(_DWORD *)(a1 + 4), 0xFFFFFFFF);
  *(_DWORD *)(a1 + 4 * a2 + 28) = a3;
  sub_1000E0E0(*(_DWORD *)(a1 + 4));
  return 1;
}

//----- (10005D90) --------------------------------------------------------
int __cdecl sub_10005D90(int a1, unsigned __int16 a2)
{
  int v3; // edi

  if ( a2 >= 3u )
    return 0;
  sub_1000E090(*(_DWORD *)(a1 + 4), 0xFFFFFFFF);
  v3 = *(_DWORD *)(a1 + 4 * a2 + 28);
  sub_1000E0E0(*(_DWORD *)(a1 + 4));
  return v3;
}

//----- (10005DD0) --------------------------------------------------------
__int16 __cdecl sub_10005DD0(void *Block)
{
  if ( *((_DWORD *)Block + 4) )
    sub_1000BBF0(*((void **)Block + 4));
  if ( *((_DWORD *)Block + 3) )
    sub_100230C0(*((void ***)Block + 3));
  sub_1000BBF0(Block);
  return 0;
}

//----- (10005E10) --------------------------------------------------------
char *__cdecl sub_10005E10(int a1, char *Source, char *a3, int a4)
{
  char *result; // eax
  char v5; // cl
  char v6[8]; // [esp+4h] [ebp-28h] BYREF
  char Destination[32]; // [esp+Ch] [ebp-20h] BYREF

  *(_DWORD *)a1 = a4;
  strncpy(Destination, Source, 0x20u);
  strncpy(v6, a3, 8u);
  Destination[31] = 0;
  v6[7] = 0;
  strcpy((char *)(a1 + 4), Destination);
  result = v6;
  do
  {
    v5 = *result;
    result[a1 + 36 - (_DWORD)v6] = *result;
    ++result;
  }
  while ( v5 );
  *(_DWORD *)(a1 + 44) |= 1u;
  return result;
}

//----- (10005E90) --------------------------------------------------------
__int16 __cdecl sub_10005E90(int a1, unsigned int *a2)
{
  int v2; // edi
  unsigned int *i; // eax

  v2 = 0;
  if ( *(int *)(a1 + 4) <= 0 )
    return -1;
  for ( i = *(unsigned int **)(a1 + 16); i != a2; i += 12 )
  {
    if ( ++v2 >= *(_DWORD *)(a1 + 4) )
      return -1;
  }
  sub_10023110(*(_DWORD **)(a1 + 12), *i);
  *(_DWORD *)(48 * v2 + *(_DWORD *)(a1 + 16) + 44) = 0;
  --*(_DWORD *)(a1 + 8);
  return 0;
}

//----- (10005EF0) --------------------------------------------------------
int __cdecl sub_10005EF0(int a1, int a2)
{
  int *v2; // ebx
  int v3; // eax
  __int16 v4; // si
  int v5; // edx
  int v6; // edi
  _DWORD *v7; // ecx

  sub_1000E090(**(_DWORD **)(a1 + 192), 0xFFFFFFFF);
  v2 = *(int **)(a1 + 192);
  v3 = v2[1];
  v4 = *(_WORD *)(v3 + 12);
  if ( v4 == -1 )
  {
    v6 = a1;
  }
  else
  {
    v5 = *(_DWORD *)(v3 + 8);
    do
    {
      v6 = *(_DWORD *)(v5 + 12 * v4 + 8);
      v7 = *(_DWORD **)(v6 + 24);
      if ( v7 && *v7 == a2 )
        break;
      v4 = *(_WORD *)(v5 + 12 * v4 + 4);
    }
    while ( v4 != -1 );
  }
  sub_1000E0E0(*v2);
  return v4 == -1 ? 0 : v6;
}

//----- (10005F70) --------------------------------------------------------
int __cdecl sub_10005F70(int a1)
{
  int v1; // eax
  int v2; // esi

  sub_1000E090(**(_DWORD **)(a1 + 192), 0xFFFFFFFF);
  v1 = *(_DWORD *)(a1 + 192);
  v2 = **(_DWORD **)(v1 + 4);
  sub_1000E0E0(*(_DWORD *)v1);
  return v2;
}

//----- (10005FA0) --------------------------------------------------------
int *__cdecl sub_10005FA0(int a1, int a2, int a3)
{
  int *v3; // esi
  _DWORD *v5; // eax
  HANDLE **v6; // eax
  HANDLE **v7; // eax
  int v8; // ecx
  __int16 v9; // ax

  if ( *(_WORD *)(a1 + 244) == 2 )
    sub_1000C620(*(_DWORD *)(a1 + 204), 4, 16, "InitUser: Creating New user...");
  v3 = (int *)sub_1000BB40(40);
  if ( v3 )
  {
    v5 = sub_1000E120(2);
    v3[1] = (int)v5;
    if ( v5 )
    {
      v3[4] = a2;
      *v3 = 32;
      v6 = sub_100028A0(a1, a2, 1);
      v3[2] = (int)v6;
      if ( v6 )
      {
        v7 = sub_10002940(a1, v3[4], 1);
        v3[3] = (int)v7;
        if ( v7 )
        {
          *(_DWORD *)(v3[2] + 96) = v3;
          *(_DWORD *)(v3[3] + 96) = v3;
          if ( sub_10005B50((int)v3, a3, 64) )
          {
            sub_1000C620(*(_DWORD *)(a1 + 204), 8, 2, "InitUser: thread start failed.");
            sub_1000C7C0("InitUser: thread start failed.");
            sub_10001F30(a1, (HANDLE **)v3[2]);
            sub_100022D0(a1, (void *)v3[3]);
            sub_1000E1E0((HANDLE *)v3[1]);
            sub_1000BBF0(v3);
            return 0;
          }
          else
          {
            v8 = *v3;
            v3[6] = 0;
            *v3 = v8 | 0xE;
            v3[7] = 0;
            v3[8] = 0;
            v3[9] = 0;
            sub_1000E090(**(_DWORD **)(a1 + 192), 0xFFFFFFFF);
            v9 = sub_10024A20(*(_DWORD **)(*(_DWORD *)(a1 + 192) + 4), (int)v3);
            *((_WORD *)v3 + 10) = v9;
            if ( v9 == -1 )
            {
              sub_1000C620(*(_DWORD *)(a1 + 204), 8, 2, "InitUser: insert list failed.");
              sub_10001F30(a1, (HANDLE **)v3[2]);
              sub_100022D0(a1, (void *)v3[3]);
              sub_1000E1E0((HANDLE *)v3[1]);
              sub_1000BBF0(v3);
              sub_1000E0E0(**(_DWORD **)(a1 + 192));
              return 0;
            }
            else
            {
              sub_1000E0E0(**(_DWORD **)(a1 + 192));
              if ( *(_WORD *)(a1 + 244) == 2 )
                sub_1000C620(*(_DWORD *)(a1 + 204), 1, 16, "InitUser: New user ready.");
              return v3;
            }
          }
        }
        else
        {
          sub_1000C620(*(_DWORD *)(a1 + 204), 8, 2, "InitUser: Cannot start new writer thread.");
          sub_10001F30(a1, (HANDLE **)v3[2]);
          sub_1000E1E0((HANDLE *)v3[1]);
          sub_1000BBF0(v3);
          return 0;
        }
      }
      else
      {
        sub_1000C620(*(_DWORD *)(a1 + 204), 8, 2, "InitUser: Cannot start new reader thread.");
        sub_1000E1E0((HANDLE *)v3[1]);
        sub_1000BBF0(v3);
        return 0;
      }
    }
    else
    {
      sub_1000BBF0(v3);
      return 0;
    }
  }
  else
  {
    sub_1000C620(*(_DWORD *)(a1 + 204), 8, 2, "InitUser: Error allocating memory for user.");
    return 0;
  }
}

//----- (10006200) --------------------------------------------------------
__int16 __cdecl sub_10006200(int a1, int a2)
{
  SOCKET *v2; // eax

  sub_1000E090(**(_DWORD **)(a1 + 192), 0xFFFFFFFF);
  sub_1000E090(*(_DWORD *)(a2 + 4), 0xFFFFFFFF);
  v2 = *(SOCKET **)(a2 + 16);
  *(_DWORD *)a2 &= 0xFFFFFFEE;
  if ( v2 )
    sub_1000CD60(v2);
  *(_DWORD *)(a2 + 28) = 0;
  *(_DWORD *)(a2 + 32) = 0;
  *(_DWORD *)(a2 + 36) = 0;
  sub_10001F30(a1, *(HANDLE ***)(a2 + 8));
  sub_100022D0(a1, *(void **)(a2 + 12));
  sub_1000E0E0(*(_DWORD *)(a2 + 4));
  sub_1000E1E0(*(HANDLE **)(a2 + 4));
  sub_10024690(*(_DWORD **)(*(_DWORD *)(a1 + 192) + 4), *(__int16 *)(a2 + 20), 1);
  sub_1000E0E0(**(_DWORD **)(a1 + 192));
  if ( *(_WORD *)(a1 + 244) == 2 )
    sub_1000C620(*(_DWORD *)(a1 + 204), 1, 16, "NETUSR_RemoveUser: User removed.");
  return 0;
}

//----- (100062C0) --------------------------------------------------------
__int16 __cdecl sub_100062C0(int a1)
{
  __int16 i; // ax
  int *v3; // ecx
  int v4; // edi

  if ( sub_1000E090(**(_DWORD **)(a1 + 192), 0xFFFFFFFF) )
  {
    for ( i = *(_WORD *)(*(_DWORD *)(*(_DWORD *)(a1 + 192) + 4) + 12);
          i != -1;
          i = *(_WORD *)(*(_DWORD *)(*(_DWORD *)(a1 + 192) + 4) + 12) )
    {
      v3 = *(int **)(a1 + 192);
      v4 = *(_DWORD *)(*(_DWORD *)(v3[1] + 8) + 12 * i + 8);
      sub_1000E0E0(*v3);
      sub_10006200(a1, v4);
      sub_1000E090(**(_DWORD **)(a1 + 192), 0xFFFFFFFF);
    }
    if ( sub_1000E0E0(**(_DWORD **)(a1 + 192)) == -1 )
      sub_1000C7C0("NETUSR::NETUSR_RemoveAllUser(): unlocking mutex failed !");
    return 0;
  }
  else
  {
    sub_1000C7C0("NETUSR::NETUSR_RemoveAllUser(): locking mutex failed !");
    return 0;
  }
}

//----- (10006390) --------------------------------------------------------
__int16 __cdecl sub_10006390(int a1, int a2)
{
  char v3[8]; // [esp+0h] [ebp-10h] BYREF
  int v4; // [esp+8h] [ebp-8h]

  v4 = a2;
  return sub_10022E20(a1, sub_10005CE0, (int)v3);
}
// 10006390: using guessed type char var_10[8];

//----- (100063C0) --------------------------------------------------------
int *__cdecl sub_100063C0(int a1, int a2)
{
  int *result; // eax
  int *v3; // esi
  _DWORD *v4; // eax
  void *v5; // eax
  int v6; // eax
  int v7; // ecx

  result = (int *)sub_1000BB40(20);
  v3 = result;
  if ( result )
  {
    v4 = sub_10023060(a1);
    v3[3] = (int)v4;
    if ( v4 )
    {
      v5 = sub_1000BB40(48 * a2);
      v3[4] = (int)v5;
      if ( v5 )
      {
        v6 = 0;
        *v3 = a1;
        v3[1] = a2;
        v3[2] = 0;
        if ( a2 > 0 )
        {
          v7 = 0;
          do
          {
            *(_DWORD *)(v3[4] + v7 + 44) = 0;
            ++v6;
            v7 += 48;
          }
          while ( v6 < v3[1] );
        }
        return v3;
      }
      else
      {
        sub_10005DD0(v3);
        return 0;
      }
    }
    else
    {
      if ( v3[4] )
        sub_1000BBF0((void *)v3[4]);
      if ( v3[3] )
        sub_100230C0((void **)v3[3]);
      sub_1000BBF0(v3);
      return 0;
    }
  }
  return result;
}

//----- (10006480) --------------------------------------------------------
int __cdecl sub_10006480(int a1, char *Source, char *a3)
{
  int v3; // ecx
  int v4; // eax
  int v5; // edi
  int result; // eax

  v3 = 0;
  if ( *(int *)(a1 + 4) <= 0 )
    return 0;
  v4 = *(_DWORD *)(a1 + 16);
  do
  {
    v5 = v4;
    if ( !*(_DWORD *)(v4 + 44) )
      break;
    ++v3;
    v4 += 48;
  }
  while ( v3 < *(_DWORD *)(a1 + 4) );
  result = sub_100230E0(*(int **)(a1 + 12));
  if ( result )
  {
    sub_10005E10(v5, Source, a3, result);
    ++*(_DWORD *)(a1 + 8);
    return v5;
  }
  return result;
}

//----- (100064E0) --------------------------------------------------------
__int16 __cdecl sub_100064E0(int a1, int a2, char *Source, char *a4)
{
  int v5; // eax

  if ( *(_DWORD *)(a1 + 4) == *(_DWORD *)(a1 + 8) )
    return 1;
  v5 = sub_10006480(a1, Source, a4);
  *(_DWORD *)(a2 + 24) = v5;
  if ( v5 )
    return 0;
  sub_1000E0E0(*(_DWORD *)(a2 + 4));
  return 2;
}

//----- (10006530) --------------------------------------------------------
_DWORD *__cdecl sub_10006530(int a1, int a2)
{
  _DWORD *v2; // esi
  _DWORD *v4; // eax
  _DWORD *v5; // eax
  int *v6; // eax

  v2 = sub_1000BB40(16);
  if ( v2 )
  {
    v4 = sub_10024800(a2);
    v2[1] = v4;
    if ( v4 )
    {
      v5 = sub_1000E120(2);
      *v2 = v5;
      if ( v5 )
      {
        v6 = sub_100063C0(a2, a2);
        v2[3] = v6;
        if ( v6 )
        {
          v2[2] = a1;
          return v2;
        }
        else
        {
          sub_1000C6B0(0, 16, "NETUSR: InitUserList: ADDRInitSystem failed.");
          sub_1000E1E0(**(HANDLE ***)(a1 + 192));
          sub_10024A10(*(void **)(*(_DWORD *)(a1 + 192) + 4));
          sub_1000BBF0(v2);
          return 0;
        }
      }
      else
      {
        sub_1000C6B0(0, 16, "NETUSR: InitUserList: MUTX_Create failed.");
        sub_10024A10(*(void **)(*(_DWORD *)(a1 + 192) + 4));
        sub_1000BBF0(v2);
        return 0;
      }
    }
    else
    {
      sub_1000C6B0(0, 16, "NETUSR: InitUserList: PL_Init failed.");
      sub_1000BBF0(v2);
      return 0;
    }
  }
  else
  {
    sub_1000C6B0(0, 16, "NETUSR: InitUserList: alloc usrlst failed.");
    return 0;
  }
}

//----- (10006630) --------------------------------------------------------
__int16 __cdecl sub_10006630(int a1)
{
  int v1; // esi

  sub_100062C0(a1);
  v1 = *(_DWORD *)(*(_DWORD *)(a1 + 192) + 12);
  if ( *(_DWORD *)(v1 + 16) )
    sub_1000BBF0(*(void **)(v1 + 16));
  if ( *(_DWORD *)(v1 + 12) )
    sub_100230C0(*(void ***)(v1 + 12));
  sub_1000BBF0((void *)v1);
  sub_1000E1E0(**(HANDLE ***)(a1 + 192));
  sub_10024A10(*(void **)(*(_DWORD *)(a1 + 192) + 4));
  sub_1000BBF0(*(void **)(a1 + 192));
  return 0;
}

//----- (10006710) --------------------------------------------------------
_DWORD *TinCat_CreateEasyCatServerAPI()
{
  _DWORD *result; // eax

  result = operator new(4u);
  if ( !result )
    return 0;
  *result = &off_1003CC9C;
  return result;
}
// 1003CC9C: using guessed type void *off_1003CC9C;

//----- (10006730) --------------------------------------------------------
_DWORD *TinCat_CreateEasyCatClientAPI()
{
  _DWORD *result; // eax

  result = operator new(4u);
  if ( !result )
    return 0;
  *result = &off_1003CCA4;
  return result;
}
// 1003CCA4: using guessed type void *off_1003CCA4;

//----- (10006750) --------------------------------------------------------
_WORD *__cdecl sub_10006750(char *a1, int a2, _DWORD *a3, __int16 a4, __int16 a5)
{
  _WORD *result; // eax
  void *v6; // esi
  int v7; // edi

  result = sub_1000BB40(4);
  v6 = result;
  if ( result )
  {
    *result = a4;
    result[1] = a5;
    v7 = sub_1000BCE0(result, 4, a1, a2, 0);
    sub_1000BBF0(v6);
    if ( v7 )
    {
      *a3 = a2 + 4;
      return (_WORD *)v7;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

//----- (100067C0) --------------------------------------------------------
int __cdecl sub_100067C0(int a1, int a2, _DWORD *a3)
{
  *a3 = a2 - 4;
  return a1 + 4;
}

//----- (100067E0) --------------------------------------------------------
_WORD *__cdecl sub_100067E0(_DWORD *a1, __int16 a2, __int16 a3)
{
  _WORD *result; // eax

  result = sub_1000BB40(4);
  if ( result )
  {
    *result = a2;
    result[1] = a3;
    *a1 = 4;
  }
  return result;
}

//----- (10006810) --------------------------------------------------------
int __thiscall sub_10006810(int this)
{
  *(_DWORD *)this = &off_1003CCB8;
  *(_DWORD *)(this + 8) = 0;
  *(_DWORD *)(this + 12) = 0;
  *(_DWORD *)(this + 16) = 0;
  *(_DWORD *)(this + 20) = 0;
  sub_100227B0((WORD *)(this + 40));
  sub_10001000(this, 0, 0, 3, 3, 10);
  return this;
}
// 1003CCB8: using guessed type int (__stdcall *off_1003CCB8)(void *Block, __int16, int, int);

//----- (10006850) --------------------------------------------------------
__int16 __thiscall sub_10006850(_WORD *this)
{
  return this[4];
}

//----- (10006880) --------------------------------------------------------
_DWORD *__thiscall sub_10006880(_DWORD *this)
{
  *this = &off_1003CE60;
  sub_1000A8D0(this, 0, 2, -1, -1);
  return this;
}
// 1003CE60: using guessed type void *off_1003CE60;

//----- (100068A0) --------------------------------------------------------
int __thiscall sub_100068A0(_DWORD *this)
{
  return this[1];
}

//----- (100068B0) --------------------------------------------------------
int __thiscall sub_100068B0(_DWORD *this)
{
  return this[26];
}

//----- (100068C0) --------------------------------------------------------
int __thiscall sub_100068C0(_DWORD *this, int a2)
{
  int result; // eax

  result = a2;
  this[26] = a2;
  return result;
}

//----- (100068D0) --------------------------------------------------------
int __thiscall sub_100068D0(_DWORD *this)
{
  return this[24];
}

//----- (100068E0) --------------------------------------------------------
int __thiscall sub_100068E0(_DWORD *this)
{
  return this[25];
}

//----- (100068F0) --------------------------------------------------------
int __thiscall sub_100068F0(_DWORD *this)
{
  return this[17];
}

//----- (10006900) --------------------------------------------------------
int __thiscall sub_10006900(_DWORD *this)
{
  return this[19];
}

//----- (10006910) --------------------------------------------------------
int __thiscall sub_10006910(_DWORD *this, int a2)
{
  int result; // eax

  result = a2;
  this[5] = a2;
  return result;
}

//----- (10006920) --------------------------------------------------------
int __thiscall sub_10006920(_DWORD *this)
{
  return this[13];
}

//----- (10006930) --------------------------------------------------------
int __thiscall sub_10006930(_DWORD *this, int a2)
{
  int result; // eax

  result = a2;
  this[13] = a2;
  return result;
}

//----- (10006940) --------------------------------------------------------
int __thiscall sub_10006940(_DWORD *this)
{
  return this[8];
}

//----- (10006950) --------------------------------------------------------
int __thiscall sub_10006950(_DWORD *this, int a2)
{
  int result; // eax

  result = a2;
  this[8] = a2;
  return result;
}

//----- (10006960) --------------------------------------------------------
int __thiscall sub_10006960(_DWORD *this)
{
  return this[10];
}

//----- (10006970) --------------------------------------------------------
int __thiscall sub_10006970(_DWORD *this, int a2)
{
  int result; // eax

  result = a2;
  this[10] = a2;
  return result;
}

//----- (10006980) --------------------------------------------------------
int __thiscall sub_10006980(_DWORD *this)
{
  return this[22];
}

//----- (10006990) --------------------------------------------------------
int __thiscall sub_10006990(_DWORD *this)
{
  return this[23];
}

//----- (100069A0) --------------------------------------------------------
char *__thiscall sub_100069A0(char *this)
{
  return this + 12;
}

//----- (100069B0) --------------------------------------------------------
int __thiscall sub_100069B0(_DWORD *this)
{
  return this[21];
}

//----- (100069C0) --------------------------------------------------------
int __thiscall sub_100069C0(_DWORD *this, int a2)
{
  int result; // eax

  result = a2;
  this[21] = a2;
  return result;
}

//----- (100069D0) --------------------------------------------------------
int __thiscall sub_100069D0(_DWORD *this)
{
  return this[30];
}

//----- (100069E0) --------------------------------------------------------
int __thiscall sub_100069E0(_DWORD *this)
{
  return this[31];
}

//----- (100069F0) --------------------------------------------------------
int __thiscall sub_100069F0(_DWORD *this)
{
  return this[32];
}

//----- (10006A20) --------------------------------------------------------
_DWORD *__thiscall sub_10006A20(_DWORD *this)
{
  *this = &off_1003CEE8;
  this[9] = 0;
  sub_1000A9B0(this + 22);
  this[1] = 0;
  this[2] = 0;
  this[12] = 0;
  this[11] = 0;
  this[13] = 0;
  this[10] = 0;
  this[15] = 0;
  this[16] = 0;
  this[21] = 0;
  this[315] = 0;
  this[313] = 0;
  this[314] = 0;
  this[3] = 0;
  this[4] = 1;
  this[5] = 4;
  this[6] = 4;
  this[7] = 4;
  this[8] = 4;
  *((_WORD *)this + 28) = 0;
  this[19] = 0;
  this[9] = 0;
  this[17] = -1;
  this[18] = -1;
  this[20] = 0xFFFF;
  return this;
}
// 1003CEE8: using guessed type void *off_1003CEE8;

//----- (10006AD0) --------------------------------------------------------
int __stdcall sub_10006AD0(int a1)
{
  return sub_100031A0(a1);
}

//----- (10006AE0) --------------------------------------------------------
int __thiscall sub_10006AE0(_DWORD *this, int a2)
{
  int result; // eax

  result = a2;
  this[15] = a2;
  return result;
}

//----- (10006AF0) --------------------------------------------------------
int __thiscall sub_10006AF0(_DWORD *this)
{
  return this[15];
}

//----- (10006B00) --------------------------------------------------------
int __thiscall sub_10006B00(unsigned __int16 *this)
{
  return this[28];
}

//----- (10006B10) --------------------------------------------------------
int __thiscall sub_10006B10(_DWORD *this)
{
  return this[20];
}

//----- (10006B20) --------------------------------------------------------
int __thiscall sub_10006B20(void *this)
{
  int v1; // eax

  v1 = (*(int (__thiscall **)(void *))(*(_DWORD *)this + 52))(this);
  return (*(int (__thiscall **)(int))(*(_DWORD *)v1 + 16))(v1);
}

//----- (10006B30) --------------------------------------------------------
int __thiscall sub_10006B30(void *this)
{
  int v1; // eax

  v1 = (*(int (__thiscall **)(void *))(*(_DWORD *)this + 52))(this);
  return (*(int (__thiscall **)(int))(*(_DWORD *)v1 + 20))(v1);
}

//----- (10006B40) --------------------------------------------------------
int __thiscall sub_10006B40(_DWORD *this)
{
  return this[3];
}

//----- (10006B50) --------------------------------------------------------
__int16 sub_10006B50(int a1, char *Format, ...)
{
  char *v2; // eax
  va_list va; // [esp+10h] [ebp+Ch] BYREF

  va_start(va, Format);
  v2 = *(char **)(a1 + 40);
  if ( v2 && *(_DWORD *)(a1 + 44) )
  {
    vsprintf(v2, Format, va);
    if ( sub_10003190() )
      strcat(*(char **)(a1 + 40), sub_10003240());
    LOWORD(v2) = sub_1000C620(*(_DWORD *)(*(_DWORD *)(a1 + 44) + 204), 8, 2, *(char **)(a1 + 40));
  }
  return (__int16)v2;
}

//----- (10006BD0) --------------------------------------------------------
int __stdcall sub_10006BD0(char *a1, int a2)
{
  char v2; // bl
  const char *v3; // ebp
  int result; // eax
  int v5; // [esp+10h] [ebp-4h]

  *a1 = 0;
  v2 = 0;
  v3 = aClassInitializ;
  v5 = 32;
  do
  {
    if ( ((1 << v2) & a2) != 0 )
      strcat(a1, v3);
    ++v2;
    v3 += 40;
    result = --v5;
  }
  while ( v5 );
  return result;
}

//----- (10006C50) --------------------------------------------------------
void __thiscall sub_10006C50(_DWORD *this, unsigned __int16 a2)
{
  char *v2; // eax
  char v3[12]; // [esp+4h] [ebp-Ch] BYREF

  strcpy(v3, "LOG_Enable");
  if ( a2 < 4u )
  {
    if ( a2 )
    {
      this[a2 + 5] |= 4;
      switch ( a2 )
      {
        case 1u:
          *(_DWORD *)(*(_DWORD *)(this[11] + 204) + 16) |= 4u;
          break;
        case 2u:
          *(_DWORD *)(*(_DWORD *)(this[11] + 208) + 16) |= 4u;
          break;
        case 3u:
          *(_DWORD *)(*(_DWORD *)(this[11] + 212) + 16) |= 4u;
          break;
      }
    }
    else
    {
      this[4] = 1;
      sub_1000C190();
      sub_1000C170();
    }
  }
  else
  {
    sub_100031F0(-41);
    v2 = sub_10003240();
    sub_1000C6F0(0, 4, "%s::%s: Neterror: %s", aTinapi, v3, v2);
  }
}

//----- (10006D30) --------------------------------------------------------
void __thiscall sub_10006D30(_DWORD *this, unsigned __int16 a2)
{
  char *v3; // eax
  char v4[12]; // [esp+4h] [ebp-Ch] BYREF

  strcpy(v4, "LOG_Disable");
  if ( a2 < 4u )
  {
    if ( a2 )
    {
      this[a2 + 5] &= ~4u;
      switch ( a2 )
      {
        case 1u:
          *(_DWORD *)(*(_DWORD *)(this[11] + 204) + 16) &= ~4u;
          break;
        case 2u:
          *(_DWORD *)(*(_DWORD *)(this[11] + 208) + 16) &= ~4u;
          break;
        case 3u:
          *(_DWORD *)(*(_DWORD *)(this[11] + 212) + 16) &= ~4u;
          break;
      }
    }
    else
    {
      sub_1000C160();
      sub_1000C180();
      this[4] = 0;
    }
  }
  else
  {
    sub_100031F0(-41);
    v3 = sub_10003240();
    sub_1000C6F0(0, 4, "%s::%s: Neterror: %s", aTinapi, v4, v3);
  }
}

//----- (10006E00) --------------------------------------------------------
char *__thiscall sub_10006E00(_DWORD *this, unsigned __int16 a2, int a3)
{
  const char *v5; // eax
  char *v6; // esi
  char v7[16]; // [esp+8h] [ebp-10h] BYREF

  strcpy(v7, "LOG_GetFilename");
  if ( a2 >= 3u )
  {
    sub_10006B50((int)this, "%s %s: Unknown filename type.", aTinapi, v7);
    return 0;
  }
  if ( a3 )
  {
    v5 = (const char *)(*(int (__thiscall **)(_DWORD *))(*this + 84))(this);
    if ( !v5 )
      v5 = ".";
    v6 = (char *)sub_1000BB40(strlen(v5) + strlen(&aUserlogTxt[32 * a2]) + 8);
    if ( !v6 )
    {
      sub_10006B50((int)this, "%s %s: Cannot allocate filename buffer.", aTinapi, v7);
      return 0;
    }
  }
  else
  {
    v6 = (char *)this[10];
  }
  *v6 = 0;
  if ( (*(int (__thiscall **)(_DWORD *))(*this + 84))(this) )
    strcpy(v6, (const char *)(*(int (__thiscall **)(_DWORD *))(*this + 84))(this));
  else
    *(_WORD *)v6 = 46;
  sub_10024090(v6, &aUserlogTxt[32 * a2]);
  return v6;
}

//----- (10006F30) --------------------------------------------------------
BOOL __thiscall sub_10006F30(_DWORD *this, unsigned int a2, unsigned int a3, int a4)
{
  int v4; // ecx

  v4 = this[13];
  return v4 && sub_10001660(v4, a2, a3, a4) != 0;
}

//----- (10006F60) --------------------------------------------------------
int __thiscall sub_10006F60(_DWORD *this)
{
  int v1; // ecx

  v1 = this[13];
  if ( !v1 )
    return 0;
  sub_10001660(v1, 0, 0, 0);
  return 1;
}

//----- (10006F80) --------------------------------------------------------
int __thiscall sub_10006F80(_DWORD *this)
{
  this[21] = 0;
  return 1;
}

//----- (10006F90) --------------------------------------------------------
BOOL __thiscall sub_10006F90(_DWORD *this, char *Source, int a3)
{
  char Destination[1088]; // [esp+8h] [ebp-440h] BYREF

  memset(Destination, 0, 0x43Cu);
  if ( Source )
    sub_1000E930(Source, Destination, 0x20u);
  *(_DWORD *)&Destination[32] = a3;
  return sub_1000AB50(this + 22, Destination) != 0;
}

//----- (10006FF0) --------------------------------------------------------
BOOL __thiscall sub_10006FF0(_DWORD *this, const void *a2, unsigned int a3)
{
  int v4[272]; // [esp+10h] [ebp-440h] BYREF

  if ( !a2 || a3 > 0x400 )
    return 0;
  memset(v4, 0, 0x43Cu);
  qmemcpy(&v4[15], a2, a3);
  v4[14] = a3;
  return sub_1000ABB0(this + 22, (int)v4) != 0;
}

//----- (10007060) --------------------------------------------------------
int __thiscall sub_10007060(int *this, int a2, _DWORD *a3)
{
  int result; // eax
  int v5; // ecx
  int i; // eax
  int v7; // ebx
  int v8; // esi
  int v9; // edx
  int v10; // eax
  int v11; // esi

  result = 0;
  if ( a3 )
  {
    *a3 = 0;
    a3[1] = 0;
    a3[2] = 0;
    a3[3] = 0;
    if ( a2 == -268435508 )
    {
      if ( sub_1000E090(*(_DWORD *)(this[11] + 132), 0xFFFFFFFF) )
      {
        *a3 = *(_DWORD *)(this[11] + 148);
        a3[1] = *(_DWORD *)(this[11] + 152);
        a3[2] = *(_DWORD *)(this[11] + 156);
        a3[3] = *(_DWORD *)(this[11] + 160);
        sub_1000E0E0(*(_DWORD *)(this[11] + 132));
        return 1;
      }
      else
      {
        return 0;
      }
    }
    else if ( a2 == -268435491 )
    {
      sub_1000E090(**(_DWORD **)(this[11] + 192), 0xFFFFFFFF);
      v5 = *(_DWORD *)(*(_DWORD *)(this[11] + 192) + 4);
      for ( i = *(_DWORD *)(v5 + 12); i != -1; i = *(_DWORD *)(*(_DWORD *)(v5 + 8) + v7 + 4) )
      {
        v7 = 12 * i;
        v8 = *(_DWORD *)(*(_DWORD *)(v5 + 8) + 12 * i + 8);
        if ( v8 )
        {
          if ( !sub_1000E090(**(_DWORD **)(v8 + 8), 0xFFFFFFFF)
            || (v9 = a3[3],
                a3[2] += *(_DWORD *)(*(_DWORD *)(v8 + 8) + 24),
                a3[3] = *(_DWORD *)(*(_DWORD *)(v8 + 8) + 28) + v9,
                sub_1000E0E0(**(_DWORD **)(v8 + 8)),
                !sub_1000E090(**(_DWORD **)(v8 + 12), 0xFFFFFFFF)) )
          {
            sub_1000E0E0(**(_DWORD **)(this[11] + 192));
            return 0;
          }
          *a3 += *(_DWORD *)(*(_DWORD *)(v8 + 12) + 24);
          a3[1] += *(_DWORD *)(*(_DWORD *)(v8 + 12) + 28);
          sub_1000E0E0(**(_DWORD **)(v8 + 12));
        }
        v5 = *(_DWORD *)(*(_DWORD *)(this[11] + 192) + 4);
      }
      sub_1000E0E0(**(_DWORD **)(this[11] + 192));
      return 1;
    }
    else
    {
      v10 = sub_10005EF0(this[11], a2);
      v11 = v10;
      if ( v10
        && sub_1000E090(**(_DWORD **)(v10 + 8), 0xFFFFFFFF)
        && (a3[2] = *(_DWORD *)(*(_DWORD *)(v11 + 8) + 24),
            a3[3] = *(_DWORD *)(*(_DWORD *)(v11 + 8) + 28),
            sub_1000E0E0(**(_DWORD **)(v11 + 8)),
            sub_1000E090(**(_DWORD **)(v11 + 12), 0xFFFFFFFF)) )
      {
        *a3 = *(_DWORD *)(*(_DWORD *)(v11 + 12) + 24);
        a3[1] = *(_DWORD *)(*(_DWORD *)(v11 + 12) + 28);
        sub_1000E0E0(**(_DWORD **)(v11 + 12));
        return 1;
      }
      else
      {
        return 0;
      }
    }
  }
  return result;
}

//----- (100072A0) --------------------------------------------------------
int __thiscall sub_100072A0(void *this, char *name, int a3)
{
  int result; // eax
  char *v5; // [esp-8h] [ebp-2Ch]
  char *v6; // [esp-8h] [ebp-2Ch]
  char *v7; // [esp-8h] [ebp-2Ch]
  int v8; // [esp+4h] [ebp-20h] BYREF
  int v9; // [esp+8h] [ebp-1Ch] BYREF
  int v10; // [esp+Ch] [ebp-18h] BYREF
  char v11[20]; // [esp+10h] [ebp-14h] BYREF

  strcpy(v11, "ConnectToHostname");
  switch ( sub_1000D320(name, &v10, &v9, &v8, &name) )
  {
    case -5:
      sub_100031F0(-37);
      goto LABEL_6;
    case -4:
    case -3:
      sub_100031F0(-36);
      v6 = sub_10003240();
      sub_1000C6F0(0, 4, "%s::%s: Neterror: %s", aTinapi, v11, v6);
      goto LABEL_7;
    case -2:
      sub_100031F0(-36);
LABEL_6:
      v7 = sub_10003240();
      sub_1000C6F0(0, 4, "%s::%s: Neterror: %s", aTinapi, v11, v7);
      goto LABEL_7;
    case -1:
      sub_100031F0(-35);
      v5 = sub_10003240();
      sub_1000C6F0(0, 4, "%s::%s: Neterror: %s", aTinapi, v11, v5);
LABEL_7:
      result = -1;
      break;
    default:
      result = (*(int (__thiscall **)(void *, int, int, int, char *, int))(*(_DWORD *)this + 112))(
                 this,
                 v10,
                 v9,
                 v8,
                 name,
                 a3);
      break;
  }
  return result;
}

//----- (100073C0) --------------------------------------------------------
int __thiscall sub_100073C0(void *this, char *name, int a3)
{
  int result; // eax
  char *v5; // [esp-8h] [ebp-38h]
  char *v6; // [esp-8h] [ebp-38h]
  char *v7; // [esp-8h] [ebp-38h]
  int v8; // [esp+Ch] [ebp-24h] BYREF
  int v9; // [esp+10h] [ebp-20h] BYREF
  int v10; // [esp+14h] [ebp-1Ch] BYREF
  char v11[24]; // [esp+18h] [ebp-18h] BYREF

  strcpy(v11, "ConnectAsyncToHostname");
  switch ( sub_1000D320(name, &v10, &v9, &v8, &name) )
  {
    case -5:
      sub_100031F0(-37);
      goto LABEL_6;
    case -4:
    case -3:
      sub_100031F0(-36);
      v6 = sub_10003240();
      sub_1000C6F0(0, 4, "%s::%s: Neterror: %s", aTinapi, v11, v6);
      goto LABEL_7;
    case -2:
      sub_100031F0(-36);
LABEL_6:
      v7 = sub_10003240();
      sub_1000C6F0(0, 4, "%s::%s: Neterror: %s", aTinapi, v11, v7);
      goto LABEL_7;
    case -1:
      sub_100031F0(-35);
      v5 = sub_10003240();
      sub_1000C6F0(0, 4, "%s::%s: Neterror: %s", aTinapi, v11, v5);
LABEL_7:
      result = -1;
      break;
    default:
      result = (*(int (__thiscall **)(void *, int, int, int, char *, int))(*(_DWORD *)this + 120))(
                 this,
                 v10,
                 v9,
                 v8,
                 name,
                 a3);
      break;
  }
  return result;
}

//----- (100074C0) --------------------------------------------------------
BOOL __thiscall sub_100074C0(int *this, int a2)
{
  return sub_10003980(this[11], a2) != 0;
}

//----- (100074E0) --------------------------------------------------------
int __thiscall sub_100074E0(unsigned __int16 *this, int a2, int a3)
{
  return (*(int (__stdcall **)(int, _DWORD, int))(*(_DWORD *)this + 136))(a2, this[34], a3);
}

//----- (10007500) --------------------------------------------------------
int __thiscall sub_10007500(_DWORD *this, int a2, int a3, int a4)
{
  return (*(int (__thiscall **)(_DWORD *, _DWORD, int, int, int, _DWORD, int))(*this + 148))(
           this,
           this[18],
           -268435508,
           a2,
           a3,
           this[17],
           a4);
}

//----- (10007530) --------------------------------------------------------
int __thiscall sub_10007530(_DWORD *this, int a2, int a3, int a4, int a5)
{
  bool v6; // zf
  int v7; // eax

  v6 = (*(int (__thiscall **)(_DWORD *))(*this + 88))(this) == 1;
  v7 = -268435508;
  if ( !v6 )
    v7 = this[18];
  return (*(int (__thiscall **)(_DWORD *, int, int, int, int, _DWORD, int))(*this + 148))(
           this,
           v7,
           a2,
           a3,
           a4,
           this[17],
           a5);
}

//----- (10007570) --------------------------------------------------------
_DWORD *__thiscall sub_10007570(_DWORD *this, int a2, int a3, int a4, int a5, __int16 a6, int a7, DWORD a8)
{
  int v9; // edi
  int v10; // edx
  _DWORD *result; // eax
  _DWORD *v12; // edi
  int v13; // eax
  int v14; // [esp-4h] [ebp-14h]
  int v15; // [esp+1Ch] [ebp+Ch]
  DWORD TickCount; // [esp+20h] [ebp+10h]

  v9 = -268435508;
  if ( (*(int (__thiscall **)(_DWORD *))(*this + 88))(this) != 1 )
    v9 = this[18];
  if ( this[313] )
  {
    j__free((void *)this[313]);
    this[313] = 0;
  }
  v10 = *this;
  v14 = this[17];
  this[314] = 0;
  if ( (*(int (__thiscall **)(_DWORD *, int, int, int, int, int, int))(v10 + 148))(this, v9, a2, a3, a4, v14, a5) )
  {
    v12 = this + 312;
    this[315] = 1;
    this[312] = 1;
    *((_WORD *)this + 632) = a6;
    TickCount = GetTickCount();
    v15 = (*(int (__thiscall **)(_DWORD *))(*this + 40))(this);
    (*(void (__thiscall **)(_DWORD *, int))(*this + 44))(this, 1);
    if ( this[312] == 1 )
    {
      do
      {
        if ( a8 && GetTickCount() - TickCount > a8 )
          *v12 = 5;
        (*(void (__thiscall **)(_DWORD *))(*this + 36))(this);
        if ( !a7 && *v12 == 3 )
          *v12 = 1;
        sub_1000DDA0(1u);
      }
      while ( *v12 == 1 );
    }
    v13 = *this;
    this[315] = 0;
    (*(void (__thiscall **)(_DWORD *, int))(v13 + 44))(this, v15);
    return this + 312;
  }
  else
  {
    result = this + 312;
    this[312] = 1;
  }
  return result;
}

//----- (10007690) --------------------------------------------------------
int TinCat_GetBuildNumber()
{
  return dword_10048A24;
}
// 10048A24: using guessed type int dword_10048A24;

//----- (100076A0) --------------------------------------------------------
int sub_100076A0()
{
  return 2000;
}

//----- (100076B0) --------------------------------------------------------
int __cdecl sub_100076B0(unsigned int ArgList)
{
  char *v2; // eax
  char v3[20]; // [esp+0h] [ebp-14h] BYREF

  strcpy(v3, "TinCat_Port_Check");
  if ( ArgList && ArgList <= 0xFFFF )
    return 1;
  sub_10003210(-34, "port: %lu", ArgList);
  v2 = sub_10003240();
  sub_1000C6F0(0, 4, "%s::%s: Neterror: %s", aTinapi, v3, v2);
  return 0;
}

//----- (10007740) --------------------------------------------------------
_DWORD *TinCat_CreateAPI()
{
  _DWORD *v0; // eax
  _DWORD *result; // eax

  v0 = operator new(0x4F4u);
  if ( !v0 )
    return 0;
  result = sub_10006A20(v0);
  if ( !result )
    return 0;
  return result;
}

//----- (10007760) --------------------------------------------------------
int __cdecl TinCat_Scramble(int a1, unsigned int a2, const char *a3, int a4)
{
  unsigned int v4; // edi
  unsigned int v6; // ecx
  char v7; // al
  char v9; // bl
  char v10; // [esp+Fh] [ebp-1h]
  char v11; // [esp+14h] [ebp+4h]

  v10 = 63;
  v4 = strlen(a3);
  if ( !a1 || !a3 )
    return 0;
  v6 = 0;
  if ( !a4 )
  {
    if ( a2 )
    {
      do
      {
        v11 = *(_BYTE *)(v6 + a1);
        v9 = v10 + v6 + v11;
        *(_BYTE *)(v6 + a1) = v9;
        *(_BYTE *)(v6 + a1) = v9 ^ a3[v6 % v4];
        ++v6;
        v10 = v11;
      }
      while ( v6 < a2 );
    }
    return 1;
  }
  if ( !a2 )
    return 1;
  do
  {
    v7 = (*(_BYTE *)(v6 + a1) ^ a3[v6 % v4]) - v6 - v10;
    *(_BYTE *)(v6 + a1) = v7;
    ++v6;
    v10 = v7;
  }
  while ( v6 < a2 );
  return 1;
}

//----- (10007830) --------------------------------------------------------
int __thiscall sub_10007830(void *this)
{
  void *v2; // eax
  void (__thiscall ***v3)(_DWORD, int); // ecx
  int result; // eax

  v2 = (void *)*((_DWORD *)this + 3);
  *(_DWORD *)this = &off_1003CEE8;
  if ( v2 )
  {
    sub_1000BBF0(v2);
    *((_DWORD *)this + 3) = 0;
  }
  v3 = (void (__thiscall ***)(_DWORD, int))*((_DWORD *)this + 16);
  if ( v3 )
  {
    (**v3)(v3, 1);
    *((_DWORD *)this + 16) = 0;
  }
  if ( *((_DWORD *)this + 313) )
  {
    j__free(*((void **)this + 313));
    *((_DWORD *)this + 313) = 0;
  }
  result = sub_1000A9F0((int)this + 88);
  *(_DWORD *)this = &off_1003CD58;
  return result;
}
// 1003CD58: using guessed type void *off_1003CD58;
// 1003CEE8: using guessed type void *off_1003CEE8;

//----- (100078A0) --------------------------------------------------------
int __thiscall sub_100078A0(void *this, int a2, int a3, unsigned int ArgList, int a5, int a6)
{
  _DWORD *v7; // eax
  _DWORD *v8; // eax
  void *v9; // eax
  int result; // eax
  void (__thiscall ***v11)(_DWORD, int); // ecx
  _DWORD *v12; // eax
  _DWORD *v13; // eax
  char *v14; // eax
  void *v15; // eax
  int v16; // eax
  char *v17; // eax
  char *v18; // [esp+4h] [ebp-20h]
  char *v19; // [esp+4h] [ebp-20h]
  char v20[16]; // [esp+14h] [ebp-10h] BYREF

  strcpy(v20, "TinCatAPI_Init");
  *((_WORD *)this + 28) = a2;
  if ( !sub_10003280() )
    return 0;
  if ( a6 )
  {
    v7 = operator new(0xCu);
    if ( v7 )
      v8 = sub_1000AEF0(v7);
    else
      v8 = 0;
    *((_DWORD *)this + 2) = v8;
    if ( !v8 || !sub_1000AF10(v8, *((_DWORD *)this + 4), *((LPCSTR *)this + 3)) )
    {
      sub_100031F0(-2);
      v18 = sub_10003240();
      sub_1000C6F0(0, 4, "%s::%s: Neterror: %s", aTinapi, v20, v18);
      return 0;
    }
    sub_1000C620(0, 4, 8, "TinCat: PHASE library ready.");
  }
  v9 = sub_1000BB40(4096);
  *((_DWORD *)this + 10) = v9;
  if ( !v9 )
  {
    sub_100031F0(-3);
    v19 = sub_10003240();
    sub_1000C6F0(0, 4, "%s::%s: Neterror: %s", aTinapi, v20, v19);
    return 0;
  }
  sub_1000C720("%s", aInstanceFourI4);
  sub_1000C720("%s", aCCopyright1996);
  sub_1000C720(
    "%s. Version %u.%u.%u",
    a04Mar2004Tinca,
    (unsigned __int16)word_10048A20,
    *(unsigned __int16 *)&Buffer[1024],
    dword_10048A24);
  sub_1000C720("%s", aIdTinapiCppV17);
  if ( *((_DWORD *)this + 4) )
    sub_1000C720("TinCat: Logging enabled.");
  else
    sub_1000C720("TinCat: Logging DISABLED !");
  if ( *((_DWORD *)this + 3) )
    sub_1000C720("TinCat: Logging directory: '%s'.", *((const char **)this + 3));
  else
    sub_1000C720("TinCat: Logging directory set to default path.");
  *((_DWORD *)this + 17) = a3;
  if ( !sub_100076B0(ArgList) )
    goto LABEL_27;
  v11 = (void (__thiscall ***)(_DWORD, int))*((_DWORD *)this + 16);
  if ( v11 )
  {
    (**v11)(v11, 1);
    *((_DWORD *)this + 16) = 0;
  }
  v12 = operator new(0x84u);
  if ( v12 )
    v13 = sub_10006880(v12);
  else
    v13 = 0;
  *((_DWORD *)this + 16) = v13;
  if ( !v13 )
  {
    sub_100031F0(-4);
    v14 = sub_10003240();
    sub_1000C6F0(0, 4, "%s::%s: Neterror: %s", aTinapi, v20, v14);
LABEL_27:
    (*(void (__thiscall **)(void *))(*(_DWORD *)this + 12))(this);
    return 0;
  }
  if ( (*(int (__thiscall **)(_DWORD *, int, int, int, unsigned int))(*v13 + 8))(v13, a5, a2, a3, ArgList) )
  {
    if ( (*(int (__thiscall **)(void *))(*(_DWORD *)this + 52))(this) )
    {
      sub_1000C720("TinCat: Registered VALUES.");
    }
    else
    {
      (*(void (__thiscall **)(void *, _DWORD))(*(_DWORD *)this + 48))(this, *((_DWORD *)this + 16));
      sub_1000C720("TinCat: Default VALUES.");
    }
    v15 = operator new(0x58u);
    if ( v15 )
      v16 = sub_10006810((int)v15);
    else
      v16 = 0;
    *((_DWORD *)this + 13) = v16;
    if ( v16 )
    {
      sub_1000C720("TinCat: System initalized.");
      result = 1;
      *((_DWORD *)this + 9) |= 1u;
    }
    else
    {
      sub_100031F0(-5);
      v17 = sub_10003240();
      sub_1000C6F0(0, 4, "%s::%s: Neterror: %s", aTinapi, v20, v17);
      (*(void (__thiscall **)(void *))(*(_DWORD *)this + 12))(this);
      return 0;
    }
  }
  else
  {
    sub_1000C7C0("%s %s", aTinapi, v20);
    (*(void (__thiscall **)(void *))(*(_DWORD *)this + 12))(this);
    return 0;
  }
  return result;
}
// 10048A20: using guessed type __int16 word_10048A20;
// 10048A24: using guessed type int dword_10048A24;
// 100078A0: using guessed type unsigned int ArgList;

//----- (10007BC0) --------------------------------------------------------
void __thiscall sub_10007BC0(int this)
{
  _DWORD *v2; // edi
  int v3; // ecx
  void (__thiscall ***v4)(_DWORD, int); // ecx
  Concurrency::details::_RefCounter *v5; // ecx

  sub_1000C620(0, 4, 8, "TinCat: Removing...");
  *(_DWORD *)(this + 36) &= ~1u;
  v2 = *(_DWORD **)(this + 52);
  if ( v2 )
  {
    v3 = *(_DWORD *)(this + 52);
    *v2 = &off_1003CCB8;
    sub_10001070(v3);
    sub_10021FE0(v2 + 10);
    j__free(v2);
    *(_DWORD *)(this + 52) = 0;
  }
  v4 = *(void (__thiscall ****)(_DWORD, int))(this + 64);
  if ( v4 )
  {
    (**v4)(v4, 1);
    *(_DWORD *)(this + 64) = 0;
  }
  if ( *(_DWORD *)(this + 40) )
  {
    sub_1000BBF0(*(void **)(this + 40));
    *(_DWORD *)(this + 40) = 0;
  }
  sub_10003170();
  sub_1000C620(0, 4, 8, "TinCat: Removed.");
  v5 = *(Concurrency::details::_RefCounter **)(this + 8);
  if ( v5 )
  {
    Concurrency::details::_RefCounter::_Destroy(v5);
    *(_DWORD *)(this + 8) = 0;
  }
}
// 1003CCB8: using guessed type int (__stdcall *off_1003CCB8)(void *Block, __int16, int, int);

//----- (10007C60) --------------------------------------------------------
int __thiscall sub_10007C60(int *this, int a2, int a3)
{
  char ArgList[1293]; // [esp+8h] [ebp-A20h] BYREF
  __int16 v5; // [esp+515h] [ebp-513h]
  char v6; // [esp+517h] [ebp-511h]
  char v7[1293]; // [esp+518h] [ebp-510h] BYREF
  __int16 v8; // [esp+A25h] [ebp-3h]
  char v9; // [esp+A27h] [ebp-1h]

  memset(ArgList, 0, sizeof(ArgList));
  v5 = 0;
  v6 = 0;
  memset(v7, 0, sizeof(v7));
  v8 = 0;
  v9 = 0;
  if ( (a2 & this[9]) == a2 )
    return 1;
  if ( a3 )
  {
    sub_10006BD0(ArgList, this[9]);
    sub_10006BD0(v7, a2);
    sub_1000C720("STATE mismatch: System is in state   : <%s> ", ArgList);
    sub_1000C720("                State needed for call: <%s>.", v7);
  }
  return 0;
}

//----- (10007D10) --------------------------------------------------------
__int16 __thiscall sub_10007D10(int this)
{
  int v2; // eax

  v2 = *(_DWORD *)(this + 36) & 0xB;
  if ( (_BYTE)v2 == 11 )
  {
    (*(void (__thiscall **)(_DWORD))(**(_DWORD **)(this + 52) + 8))(*(_DWORD *)(this + 52));
    v2 = *(_DWORD *)(this + 84);
    if ( v2 )
    {
      LOWORD(v2) = *(_WORD *)(this + 56);
      if ( (_WORD)v2 == 1 )
      {
        LOWORD(v2) = sub_1000ABE0(this + 88);
      }
      else if ( (_WORD)v2 == 2 )
      {
        LOWORD(v2) = sub_1000AC60(this + 88);
      }
    }
  }
  return v2;
}

//----- (10007D50) --------------------------------------------------------
__int16 __thiscall sub_10007D50(int *this, __int16 a2)
{
  char *v3; // eax
  char v5[28]; // [esp+Ch] [ebp-1Ch] BYREF

  strcpy(v5, "Mode_UserMaxHandling_Set");
  if ( sub_10007C60(this, 11, 1) )
    return sub_10001C40(this[11], 0xFFFFFFFF, a2);
  sub_100031F0(-18);
  v3 = sub_10003240();
  return sub_1000C6F0(0, 4, "%s::%s: Neterror: %s", aTinapi, v5, v3);
}

//----- (10007DD0) --------------------------------------------------------
__int16 __thiscall sub_10007DD0(int *this)
{
  char *v2; // eax
  char v4[28]; // [esp+Ch] [ebp-1Ch] BYREF

  strcpy(v4, "Mode_UserMaxHandling_Get");
  if ( sub_10007C60(this, 11, 1) )
    return *(_WORD *)(this[11] + 140);
  sub_100031F0(-18);
  v2 = sub_10003240();
  sub_1000C6F0(0, 4, "%s::%s: Neterror: %s", aTinapi, v4, v2);
  return 0;
}

//----- (10007E40) --------------------------------------------------------
int __thiscall sub_10007E40(int *this)
{
  char *v2; // eax
  char v4[32]; // [esp+Ch] [ebp-20h] BYREF

  strcpy(v4, "TinCatAPI_MessagePollCount_Get");
  if ( sub_10007C60(this, 1, 1) )
    return *(_DWORD *)(this[13] + 32);
  sub_100031F0(-18);
  v2 = sub_10003240();
  sub_1000C6F0(0, 4, "%s::%s: Neterror: %s", aTinapi, v4, v2);
  return -1;
}

//----- (10007EB0) --------------------------------------------------------
__int16 __thiscall sub_10007EB0(int *this, int a2)
{
  int v3; // eax
  char *v4; // eax
  char v6[32]; // [esp+Ch] [ebp-20h] BYREF

  strcpy(v6, "TinCatAPI_MessagePollCount_Set");
  v3 = sub_10007C60(this, 1, 1);
  if ( v3 )
  {
    *(_DWORD *)(this[13] + 32) = a2;
  }
  else
  {
    sub_100031F0(-18);
    v4 = sub_10003240();
    LOWORD(v3) = sub_1000C6F0(0, 4, "%s::%s: Neterror: %s", aTinapi, v6, v4);
  }
  return v3;
}

//----- (10007F20) --------------------------------------------------------
int __thiscall sub_10007F20(void **this, const char *a2)
{
  int result; // eax

  if ( this[3] )
  {
    sub_1000BBF0(this[3]);
    this[3] = 0;
  }
  result = (int)sub_1000BB40(strlen(a2) + 8);
  this[3] = (void *)result;
  if ( result )
  {
    strcpy((char *)result, a2);
    return 1;
  }
  return result;
}

//----- (10007F90) --------------------------------------------------------
BOOL __thiscall sub_10007F90(int *this)
{
  char *v2; // eax
  char v4[24]; // [esp+4h] [ebp-18h] BYREF

  strcpy(v4, "BCast_Client_UpdateList");
  if ( !sub_10007C60(this, 11, 1) )
  {
    sub_100031F0(-18);
    v2 = sub_10003240();
    sub_1000C6F0(0, 4, "%s::%s: Neterror: %s", aTinapi, v4, v2);
    return 0;
  }
  if ( !this[21] )
    return 0;
  return sub_1000AEB0(this + 22) != 0;
}

//----- (10008030) --------------------------------------------------------
__int16 __thiscall sub_10008030(int this, int a2)
{
  char *v3; // eax
  char v5[20]; // [esp+4h] [ebp-14h] BYREF

  strcpy(v5, "ConnectionFailed");
  if ( sub_10007C60((int *)this, 3, 1) )
    return (*(int (__thiscall **)(_DWORD, int))(**(_DWORD **)(this + 48) + 8))(*(_DWORD *)(this + 48), a2);
  sub_100031F0(-18);
  v3 = sub_10003240();
  return sub_1000C6F0(0, 4, "%s::%s: Neterror: %s", aTinapi, v5, v3);
}

//----- (100080C0) --------------------------------------------------------
__int16 __thiscall sub_100080C0(int this, int a2)
{
  char *v3; // eax
  char v5[24]; // [esp+4h] [ebp-18h] BYREF

  strcpy(v5, "ConnectionEstablished");
  if ( sub_10007C60((int *)this, 3, 1) )
    return (*(int (__thiscall **)(_DWORD, int))(**(_DWORD **)(this + 48) + 4))(*(_DWORD *)(this + 48), a2);
  sub_100031F0(-18);
  v3 = sub_10003240();
  return sub_1000C6F0(0, 4, "%s::%s: Neterror: %s", aTinapi, v5, v3);
}

//----- (10008160) --------------------------------------------------------
__int16 __thiscall sub_10008160(int *this, int a2)
{
  char *v3; // eax
  __int16 result; // ax
  char v5[16]; // [esp+4h] [ebp-10h] BYREF

  strcpy(v5, "User_LoggedIN");
  if ( sub_10007C60(this, 3, 1) )
  {
    if ( (*(int (__thiscall **)(int *))(*this + 88))(this) == 2 )
      this[18] = a2;
    this[9] |= 4u;
    ++this[19];
    result = (*(int (__thiscall **)(int, int))(*(_DWORD *)this[12] + 12))(this[12], a2);
    if ( this[315] == 1 )
      this[312] = 4;
  }
  else
  {
    sub_100031F0(-18);
    v3 = sub_10003240();
    return sub_1000C6F0(0, 4, "%s::%s: Neterror: %s", aTinapi, v5, v3);
  }
  return result;
}

//----- (10008210) --------------------------------------------------------
__int16 __thiscall sub_10008210(int this, int a2)
{
  char *v3; // eax
  __int16 result; // ax
  char v5[16]; // [esp+4h] [ebp-10h] BYREF

  strcpy(v5, "User_LoggedOUT");
  if ( sub_10007C60((int *)this, 3, 1) )
  {
    result = (*(int (__thiscall **)(_DWORD, int))(**(_DWORD **)(this + 48) + 16))(*(_DWORD *)(this + 48), a2);
    if ( *(_DWORD *)(this + 1260) == 1 )
      *(_DWORD *)(this + 1248) = 2;
  }
  else
  {
    sub_100031F0(-18);
    v3 = sub_10003240();
    return sub_1000C6F0(0, 4, "%s::%s: Neterror: %s", aTinapi, v5, v3);
  }
  return result;
}

//----- (100082B0) --------------------------------------------------------
__int16 __thiscall sub_100082B0(int this, int a2)
{
  char *v3; // eax
  __int16 result; // ax
  char v5[16]; // [esp+4h] [ebp-10h] BYREF

  strcpy(v5, "ConnectionLost");
  if ( sub_10007C60((int *)this, 3, 1) )
  {
    result = (*(int (__thiscall **)(_DWORD, int))(**(_DWORD **)(this + 48) + 20))(*(_DWORD *)(this + 48), a2);
    if ( *(_DWORD *)(this + 1260) == 1 )
      *(_DWORD *)(this + 1248) = 2;
  }
  else
  {
    sub_100031F0(-18);
    v3 = sub_10003240();
    return sub_1000C6F0(0, 4, "%s::%s: Neterror: %s", aTinapi, v5, v3);
  }
  return result;
}

//----- (10008350) --------------------------------------------------------
__int16 __thiscall sub_10008350(int *this, int a2)
{
  char *v3; // eax
  __int16 result; // ax
  int v5; // eax
  char v6[20]; // [esp+4h] [ebp-14h] BYREF

  strcpy(v6, "ConnectionClosed");
  if ( sub_10007C60(this, 3, 1) )
  {
    if ( (*(int (__thiscall **)(int *))(*this + 88))(this) == 2 )
      this[18] = -1;
    v5 = this[19];
    this[19] = v5 - 1;
    if ( !v5 )
    {
      this[9] &= ~4u;
      this[20] = 0xFFFF;
    }
    (*(void (__thiscall **)(int, int))(*(_DWORD *)this[12] + 24))(this[12], a2);
    result = (*(int (__thiscall **)(int *, int))(*this + 208))(this, a2);
    if ( this[315] == 1 )
      this[312] = 2;
  }
  else
  {
    sub_100031F0(-18);
    v3 = sub_10003240();
    return sub_1000C6F0(0, 4, "%s::%s: Neterror: %s", aTinapi, v6, v3);
  }
  return result;
}

//----- (10008430) --------------------------------------------------------
__int16 __thiscall sub_10008430(int this, int a2, int a3, int a4)
{
  char *v5; // eax
  __int16 result; // ax
  char v7[16]; // [esp+4h] [ebp-10h] BYREF

  strcpy(v7, "Received_File");
  if ( sub_10007C60((int *)this, 15, 1) )
  {
    result = (*(int (__thiscall **)(_DWORD, int, int, int))(**(_DWORD **)(this + 48) + 32))(
               *(_DWORD *)(this + 48),
               a2,
               a3,
               a4);
    if ( *(_DWORD *)(this + 1260) == 1 )
      *(_DWORD *)(this + 1248) = 4;
  }
  else
  {
    sub_100031F0(-18);
    v5 = sub_10003240();
    return sub_1000C6F0(0, 4, "%s::%s: Neterror: %s", aTinapi, v7, v5);
  }
  return result;
}

//----- (100084D0) --------------------------------------------------------
__int16 __thiscall sub_100084D0(int *this, int a2, int a3, int a4)
{
  int v4; // eax
  char *v5; // eax
  char v7[20]; // [esp+0h] [ebp-14h] BYREF

  strcpy(v7, "Received_FileERROR");
  v4 = sub_10007C60(this, 15, 1);
  if ( !v4 )
  {
    sub_100031F0(-18);
    v5 = sub_10003240();
    LOWORD(v4) = sub_1000C6F0(0, 4, "%s::%s: Neterror: %s", aTinapi, v7, v5);
  }
  return v4;
}

//----- (10008550) --------------------------------------------------------
__int16 __thiscall sub_10008550(int *this, int a2, int a3, int a4, int a5, int a6)
{
  int v6; // eax
  char *v7; // eax
  char v9[20]; // [esp+0h] [ebp-14h] BYREF

  strcpy(v9, "Received_GroupData");
  v6 = sub_10007C60(this, 15, 1);
  if ( !v6 )
  {
    sub_100031F0(-18);
    v7 = sub_10003240();
    LOWORD(v6) = sub_1000C6F0(0, 4, "%s::%s: Neterror: %s", aTinapi, v9, v7);
  }
  return v6;
}

//----- (100085D0) --------------------------------------------------------
__int16 __thiscall sub_100085D0(int *this, int a2, int a3, signed int ArgList)
{
  signed int v4; // esi
  __int16 result; // ax
  char *v7; // eax
  DWORD TickCount; // eax
  _WORD *v9; // esi
  char *v10; // eax
  char *v11; // eax
  char v12[16]; // [esp+8h] [ebp-10h] BYREF

  v4 = ArgList;
  strcpy(v12, "Received_Ping");
  result = 103;
  if ( ArgList )
  {
    if ( sub_10007C60(this, 15, 1) )
    {
      result = *(_WORD *)(v4 + 2);
      if ( result )
      {
        if ( result == 1 )
        {
          TickCount = GetTickCount();
          result = (*(int (__thiscall **)(int, _DWORD, DWORD))(*(_DWORD *)this[12] + 52))(
                     this[12],
                     *(_DWORD *)(v4 + 4),
                     TickCount - *(_DWORD *)(v4 + 8));
          if ( this[315] == 1 )
            this[312] = 4;
        }
      }
      else
      {
        *(_WORD *)(v4 + 2) = 1;
        if ( (*(int (__thiscall **)(int *))(*this + 88))(this) == 1 )
          *(_DWORD *)(v4 + 4) = -268435508;
        else
          *(_DWORD *)(v4 + 4) = this[18];
        v9 = sub_10006750((char *)v4, 12, &ArgList, 99, 23177);
        if ( v9 )
        {
          if ( sub_10003C10(this[11], a2, a3, 1, 2, v9, ArgList) )
          {
            sub_10003210(-27, "pingmsg size: %lu", ArgList);
            v11 = sub_10003240();
            sub_1000C6F0(0, 4, "%s::%s: Neterror: %s", aTinapi, v12, v11);
            return sub_1000BBF0(v9);
          }
          else
          {
            return sub_1000BBF0(v9);
          }
        }
        else
        {
          sub_10003210(-26, "pingmsg size: %lu", 12);
          v10 = sub_10003240();
          return sub_1000C6F0(0, 4, "%s::%s: Neterror: %s", aTinapi, v12, v10);
        }
      }
    }
    else
    {
      sub_100031F0(-18);
      v7 = sub_10003240();
      return sub_1000C6F0(0, 4, "%s::%s: Neterror: %s", aTinapi, v12, v7);
    }
  }
  return result;
}

//----- (10008780) --------------------------------------------------------
__int16 __thiscall sub_10008780(int this, int a2)
{
  char *v3; // eax
  __int16 result; // ax
  char v5[24]; // [esp+4h] [ebp-18h] BYREF

  strcpy(v5, "Broadcast_ServerAdded");
  if ( sub_10007C60((int *)this, 3, 1) )
  {
    result = (*(int (__thiscall **)(_DWORD, int))(**(_DWORD **)(this + 48) + 40))(*(_DWORD *)(this + 48), a2);
    if ( *(_DWORD *)(this + 1260) == 1 )
      *(_DWORD *)(this + 1248) = 4;
  }
  else
  {
    sub_100031F0(-18);
    v3 = sub_10003240();
    return sub_1000C6F0(0, 4, "%s::%s: Neterror: %s", aTinapi, v5, v3);
  }
  return result;
}

//----- (10008830) --------------------------------------------------------
__int16 __thiscall sub_10008830(int this, int a2)
{
  char *v3; // eax
  __int16 result; // ax
  char v5[24]; // [esp+4h] [ebp-18h] BYREF

  strcpy(v5, "Broadcast_ServerRemoved");
  if ( sub_10007C60((int *)this, 3, 1) )
  {
    result = (*(int (__thiscall **)(_DWORD, int))(**(_DWORD **)(this + 48) + 44))(*(_DWORD *)(this + 48), a2);
    if ( *(_DWORD *)(this + 1260) == 1 )
      *(_DWORD *)(this + 1248) = 4;
  }
  else
  {
    sub_100031F0(-18);
    v3 = sub_10003240();
    return sub_1000C6F0(0, 4, "%s::%s: Neterror: %s", aTinapi, v5, v3);
  }
  return result;
}

//----- (100088E0) --------------------------------------------------------
__int16 __thiscall sub_100088E0(int this)
{
  char *v2; // eax
  __int16 result; // ax
  char v4[24]; // [esp+4h] [ebp-18h] BYREF

  strcpy(v4, "Broadcast_ListUpdated");
  if ( sub_10007C60((int *)this, 3, 1) )
  {
    result = (*(int (__thiscall **)(_DWORD))(**(_DWORD **)(this + 48) + 48))(*(_DWORD *)(this + 48));
    if ( *(_DWORD *)(this + 1260) == 1 )
      *(_DWORD *)(this + 1248) = 4;
  }
  else
  {
    sub_100031F0(-18);
    v2 = sub_10003240();
    return sub_1000C6F0(0, 4, "%s::%s: Neterror: %s", aTinapi, v4, v2);
  }
  return result;
}

//----- (10008980) --------------------------------------------------------
int __thiscall sub_10008980(int *this, char a2, char a3, char a4, char a5, int ArgList)
{
  int v8; // ebp
  int v9; // eax
  int *v10; // ebx
  int v11; // eax
  int v12; // eax
  unsigned int v13; // edi
  int v14; // eax
  DWORD v15; // eax
  char *v16; // eax
  char *v17; // [esp-8h] [ebp-28h]
  char *v18; // [esp-8h] [ebp-28h]
  char v19[12]; // [esp+4h] [ebp-1Ch] BYREF
  int v20[4]; // [esp+10h] [ebp-10h] BYREF

  strcpy(v19, "ConnectToIP");
  sub_10021EE0(v20);
  if ( (*(int (__thiscall **)(int *))(*this + 88))(this) == 1 )
  {
    sub_100031F0(-29);
    v17 = sub_10003240();
    sub_1000C6F0(0, 4, "%s::%s: Neterror: %s", aTinapi, v19, v17);
    return -1;
  }
  if ( !sub_10007C60(this, 11, 1) )
  {
    sub_100031F0(-18);
    v18 = sub_10003240();
    sub_1000C6F0(0, 4, "%s::%s: Neterror: %s", aTinapi, v19, v18);
    return -1;
  }
  v8 = ArgList;
  if ( ArgList == 0xFFFF )
    v8 = (*(int (__thiscall **)(int *))(*this + 104))(this);
  if ( !sub_100076B0(v8) )
    return -1;
  v9 = (*(int (__thiscall **)(int *))(*this + 52))(this);
  *(_DWORD *)(this[11] + 184) = (*(int (__thiscall **)(int))(*(_DWORD *)v9 + 100))(v9);
  v10 = sub_10004380(this[11], aUser, aPassword, v8, a2, a3, a4, a5);
  if ( !v10 )
    return -1;
  v11 = (*(int (__thiscall **)(int *))(*this + 52))(this);
  v12 = (*(int (__thiscall **)(int))(*(_DWORD *)v11 + 124))(v11);
  sub_10021F00(v20, v12);
  v13 = this[19];
  do
  {
    if ( (unsigned __int8)sub_10021F20(v20) )
      break;
    (*(void (__thiscall **)(int *))(*this + 36))(this);
    v14 = (*(int (__thiscall **)(int *))(*this + 52))(this);
    v15 = (*(int (__thiscall **)(int))(*(_DWORD *)v14 + 128))(v14);
    sub_1000DDA0(v15);
  }
  while ( this[19] <= v13 );
  if ( this[19] <= v13 )
  {
    sub_100031F0(-23);
    v16 = sub_10003240();
    sub_1000C6F0(0, 4, "%s::%s: Neterror: %s", aTinapi, v19, v16);
    return -1;
  }
  this[20] = v8;
  return *(_DWORD *)v10[6];
}
// 10008980: using guessed type int var_10[4];

//----- (10008B20) --------------------------------------------------------
int __thiscall sub_10008B20(int *this, char a2, char a3, char a4, char a5, int ArgList)
{
  int v8; // edi
  int v9; // eax
  void *v10; // eax
  char *v11; // [esp-8h] [ebp-18h]
  char *v12; // [esp-8h] [ebp-18h]
  char v13[12]; // [esp+4h] [ebp-Ch] BYREF

  strcpy(v13, "ConnectToIP");
  if ( (*(int (__thiscall **)(int *))(*this + 88))(this) == 1 )
  {
    sub_100031F0(-29);
    v11 = sub_10003240();
    sub_1000C6F0(0, 4, "%s::%s: Neterror: %s", aTinapi, v13, v11);
    return -1;
  }
  if ( !sub_10007C60(this, 11, 1) )
  {
    sub_100031F0(-18);
    v12 = sub_10003240();
    sub_1000C6F0(0, 4, "%s::%s: Neterror: %s", aTinapi, v13, v12);
    return -1;
  }
  v8 = ArgList;
  if ( ArgList == 0xFFFF )
    v8 = (*(int (__thiscall **)(int *))(*this + 104))(this);
  if ( sub_100076B0(v8)
    && (v9 = (*(int (__thiscall **)(int *))(*this + 52))(this),
        *(_DWORD *)(this[11] + 184) = (*(int (__thiscall **)(int))(*(_DWORD *)v9 + 100))(v9),
        (v10 = sub_10004650(this[11], aUser, aPassword, v8, a2, a3, a4, a5)) != 0) )
  {
    return *(_DWORD *)v10;
  }
  else
  {
    return -1;
  }
}

//----- (10008C30) --------------------------------------------------------
int __thiscall sub_10008C30(int *this, int a2)
{
  char *v3; // eax
  char v5[12]; // [esp+4h] [ebp-Ch] BYREF

  strcpy(v5, "Disconnect");
  if ( sub_10007C60(this, 15, 1) )
    return (*(int (__thiscall **)(int *, int))(*this + 176))(this, a2);
  sub_100031F0(-18);
  v3 = sub_10003240();
  sub_1000C6F0(0, 4, "%s::%s: Neterror: %s", aTinapi, v5, v3);
  return 0;
}

//----- (10008CC0) --------------------------------------------------------
int __thiscall sub_10008CC0(int *this, int a2, unsigned __int16 a3, unsigned __int16 a4)
{
  _WORD *v6; // esi
  char *v7; // eax
  bool v8; // zf
  int v9; // eax
  char *v10; // eax
  char *v11; // [esp-8h] [ebp-1Ch]
  char *v12; // [esp-8h] [ebp-1Ch]
  signed int v13; // [esp+4h] [ebp-10h] BYREF
  char v14[12]; // [esp+8h] [ebp-Ch] BYREF

  strcpy(v14, "Send_Notify");
  if ( !sub_10007C60(this, 15, 1) )
  {
    sub_100031F0(-18);
    v11 = sub_10003240();
    sub_1000C6F0(0, 4, "%s::%s: Neterror: %s", aTinapi, v14, v11);
    return 0;
  }
  if ( !a2 )
  {
    sub_100031F0(-30);
    v12 = sub_10003240();
    sub_1000C6F0(0, 4, "%s::%s: Neterror: %s", aTinapi, v14, v12);
    return 0;
  }
  v6 = sub_100067E0(&v13, a3, a4);
  if ( v6 )
  {
    v8 = (*(int (__thiscall **)(int *))(*this + 88))(this) == 1;
    v9 = -268435508;
    if ( !v8 )
      v9 = this[18];
    if ( sub_10003C10(this[11], v9, a2, 1, 2, v6, v13) )
    {
      sub_10003210(-27, "module id: %lu msgtype id: %lu", a3, a4);
      v10 = sub_10003240();
      sub_1000C6F0(0, 4, "%s::%s: Neterror: %s", aTinapi, v14, v10);
      sub_1000BBF0(v6);
      return 0;
    }
    else
    {
      sub_1000BBF0(v6);
      return 1;
    }
  }
  else
  {
    sub_10003210(-26, "module id: %lu msgtype id: %lu", a3, a4);
    v7 = sub_10003240();
    sub_1000C6F0(0, 4, "%s::%s: Neterror: %s", aTinapi, v14, v7);
    return 0;
  }
}

//----- (10008E40) --------------------------------------------------------
int __thiscall sub_10008E40(int *this, int a2, int a3, char *a4, int ArgList, int a6, int a7)
{
  char *v7; // eax
  _WORD *v9; // esi
  char *v10; // eax
  int v11; // eax
  char *v12; // eax
  char *v13; // eax
  char *v14; // eax
  signed int v16; // [esp+8h] [ebp-10h] BYREF
  char v17[12]; // [esp+Ch] [ebp-Ch] BYREF

  strcpy(v17, "Send_Data");
  if ( sub_10007C60(this, 15, 1) )
  {
    if ( a2 && a3 )
    {
      if ( a4 && ArgList )
      {
        v9 = sub_10006750(a4, ArgList, &v16, a6, a7);
        if ( v9 )
        {
          if ( (*(int (__thiscall **)(int *))(*this + 88))(this) == 1 )
            v11 = -268435508;
          else
            v11 = this[18];
          if ( sub_10003C10(this[11], v11, a3, 1, 2, v9, v16) )
          {
            sub_10003210(-27, "size: %lu module id: %lu msgtype id: %lu", ArgList, a6, a7);
            v12 = sub_10003240();
            sub_1000C6F0(0, 4, "%s::%s: Neterror: %s", aTinapi, v17, v12);
            sub_1000BBF0(v9);
            return 0;
          }
          else
          {
            sub_1000BBF0(v9);
            return 1;
          }
        }
        else
        {
          sub_10003210(-26, "size: %lu module id: %lu msgtype id: %lu", ArgList, a6, a7);
          v10 = sub_10003240();
          sub_1000C6F0(0, 4, "%s::%s: Neterror: %s", aTinapi, v17, v10);
          return 0;
        }
      }
      else
      {
        sub_100031F0(2);
        v13 = sub_10003240();
        sub_1000C6F0(0, 4, "%s::%s: Neterror: %s", aTinapi, v17, v13);
        return 0;
      }
    }
    else
    {
      sub_100031F0(-30);
      v14 = sub_10003240();
      sub_1000C6F0(0, 4, "%s::%s: Neterror: %s", aTinapi, v17, v14);
      return 0;
    }
  }
  else
  {
    sub_100031F0(-18);
    v7 = sub_10003240();
    sub_1000C6F0(0, 4, "%s::%s: Neterror: %s", aTinapi, v17, v7);
    return 0;
  }
}
// 10008E40: using guessed type int ArgList;

//----- (10009030) --------------------------------------------------------
BOOL __thiscall sub_10009030(int *this, int a2, int a3, char *a4, int a5)
{
  char *v6; // eax
  _WORD *v8; // eax
  char v9[20]; // [esp+4h] [ebp-14h] BYREF

  strcpy(v9, "Send_DataToGroup");
  if ( !sub_10007C60(this, 15, 1) )
  {
    sub_100031F0(-18);
    v6 = sub_10003240();
    sub_1000C6F0(0, 4, "%s::%s: Neterror: %s", aTinapi, v9, v6);
    return 0;
  }
  v8 = (_WORD *)this[11];
  if ( *v8 != 2 )
    return 0;
  return sub_10003F60((int)v8, a2, a3, a4, a5) == 0;
}

//----- (100090E0) --------------------------------------------------------
BOOL __thiscall sub_100090E0(int *this, int a2, int a3, char *Source)
{
  char *v5; // eax
  char v7[12]; // [esp+4h] [ebp-Ch] BYREF

  strcpy(v7, "Send_File");
  if ( sub_10007C60(this, 15, 1) )
    return sub_10003D10(this[11], Source, a2, a3) == 0;
  sub_100031F0(-18);
  v5 = sub_10003240();
  sub_1000C6F0(0, 4, "%s::%s: Neterror: %s", aTinapi, v7, v5);
  return 0;
}

//----- (10009170) --------------------------------------------------------
int __thiscall sub_10009170(int *this, int a2)
{
  char *v3; // eax
  _WORD *v5; // esi
  char *v6; // eax
  bool v7; // zf
  int v8; // eax
  char *v9; // eax
  char ArgList[4]; // [esp+4h] [ebp-1Ch] BYREF
  char v11[12]; // [esp+8h] [ebp-18h] BYREF
  __int16 v12[2]; // [esp+14h] [ebp-Ch] BYREF
  int v13; // [esp+18h] [ebp-8h]
  DWORD TickCount; // [esp+1Ch] [ebp-4h]

  strcpy(v11, "Send_Ping");
  if ( sub_10007C60(this, 15, 1) )
  {
    v12[0] = 23177;
    v12[1] = 0;
    v13 = a2;
    TickCount = GetTickCount();
    v5 = sub_10006750((char *)v12, 12, ArgList, 99, 23177);
    if ( v5 )
    {
      v7 = (*(int (__thiscall **)(int *))(*this + 88))(this) == 1;
      v8 = -268435508;
      if ( !v7 )
        v8 = this[18];
      if ( sub_10003C10(this[11], v8, a2, 1, 2, v5, *(signed int *)ArgList) )
      {
        sub_10003210(-27, "pingmsg size: %lu", *(_DWORD *)ArgList);
        v9 = sub_10003240();
        sub_1000C6F0(0, 4, "%s::%s: Neterror: %s", aTinapi, v11, v9);
        sub_1000BBF0(v5);
        return 0;
      }
      else
      {
        sub_1000BBF0(v5);
        return 1;
      }
    }
    else
    {
      sub_10003210(-26, "pingmsg size: %lu", 12);
      v6 = sub_10003240();
      sub_1000C6F0(0, 4, "%s::%s: Neterror: %s", aTinapi, v11, v6);
      return 0;
    }
  }
  else
  {
    sub_100031F0(-18);
    v3 = sub_10003240();
    sub_1000C6F0(0, 4, "%s::%s: Neterror: %s", aTinapi, v11, v3);
    return 0;
  }
}

//----- (10009300) --------------------------------------------------------
int __userpurge sub_10009300@<eax>(int *a1@<ecx>, int a2, unsigned __int16 (__thiscall **a3)(int, int *, int, int))
{
  char *v4; // eax
  int v6; // ebp
  int v7; // edi
  int v8; // ebx
  int v9; // eax
  int v10; // eax
  char v11[20]; // [esp+4h] [ebp-14h] BYREF

  strcpy(v11, "NetworkService_Init");
  if ( !sub_10007C60(a1, 3, 1) )
  {
    sub_100031F0(-18);
    v4 = sub_10003240();
    sub_1000C6F0(0, 4, "%s::%s: Neterror: %s", aTinapi, v11, v4);
    return 0;
  }
  if ( a2 )
    (*(void (__thiscall **)(int *, int))(*a1 + 48))(a1, a2);
  v6 = ((*(int (__thiscall **)(int *))(*a1 + 88))(a1) == 2) + 1;
  v7 = (*(int (__thiscall **)(int *))(*a1 + 52))(a1);
  v8 = (*(int (__thiscall **)(int *))(*a1 + 52))(a1);
  v9 = (*(int (__thiscall **)(int))(*(_DWORD *)v7 + 16))(v7);
  v10 = (*(int (__thiscall **)(int, int))(*(_DWORD *)v8 + 28))(v8, v9);
  if ( (*a3)(a1[13], a1, v6, v10) == 0xFFFF )
    return 0;
  a1[11] = *(_DWORD *)(a1[13] + 76);
  sub_1000C720("Network Service initialized.");
  a1[9] |= 8u;
  return 1;
}

//----- (10009410) --------------------------------------------------------
__int16 __thiscall sub_10009410(int *this)
{
  char *v2; // eax
  int v4; // eax
  char v5[24]; // [esp+4h] [ebp-18h] BYREF

  strcpy(v5, "NetworkService_Remove");
  if ( sub_10007C60(this, 11, 1) )
  {
    v4 = this[13];
    if ( v4 )
      (*(void (**)(void))(*(_DWORD *)v4 + 4))();
    this[9] &= ~8u;
    return sub_1000C720("Network Service removed.");
  }
  else
  {
    sub_100031F0(-18);
    v2 = sub_10003240();
    return sub_1000C6F0(0, 4, "%s::%s: Neterror: %s", aTinapi, v5, v2);
  }
}

//----- (100094C0) --------------------------------------------------------
__int16 __thiscall sub_100094C0(int this)
{
  char *v2; // eax
  char v4[44]; // [esp+Ch] [ebp-2Ch] BYREF

  strcpy(v4, "NetworkService_IncomingConnections_Start");
  if ( sub_10007C60((int *)this, 11, 1) )
    return sub_10001B80(*(char **)(this + 44));
  sub_100031F0(-18);
  v2 = sub_10003240();
  return sub_1000C6F0(0, 4, "%s::%s: Neterror: %s", aTinapi, v4, v2);
}

//----- (10009530) --------------------------------------------------------
__int16 __thiscall sub_10009530(int this)
{
  char *v2; // eax
  char v4[40]; // [esp+Ch] [ebp-28h] BYREF

  strcpy(v4, "NetworkService_IncomingConnections_Stop");
  if ( sub_10007C60((int *)this, 11, 1) )
    return sub_10001BE0(*(char **)(this + 44));
  sub_100031F0(-18);
  v2 = sub_10003240();
  return sub_1000C6F0(0, 4, "%s::%s: Neterror: %s", aTinapi, v4, v2);
}

//----- (100095A0) --------------------------------------------------------
int __thiscall sub_100095A0(int *this, int a2)
{
  char *v3; // eax
  char v5[28]; // [esp+Ch] [ebp-1Ch] BYREF

  strcpy(v5, "TinCatAPI_RegisterCallbacks");
  if ( sub_10007C60(this, 1, 1) )
  {
    this[12] = a2;
    this[9] |= 2u;
    return 1;
  }
  else
  {
    sub_100031F0(-18);
    v3 = sub_10003240();
    sub_1000C6F0(0, 4, "%s::%s: Neterror: %s", aTinapi, v5, v3);
    return 0;
  }
}

//----- (10009620) --------------------------------------------------------
__int16 __cdecl sub_10009620(int a1, int a2, int a3)
{
  __int16 result; // ax

  if ( a1 )
  {
    if ( a2 )
    {
      if ( a3 )
        return sub_10008830(a1, a2);
      else
        return sub_10008780(a1, a2);
    }
    else
    {
      return sub_100088E0(a1);
    }
  }
  return result;
}

//----- (10009650) --------------------------------------------------------
int __thiscall sub_10009650(int this, char *Source, __int16 a3, int a4, int a5)
{
  char *v6; // eax
  char v8[16]; // [esp+4h] [ebp-10h] BYREF

  strcpy(v8, "BCast_Enable");
  if ( sub_10007C60((int *)this, 11, 1) )
  {
    if ( sub_1000AA60(this + 88, a3, *(_DWORD *)(this + 68), a4) && sub_1000AB00((char *)(this + 88), Source) )
    {
      *(_DWORD *)(this + 1244) = this;
      *(_DWORD *)(this + 1240) = sub_10009620;
      *(_DWORD *)(this + 84) = 1;
      return 1;
    }
    else
    {
      return 0;
    }
  }
  else
  {
    sub_100031F0(-18);
    v6 = sub_10003240();
    sub_1000C6F0(0, 4, "%s::%s: Neterror: %s", aTinapi, v8, v6);
    return 0;
  }
}

//----- (10009720) --------------------------------------------------------
__int16 __thiscall sub_10009720(int this, int a2, int a3, unsigned __int16 *a4, int a5)
{
  char *v6; // eax
  void *v7; // eax
  char *v8; // eax
  const void *v9; // esi
  int v10; // edx
  bool v11; // cc
  char *v12; // eax
  unsigned int v13; // ecx
  void *v14; // edi
  unsigned int v16; // [esp+4h] [ebp-14h] BYREF
  char v17[16]; // [esp+8h] [ebp-10h] BYREF

  strcpy(v17, "Received_Data");
  if ( !sub_10007C60((int *)this, 15, 1) )
  {
    sub_100031F0(-18);
    v6 = sub_10003240();
    LOWORD(v7) = sub_1000C6F0(0, 4, "%s::%s: Neterror: %s", aTinapi, v17, v6);
    return (__int16)v7;
  }
  if ( !a4 )
  {
    sub_100031F0(-28);
    v8 = sub_10003240();
    LOWORD(v7) = sub_1000C6F0(0, 4, "%s::%s: Neterror: %s", aTinapi, v17, v8);
    return (__int16)v7;
  }
  v9 = (const void *)sub_100067C0((int)a4, a5, &v16);
  if ( *a4 == 99 && a4[1] == 23177 )
  {
    LOWORD(v7) = sub_100085D0((int *)this, a2, a3, (signed int)v9);
    return (__int16)v7;
  }
  if ( *(_DWORD *)(this + 1260) != 1 )
    goto LABEL_11;
  if ( a4[1] != *(_WORD *)(this + 1264) )
  {
    *(_DWORD *)(this + 1248) = 3;
LABEL_11:
    v10 = **(_DWORD **)(this + 48);
    if ( (int)v16 <= 0 )
      LOWORD(v7) = (*(int (__stdcall **)(int, int, _DWORD))(v10 + 36))(a2, a3, a4[1]);
    else
      LOWORD(v7) = (*(int (__stdcall **)(int, int, _DWORD, _DWORD, const void *, unsigned int))(v10 + 28))(
                     a2,
                     a3,
                     *a4,
                     a4[1],
                     v9,
                     v16);
    return (__int16)v7;
  }
  v7 = (void *)v16;
  v11 = (int)v16 <= 0;
  *(_DWORD *)(this + 1248) = 0;
  if ( !v11 )
  {
    v7 = operator new((unsigned int)v7);
    *(_DWORD *)(this + 1252) = v7;
    if ( v7 )
    {
      v13 = v16;
      *(_DWORD *)(this + 1256) = v16;
      v14 = v7;
      LOWORD(v7) = v13;
      qmemcpy(v14, v9, v13);
    }
    else
    {
      sub_100031F0(-42);
      v12 = sub_10003240();
      LOWORD(v7) = sub_1000C6F0(0, 4, "%s::%s: Neterror: %s", aTinapi, v17, v12);
    }
  }
  return (__int16)v7;
}

//----- (100098F0) --------------------------------------------------------
int __thiscall sub_100098F0(int *this, const char *ArgList, int a3)
{
  char *v4; // eax
  int result; // eax
  char *v6; // eax
  char v7[16]; // [esp+4h] [ebp-10h] BYREF

  strcpy(v7, "Helper_GetUser");
  if ( sub_10007C60(this, 15, 1) )
  {
    result = sub_10005EF0(this[11], a3);
    if ( !result )
    {
      sub_10003210(-24, "%s: user id: %lu", ArgList, a3);
      v6 = sub_10003240();
      sub_1000C6F0(0, 4, "%s::%s: Neterror: %s", aTinusr, v7, v6);
      return 0;
    }
  }
  else
  {
    sub_100031F0(-18);
    v4 = sub_10003240();
    sub_1000C6F0(0, 4, "%s::%s: Neterror: %s", aTinusr, v7, v4);
    return 0;
  }
  return result;
}
// 100098F0: using guessed type const char *ArgList;

//----- (100099C0) --------------------------------------------------------
int __thiscall sub_100099C0(int *this, int a2, _DWORD *a3, _DWORD *a4, _DWORD *a5, _DWORD *a6)
{
  int result; // eax
  char ArgList[12]; // [esp+0h] [ebp-Ch] BYREF

  strcpy(ArgList, "User_GetIP");
  result = sub_100098F0(this, ArgList, a2);
  if ( result )
  {
    sub_1000D410((unsigned __int8 *)(*(_DWORD *)(result + 16) + 524), a3, a4, a5, a6);
    return 1;
  }
  return result;
}

//----- (10009A40) --------------------------------------------------------
int __thiscall sub_10009A40(int *this, int a2)
{
  int v3; // eax
  char *v4; // eax
  char ArgList[12]; // [esp+4h] [ebp-Ch] BYREF

  strcpy(ArgList, "User_LogOut");
  v3 = sub_100098F0(this, ArgList, a2);
  if ( !v3 )
    return 0;
  if ( sub_10005940(this[11], v3) )
  {
    sub_100031F0(1);
    v4 = sub_10003240();
    sub_1000C6F0(0, 4, "%s::%s: Neterror: %s", aTinusr, ArgList, v4);
    return 0;
  }
  return 1;
}

//----- (10009AD0) --------------------------------------------------------
int __thiscall sub_10009AD0(int *this)
{
  int v2; // eax
  char *v4; // [esp-8h] [ebp-1Ch]
  char *v5; // [esp-8h] [ebp-1Ch]
  char v6[16]; // [esp+4h] [ebp-10h] BYREF

  strcpy(v6, "User_LogOutALL");
  if ( sub_10007C60(this, 15, 1) )
  {
    v2 = sub_10005C60(this[11]);
    if ( !v2 )
      return 1;
    while ( !sub_10005940(this[11], v2) )
    {
      v2 = sub_10005C60(this[11]);
      if ( !v2 )
        return 1;
    }
    sub_100031F0(1);
    v5 = sub_10003240();
    sub_1000C6F0(0, 4, "%s::%s: Neterror: %s", aTinusr, v6, v5);
  }
  else
  {
    sub_100031F0(-18);
    v4 = sub_10003240();
    sub_1000C6F0(0, 4, "%s::%s: Neterror: %s", aTinusr, v6, v4);
  }
  return 0;
}

//----- (10009BA0) --------------------------------------------------------
int __thiscall sub_10009BA0(int *this, int a2)
{
  int result; // eax
  int v3; // esi
  int v4; // eax
  void **i; // eax
  char ArgList[24]; // [esp+4h] [ebp-18h] BYREF

  strcpy(ArgList, "User_SendQueue_Clear");
  result = sub_100098F0(this, ArgList, a2);
  v3 = result;
  if ( result )
  {
    sub_1000E090(*(_DWORD *)(result + 4), 0xFFFFFFFF);
    v4 = *(_DWORD *)(*(_DWORD *)(v3 + 12) + 84);
    if ( v4 )
    {
      for ( i = (void **)sub_10022B10(v4, &a2); i; i = (void **)sub_10022B10(
                                                                  *(_DWORD *)(*(_DWORD *)(v3 + 12) + 84),
                                                                  &a2) )
        sub_1000CAD0(i);
    }
    sub_1000E0E0(*(_DWORD *)(v3 + 4));
    return 1;
  }
  return result;
}

//----- (10009C60) --------------------------------------------------------
int __thiscall sub_10009C60(int *this, int a2)
{
  int result; // eax
  int v3; // esi
  int v4; // edi
  char ArgList[24]; // [esp+4h] [ebp-18h] BYREF

  strcpy(ArgList, "User_SendQueue_GetCount");
  result = sub_100098F0(this, ArgList, a2);
  v3 = result;
  if ( result )
  {
    sub_1000E090(*(_DWORD *)(result + 4), 0xFFFFFFFF);
    v4 = sub_10022B70(*(_DWORD *)(*(_DWORD *)(v3 + 12) + 84));
    sub_1000E0E0(*(_DWORD *)(v3 + 4));
    return v4;
  }
  return result;
}

//----- (10009CF0) --------------------------------------------------------
int __thiscall sub_10009CF0(int *this, int a2, int a3)
{
  int result; // eax
  char ArgList[24]; // [esp+8h] [ebp-18h] BYREF

  strcpy(ArgList, "User_CustomData_Attach");
  result = sub_100098F0(this, ArgList, a2);
  if ( result )
  {
    sub_10005D50(result, 2u, a3);
    return 1;
  }
  return result;
}

//----- (10009D50) --------------------------------------------------------
int __thiscall sub_10009D50(int *this, int a2)
{
  int result; // eax
  char ArgList[20]; // [esp+0h] [ebp-14h] BYREF

  strcpy(ArgList, "User_CustomData_Get");
  result = sub_100098F0(this, ArgList, a2);
  if ( result )
    return sub_10005D90(result, 2u);
  return result;
}

//----- (10009DB0) --------------------------------------------------------
__int16 __thiscall sub_10009DB0(int *this, int a2)
{
  int v2; // eax
  char ArgList[24]; // [esp+0h] [ebp-18h] BYREF

  strcpy(ArgList, "User_CustomData_Clear");
  v2 = sub_100098F0(this, ArgList, a2);
  if ( v2 )
    LOWORD(v2) = sub_10005D00(v2, 2u, 1);
  return v2;
}

//----- (10009E20) --------------------------------------------------------
int __thiscall sub_10009E20(int *this, int ArgList, const char *a3)
{
  int v5; // ebp
  char *v6; // eax
  char *v7; // eax
  char *v8; // [esp-10h] [ebp-30h]
  char *v9; // [esp-10h] [ebp-30h]
  char v10[24]; // [esp+8h] [ebp-18h] BYREF

  strcpy(v10, "User_LogNoteText_Attach");
  if ( !a3 )
  {
    sub_10003210(-31, "user id: %lu", ArgList);
    v8 = sub_10003240();
    sub_1000C6F0(0, 4, "%s::%s: Neterror: %s", aTinusr, v10, v8);
    return 0;
  }
  if ( strlen(a3) >= 0x80 )
  {
    sub_10003210(-32, "user id: %lu", ArgList);
    v9 = sub_10003240();
    sub_1000C6F0(0, 4, "%s::%s: Neterror: %s", aTinusr, v10, v9);
    return 0;
  }
  v5 = sub_100098F0(this, v10, ArgList);
  if ( !v5 )
    return 0;
  (*(void (__thiscall **)(int *, int))(*this + 208))(this, ArgList);
  v6 = (char *)sub_1000BB40(strlen(a3) + 2);
  if ( !v6 )
  {
    sub_10003210(-33, "user id: %lu", ArgList);
    v7 = sub_10003240();
    sub_1000C6F0(0, 4, "%s::%s: Neterror: %s", aTinusr, v10, v7);
    return 0;
  }
  strcpy(v6, a3);
  sub_10005D50(v5, 1u, (int)v6);
  return 1;
}
// 10009E20: using guessed type int ArgList;

//----- (10009F90) --------------------------------------------------------
int __thiscall sub_10009F90(int *this, int a2)
{
  int result; // eax
  char ArgList[24]; // [esp+0h] [ebp-18h] BYREF

  strcpy(ArgList, "User_LogNoteText_Get");
  result = sub_100098F0(this, ArgList, a2);
  if ( result )
    return sub_10005D90(result, 1u);
  return result;
}

//----- (1000A000) --------------------------------------------------------
__int16 __thiscall sub_1000A000(int *this, int a2)
{
  int v3; // eax
  int v4; // edi
  void *v5; // eax
  char ArgList[24]; // [esp+Ch] [ebp-18h] BYREF

  strcpy(ArgList, "User_LogNoteText_Clear");
  v3 = sub_100098F0(this, ArgList, a2);
  v4 = v3;
  if ( v3 )
  {
    v5 = (void *)(*(int (__thiscall **)(int *, int))(*this + 204))(this, a2);
    if ( v5 )
      sub_1000BBF0(v5);
    LOWORD(v3) = sub_10005D00(v4, 1u, 1);
  }
  return v3;
}

//----- (1000A060) --------------------------------------------------------
int __thiscall sub_1000A060(int *this)
{
  char *v2; // eax
  char v4[12]; // [esp+4h] [ebp-Ch] BYREF

  strcpy(v4, "User_GetMax");
  if ( sub_10007C60(this, 11, 1) )
    return *(_DWORD *)(this[11] + 136);
  sub_100031F0(-18);
  v2 = sub_10003240();
  sub_1000C6F0(0, 4, "%s::%s: Neterror: %s", aTinusr, v4, v2);
  return -1;
}

//----- (1000A0D0) --------------------------------------------------------
__int16 __thiscall sub_1000A0D0(int *this, unsigned int a2)
{
  char *v3; // eax
  unsigned int v5; // edi
  int v6; // eax
  int v7; // eax
  char v8[12]; // [esp+4h] [ebp-Ch] BYREF

  strcpy(v8, "User_SetMax");
  if ( sub_10007C60(this, 11, 1) )
  {
    v5 = a2;
    if ( a2 > sub_100076A0() )
      v5 = sub_100076A0();
    v6 = (*(int (__thiscall **)(int *))(*this + 52))(this);
    if ( v5 > (*(int (__thiscall **)(int))(*(_DWORD *)v6 + 28))(v6) )
    {
      v7 = (*(int (__thiscall **)(int *))(*this + 52))(this);
      v5 = (*(int (__thiscall **)(int))(*(_DWORD *)v7 + 28))(v7);
    }
    return sub_10001C40(this[11], v5, 2);
  }
  else
  {
    sub_100031F0(-18);
    v3 = sub_10003240();
    return sub_1000C6F0(0, 4, "%s::%s: Neterror: %s", aTinusr, v8, v3);
  }
}

//----- (1000A180) --------------------------------------------------------
int __thiscall sub_1000A180(int *this)
{
  char *v2; // eax
  char v4[24]; // [esp+Ch] [ebp-18h] BYREF

  strcpy(v4, "User_GetConnectedCount");
  if ( sub_10007C60(this, 11, 1) )
    return sub_10005F70(this[11]);
  sub_100031F0(-18);
  v2 = sub_10003240();
  sub_1000C6F0(0, 4, "%s::%s: Neterror: %s", aTinusr, v4, v2);
  return -1;
}

//----- (1000A1F0) --------------------------------------------------------
int __thiscall sub_1000A1F0(_DWORD *this, unsigned int ArgList)
{
  int result; // eax

  result = sub_100076B0(ArgList);
  if ( result )
  {
    this[1] = ArgList;
    return 1;
  }
  return result;
}

//----- (1000A220) --------------------------------------------------------
int __thiscall sub_1000A220(int this, int a2, int a3, int a4)
{
  int result; // eax

  *(_DWORD *)(this + 4) = a4;
  *(_DWORD *)(this + 8) = a3;
  *(_DWORD *)(this + 60) = *(_DWORD *)(a2 + 8);
  *(_WORD *)(this + 64) = *(_WORD *)(a2 + 12);
  *(_DWORD *)(this + 68) = *(_DWORD *)(a2 + 16);
  *(_WORD *)(this + 72) = *(_WORD *)(a2 + 20);
  *(_DWORD *)(this + 76) = *(_DWORD *)(a2 + 24);
  *(_WORD *)(this + 80) = *(_WORD *)(a2 + 28);
  *(_DWORD *)(this + 40) = *(_DWORD *)(a2 + 32);
  *(_DWORD *)(this + 36) = *(_DWORD *)(a2 + 36);
  *(_DWORD *)(this + 32) = *(_DWORD *)(a2 + 40);
  *(_DWORD *)(this + 20) = *(_DWORD *)(a2 + 44);
  *(_DWORD *)(this + 24) = *(_DWORD *)(a2 + 48);
  *(_DWORD *)(this + 16) = *(_DWORD *)(a2 + 52);
  *(_DWORD *)(this + 28) = *(_DWORD *)(a2 + 56);
  *(_DWORD *)(this + 56) = *(_DWORD *)(a2 + 60);
  *(_DWORD *)(this + 52) = *(_DWORD *)(a2 + 64);
  *(_DWORD *)(this + 48) = *(_DWORD *)(a2 + 68);
  *(_DWORD *)(this + 44) = *(_DWORD *)(a2 + 72);
  *(_DWORD *)(this + 12) = *(_DWORD *)(a2 + 76);
  *(_DWORD *)(this + 88) = *(_DWORD *)(a2 + 80);
  *(_DWORD *)(this + 92) = *(_DWORD *)(a2 + 84);
  *(_DWORD *)(this + 84) = *(_DWORD *)(a2 + 124);
  *(_DWORD *)(this + 96) = *(_DWORD *)(a2 + 88);
  *(_DWORD *)(this + 100) = *(_DWORD *)(a2 + 92);
  *(_DWORD *)(this + 108) = *(_DWORD *)(a2 + 112);
  *(_DWORD *)(this + 112) = *(_DWORD *)(a2 + 116);
  *(_DWORD *)(this + 116) = *(_DWORD *)(a2 + 120);
  *(_DWORD *)(this + 104) = *(_DWORD *)(a2 + 96);
  *(_DWORD *)(this + 120) = *(_DWORD *)(a2 + 100);
  *(_DWORD *)(this + 124) = *(_DWORD *)(a2 + 104);
  result = *(_DWORD *)(a2 + 108);
  *(_DWORD *)(this + 128) = result;
  return result;
}

//----- (1000A300) --------------------------------------------------------
int __thiscall sub_1000A300(int this, int a2)
{
  int v3; // eax
  int v4; // esi
  const char *v5; // eax
  const char *v6; // eax
  const char *v7; // eax
  const char *v8; // eax
  const char *v9; // eax
  const char *v10; // eax
  const char *v11; // eax
  const char *v12; // eax
  const char *v13; // eax
  const char *v14; // eax
  const char *v15; // eax
  const char *v16; // eax
  const char *v17; // eax
  const char *v18; // eax
  const char *v19; // eax
  const char *v20; // eax
  const char *v21; // eax
  const char *v22; // eax
  const char *v23; // eax
  const char *v24; // eax
  const char *v25; // eax
  const char *v26; // eax
  const char *v27; // eax
  const char *v28; // eax

  v3 = off_1004AE0C(a2);
  v4 = v3;
  if ( !v3 )
    return 0;
  v5 = (const char *)off_1004AE14(v3, "tincat", "port");
  if ( !v5 )
    return 0;
  *(_DWORD *)(this + 4) = atol(v5);
  v6 = (const char *)off_1004AE14(v4, "tincat", "usr_max");
  if ( !v6 )
    return 0;
  *(_DWORD *)(this + 104) = atol(v6);
  v7 = (const char *)off_1004AE14(v4, "tincat", "buf_rw");
  if ( !v7 )
    return 0;
  *(_DWORD *)(this + 88) = atol(v7);
  v8 = (const char *)off_1004AE14(v4, "tincat", "buf_writeblock");
  if ( !v8 )
    return 0;
  *(_DWORD *)(this + 92) = atol(v8);
  v9 = (const char *)off_1004AE14(v4, "tincat", "thrd_exit");
  if ( !v9 )
    return 0;
  *(_DWORD *)(this + 12) = atol(v9);
  v10 = (const char *)off_1004AE14(v4, "tincat", "srv_newconnect");
  if ( !v10 )
    return 0;
  *(_DWORD *)(this + 16) = atol(v10);
  v11 = (const char *)off_1004AE14(v4, "tincat", "srv_waitforflags");
  if ( !v11 )
    return 0;
  *(_DWORD *)(this + 28) = atol(v11);
  v12 = (const char *)off_1004AE14(v4, "tincat", "srv_sendlogofftimeout");
  if ( !v12 )
    return 0;
  *(_DWORD *)(this + 24) = atol(v12);
  v13 = (const char *)off_1004AE14(v4, "tincat", "srv_sendlogonrequest");
  if ( !v13 )
    return 0;
  *(_DWORD *)(this + 20) = atol(v13);
  v14 = (const char *)off_1004AE14(v4, "tincat", "srv_checkdeadcon");
  if ( !v14 )
    return 0;
  *(_DWORD *)(this + 32) = atol(v14);
  v15 = (const char *)off_1004AE14(v4, "tincat", "srv_checkdeadcalltime");
  if ( !v15 )
    return 0;
  *(_DWORD *)(this + 36) = atol(v15);
  v16 = (const char *)off_1004AE14(v4, "tincat", "srv_sendalive");
  if ( !v16 )
    return 0;
  *(_DWORD *)(this + 40) = atol(v16);
  v17 = (const char *)off_1004AE14(v4, "tincat", "usr_initnew");
  if ( !v17 )
    return 0;
  *(_DWORD *)(this + 44) = atol(v17);
  v18 = (const char *)off_1004AE14(v4, "tincat", "usr_remove");
  if ( !v18 )
    return 0;
  *(_DWORD *)(this + 48) = atol(v18);
  v19 = (const char *)off_1004AE14(v4, "tincat", "usr_logoncheck");
  if ( !v19 )
    return 0;
  *(_DWORD *)(this + 52) = atol(v19);
  v20 = (const char *)off_1004AE14(v4, "tincat", "usr_logofftimeout");
  if ( !v20 )
    return 0;
  *(_DWORD *)(this + 56) = atol(v20);
  v21 = (const char *)off_1004AE14(v4, "tincat", "drv_removetime");
  if ( !v21 )
    return 0;
  *(_DWORD *)(this + 120) = atol(v21);
  v22 = (const char *)off_1004AE14(v4, "tincat", "drv_reader_sleep");
  if ( !v22 )
    return 0;
  *(_DWORD *)(this + 60) = atol(v22);
  v23 = (const char *)off_1004AE14(v4, "tincat", "drv_reader_sleep_activate");
  if ( !v23 )
    return 0;
  *(_WORD *)(this + 64) = atol(v23);
  v24 = (const char *)off_1004AE14(v4, "tincat", "drv_writer_sleep");
  if ( !v24 )
    return 0;
  *(_DWORD *)(this + 68) = atol(v24);
  v25 = (const char *)off_1004AE14(v4, "tincat", "drv_writer_sleep_activate");
  if ( !v25 )
    return 0;
  *(_WORD *)(this + 72) = atol(v25);
  v26 = (const char *)off_1004AE14(v4, "tincat", "drv_serverloop_sleep");
  if ( !v26 )
    return 0;
  *(_DWORD *)(this + 76) = atol(v26);
  v27 = (const char *)off_1004AE14(v4, "tincat", "drv_serverloop_sleep_activate");
  if ( !v27 )
    return 0;
  *(_WORD *)(this + 80) = atol(v27);
  v28 = (const char *)off_1004AE14(v4, "tincat", "drv_disable_nagle");
  if ( !v28 )
    return 0;
  *(_DWORD *)(this + 84) = j__atol(v28) > 0;
  off_1004AE18(v4);
  return 1;
}
// 1004AE0C: using guessed type int (__cdecl *off_1004AE0C)(_DWORD);
// 1004AE14: using guessed type int (__cdecl *off_1004AE14)(_DWORD, _DWORD, _DWORD);
// 1004AE18: using guessed type int (__cdecl *off_1004AE18)(_DWORD);

//----- (1000A6B0) --------------------------------------------------------
__int16 __thiscall sub_1000A6B0(int this, unsigned int a2)
{
  __int16 result; // ax
  char *v4; // eax
  char v5[20]; // [esp+8h] [ebp-14h] BYREF

  strcpy(v5, "Drv_SetWriterTiming");
  result = 21618;
  if ( a2 <= 0xEA60 )
  {
    if ( a2 )
    {
      *(_DWORD *)(this + 68) = a2;
      *(_WORD *)(this + 72) = 1;
    }
    else
    {
      *(_DWORD *)(this + 68) = 0;
      *(_WORD *)(this + 72) = 0;
    }
  }
  else
  {
    sub_100031F0(3);
    v4 = sub_10003240();
    result = sub_1000C6F0(0, 4, "%s::%s: Neterror: %s", aTinvalue, v5, v4);
    *(_DWORD *)(this + 68) = 60000;
    *(_WORD *)(this + 72) = 1;
  }
  return result;
}

//----- (1000A760) --------------------------------------------------------
__int16 __thiscall sub_1000A760(int this, unsigned int a2)
{
  __int16 result; // ax
  char *v4; // eax
  char v5[20]; // [esp+8h] [ebp-14h] BYREF

  strcpy(v5, "Drv_SetReaderTiming");
  result = 21618;
  if ( a2 <= 0xEA60 )
  {
    if ( a2 )
    {
      *(_DWORD *)(this + 60) = a2;
      *(_WORD *)(this + 64) = 1;
    }
    else
    {
      *(_DWORD *)(this + 60) = 0;
      *(_WORD *)(this + 64) = 0;
    }
  }
  else
  {
    sub_100031F0(3);
    v4 = sub_10003240();
    result = sub_1000C6F0(0, 4, "%s::%s: Neterror: %s", aTinvalue, v5, v4);
    *(_DWORD *)(this + 60) = 60000;
    *(_WORD *)(this + 64) = 1;
  }
  return result;
}

//----- (1000A810) --------------------------------------------------------
__int16 __thiscall sub_1000A810(int this, unsigned int a2)
{
  __int16 result; // ax
  char *v4; // eax
  char v5[24]; // [esp+8h] [ebp-18h] BYREF

  strcpy(v5, "Drv_SetServerLoopTiming");
  result = 19570;
  if ( a2 <= 0xEA60 )
  {
    if ( a2 )
    {
      *(_DWORD *)(this + 68) = a2;
      *(_WORD *)(this + 72) = 1;
    }
    else
    {
      *(_DWORD *)(this + 68) = 0;
      *(_WORD *)(this + 72) = 0;
    }
  }
  else
  {
    sub_100031F0(3);
    v4 = sub_10003240();
    result = sub_1000C6F0(0, 4, "%s::%s: Neterror: %s", aTinvalue, v5, v4);
    *(_DWORD *)(this + 68) = 60000;
    *(_WORD *)(this + 72) = 1;
  }
  return result;
}

//----- (1000A8D0) --------------------------------------------------------
int __thiscall sub_1000A8D0(void *this, unsigned __int16 a2, __int16 a3, int a4, int a5)
{
  char *v5; // eax
  int v7; // eax
  char v8[16]; // [esp+0h] [ebp-10h] BYREF

  strcpy(v8, "InitDefaults");
  if ( a2 < 4u )
  {
    v7 = a2 << 7;
    if ( a3 == 1 )
      sub_1000A220((int)this, (int)&unk_10048FE0 + v7, a4, a5);
    else
      sub_1000A220((int)this, (int)&unk_100491E0 + v7, a4, a5);
    return 1;
  }
  else
  {
    sub_100031F0(-40);
    v5 = sub_10003240();
    sub_1000C6F0(0, 4, "%s::%s: Neterror: %s", aTinvalue, v8, v5);
    return 0;
  }
}

//----- (1000A980) --------------------------------------------------------
int TinCat_CreateTinCatValues()
{
  _DWORD *v0; // eax
  int v1; // ecx

  v0 = operator new(0x84u);
  if ( !v0 )
    return 0;
  *v0 = &off_1003CE60;
  sub_1000A220((int)v0, (int)&unk_100491E0, -1, -1);
  return v1;
}
// 1000A9A7: variable 'v1' is possibly undefined
// 1003CE60: using guessed type void *off_1003CE60;

//----- (1000A9B0) --------------------------------------------------------
_DWORD *__thiscall sub_1000A9B0(_DWORD *this)
{
  sub_10024FE0((DNameNode *)this);
  memset(this + 6, 0, 0x45Cu);
  this[285] = 0;
  this[286] = 0;
  this[287] = 0;
  this[288] = 0;
  this[289] = 0;
  return this;
}

//----- (1000A9F0) --------------------------------------------------------
int __thiscall sub_1000A9F0(int this)
{
  void *i; // eax
  _DWORD *v4[6]; // [esp+4h] [ebp-18h] BYREF

  sub_10024350(v4, (_DWORD *)this);
  for ( i = (void *)sub_10024240(v4); i; i = (void *)sub_10024270(v4) )
    j__free(i);
  sub_10024200(v4);
  if ( *(_DWORD *)(this + 1140) )
    sub_1000D6B0(*(_DWORD **)(this + 1140));
  sub_100243A0(v4);
  return sub_10025B40((_DWORD *)this);
}

//----- (1000AA60) --------------------------------------------------------
int __thiscall sub_1000AA60(int this, __int16 a2, __int16 a3, int a4)
{
  void *i; // eax
  char *v6; // eax
  _DWORD *v8[6]; // [esp+4h] [ebp-18h] BYREF

  sub_10024350(v8, (_DWORD *)this);
  for ( i = (void *)sub_10024240(v8); i; i = (void *)sub_10024270(v8) )
    j__free(i);
  sub_10024200(v8);
  if ( *(_DWORD *)(this + 1140) )
    sub_1000D6B0(*(_DWORD **)(this + 1140));
  v6 = sub_1000D4B0(a3, a2, 1116);
  *(_DWORD *)(this + 1140) = v6;
  if ( v6 )
  {
    *(_DWORD *)(this + 1144) = a4;
    sub_100243A0(v8);
    return 1;
  }
  else
  {
    sub_100243A0(v8);
    return 0;
  }
}

//----- (1000AB00) --------------------------------------------------------
int __thiscall sub_1000AB00(char *this, char *Source)
{
  _DWORD *v3; // ecx

  if ( Source )
  {
    sub_1000E930(Source, this + 24, 0x20u);
  }
  else
  {
    v3 = this + 24;
    *v3 = 0;
    v3[1] = 0;
    v3[2] = 0;
    v3[3] = 0;
    v3[4] = 0;
    v3[5] = 0;
    v3[6] = 0;
    v3[7] = 0;
  }
  return 1;
}

//----- (1000AB50) --------------------------------------------------------
int __thiscall sub_1000AB50(_DWORD *this, const void *a2)
{
  int v3[271]; // [esp+8h] [ebp-440h] BYREF

  if ( !a2 )
    return 0;
  qmemcpy(v3, a2, sizeof(v3));
  v3[14] = this[28];
  qmemcpy(&v3[15], this + 29, 0x400u);
  qmemcpy(this + 14, v3, 0x43Cu);
  return 1;
}

//----- (1000ABB0) --------------------------------------------------------
int __thiscall sub_1000ABB0(_DWORD *this, int a2)
{
  int result; // eax

  result = a2;
  if ( a2 )
  {
    this[28] = *(_DWORD *)(a2 + 56);
    qmemcpy(this + 29, (const void *)(a2 + 60), 0x400u);
    return 1;
  }
  return result;
}

//----- (1000ABE0) --------------------------------------------------------
int __thiscall sub_1000ABE0(int this)
{
  int result; // eax
  unsigned int v3; // [esp+4h] [ebp-34h] BYREF
  _DWORD v4[4]; // [esp+8h] [ebp-30h] BYREF
  char Str1[32]; // [esp+18h] [ebp-20h] BYREF

  result = *(_DWORD *)(this + 1140);
  if ( result )
  {
    if ( *(_BYTE *)(this + 24) )
    {
      v3 = 32;
      result = sub_1000D850(result, Str1, &v3, v4);
      if ( result )
      {
        if ( v3 == 32 )
        {
          result = strncmp(Str1, (const char *)(this + 24), 0x20u);
          if ( !result )
            return sub_1000D7D0(*(_DWORD *)(this + 1140), (const void *)(this + 24), 0x45Cu, v4);
        }
      }
    }
  }
  return result;
}
// 1000ABE0: using guessed type _DWORD var_30[4];

//----- (1000AC60) --------------------------------------------------------
int __thiscall sub_1000AC60(int this)
{
  int result; // eax
  void *v3; // esi
  int v4; // edi
  void (__cdecl *v5)(_DWORD, void *, int); // eax
  void (__cdecl *v6)(_DWORD, _DWORD, _DWORD); // eax
  int v7; // esi
  _DWORD *v8; // ebp
  void (__cdecl *v9)(_DWORD, _DWORD *, _DWORD); // eax
  int v10; // [esp-18h] [ebp-4A4h]
  unsigned int v11; // [esp+4h] [ebp-488h] BYREF
  _DWORD *v12[6]; // [esp+8h] [ebp-484h] BYREF
  int v13[4]; // [esp+20h] [ebp-46Ch] BYREF
  char Str1[32]; // [esp+30h] [ebp-45Ch] BYREF
  char Destination[1084]; // [esp+50h] [ebp-43Ch] BYREF

  result = *(_DWORD *)(this + 1148);
  if ( result )
  {
    result = *(_DWORD *)(this + 1140);
    if ( result )
    {
      sub_10024350(v12, (_DWORD *)this);
      if ( GetTickCount() - *(_DWORD *)(this + 1148) <= *(_DWORD *)(this + 1144) )
      {
        if ( *(_BYTE *)(this + 24) )
        {
          v10 = *(_DWORD *)(this + 1140);
          v11 = 1116;
          if ( sub_1000D850(v10, Str1, &v11, v13) )
          {
            if ( v11 == 1116 && !strncmp(Str1, (const char *)(this + 24), 0x20u) )
            {
              *(_DWORD *)&Destination[36] = v13[0];
              *(_DWORD *)&Destination[48] = v13[3];
              *(_DWORD *)&Destination[40] = v13[1];
              *(_DWORD *)&Destination[44] = v13[2];
              v7 = sub_10024240(v12);
              if ( v7 )
              {
                while ( *(_DWORD *)(v7 + 36) != *(_DWORD *)&Destination[36]
                     || *(_DWORD *)(v7 + 40) != *(_DWORD *)&Destination[40]
                     || *(_DWORD *)(v7 + 44) != *(_DWORD *)&Destination[44]
                     || *(_DWORD *)(v7 + 48) != *(_DWORD *)&Destination[48]
                     || *(_DWORD *)(v7 + 32) != *(_DWORD *)&Destination[32] )
                {
                  v7 = sub_10024270(v12);
                  if ( !v7 )
                    goto LABEL_26;
                }
                *(_DWORD *)(v7 + 52) = GetTickCount();
                sub_1000E930((char *)v7, Destination, 0x20u);
              }
              else
              {
LABEL_26:
                v8 = operator new(0x43Cu);
                if ( v8 )
                {
                  qmemcpy(v8, Destination, 0x43Cu);
                  v8[13] = GetTickCount();
                  if ( sub_10024100(v12, (int)v8) == -1 )
                  {
                    j__free(v8);
                    return sub_100243A0(v12);
                  }
                  v9 = *(void (__cdecl **)(_DWORD, _DWORD *, _DWORD))(this + 1152);
                  if ( v9 )
                    v9(*(_DWORD *)(this + 1156), v8, 0);
                }
              }
            }
          }
        }
      }
      else
      {
        v3 = 0;
        v4 = sub_10024240(v12);
        while ( v4 )
        {
          if ( *(_DWORD *)(v4 + 52) < *(_DWORD *)(this + 1148) )
            v3 = (void *)v4;
          v4 = sub_10024270(v12);
          if ( v3 )
          {
            v5 = *(void (__cdecl **)(_DWORD, void *, int))(this + 1152);
            if ( v5 )
              v5(*(_DWORD *)(this + 1156), v3, 1);
            (*(void (__thiscall **)(int, void *))(*(_DWORD *)this + 36))(this, v3);
            j__free(v3);
            v3 = 0;
          }
        }
        v6 = *(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(this + 1152);
        *(_DWORD *)(this + 1148) = 0;
        if ( v6 )
          v6(*(_DWORD *)(this + 1156), 0, 0);
      }
      return sub_100243A0(v12);
    }
  }
  return result;
}

//----- (1000AEB0) --------------------------------------------------------
int __thiscall sub_1000AEB0(_DWORD *this)
{
  int v2; // ecx

  v2 = this[285];
  if ( !v2 || !*((_BYTE *)this + 24) || !sub_1000D6E0(v2, this + 6, 0x20u) )
    return 0;
  this[287] = GetTickCount();
  return 1;
}

//----- (1000AEF0) --------------------------------------------------------
_DWORD *__thiscall sub_1000AEF0(_DWORD *this)
{
  _DWORD *result; // eax

  result = this;
  *this = &off_1003D8FC;
  this[1] = 0;
  this[2] = 0;
  return result;
}
// 1003D8FC: using guessed type void *off_1003D8FC;

//----- (1000AF10) --------------------------------------------------------
int __thiscall sub_1000AF10(_DWORD *this, int a2, LPCSTR lpPathName)
{
  int result; // eax
  int v5; // esi
  unsigned int v6; // edi
  char *v7; // eax
  char *v8; // esi
  int v9; // [esp+4h] [ebp-4h]

  v9 = 0;
  if ( this[1] )
    return 0;
  v5 = dword_1004CAD8;
  if ( !dword_1004CAD8 )
  {
    if ( (unsigned __int16)sub_1000E970() )
      return 0;
    v9 = 1;
  }
  if ( a2 )
  {
    sub_1000EA00(lpPathName);
  }
  else
  {
    sub_1000C160();
    sub_1000C180();
  }
  if ( v5 )
    return 1;
  v6 = strlen(aLogfileTxt_0) + 8;
  if ( lpPathName )
    v6 += strlen(lpPathName);
  v7 = (char *)sub_1000BB40(v6);
  v8 = v7;
  if ( !v7 )
    goto LABEL_15;
  sub_1000BC80((int)lpPathName, v7, 0, v6);
  if ( lpPathName )
    sprintf(v8, "%s", lpPathName);
  else
    *(_WORD *)v8 = 46;
  sub_10024090(v8, aLogfileTxt_0);
  this[2] = sub_1000BEB0(1024, (_BYTE *)4, v8);
  sub_1000BBF0(v8);
  if ( this[2] )
  {
    sub_1000C030((_DWORD *)this[2]);
    if ( v9 )
    {
      sub_1000C720("%s", aInstanceFourI4_0);
      sub_1000C720("%s", aCCopyright1996_0);
      sub_1000C720("%s", a08Apr2004Libra);
      sub_1000C720("%s", aIdBlCV16200404);
    }
    result = 1;
    this[1] = 1;
  }
  else
  {
LABEL_15:
    sub_1000E9A0();
    return 0;
  }
  return result;
}
// 1004CAD8: using guessed type int dword_1004CAD8;

//----- (1000B080) --------------------------------------------------------
__int16 __cdecl sub_1000B080(char *a1)
{
  return sub_1000C6B0(0, 4, a1);
}

//----- (1000B0A0) --------------------------------------------------------
int __thiscall sub_1000B0A0(int this)
{
  int result; // eax
  char v3[16]; // [esp+4h] [ebp-20h] BYREF
  int v4; // [esp+14h] [ebp-10h]
  int v5; // [esp+18h] [ebp-Ch]
  _DWORD ArgList[2]; // [esp+1Ch] [ebp-8h]

  result = *(_DWORD *)(this + 4);
  if ( result )
  {
    sub_1000BCB0(v3);
    sub_1000BDF0((int (__cdecl *)(char *))sub_1000B080);
    sub_1000C720("MEMORY RESULT: Highest memory: %ld, GetMem %lu <--> %lu FreeMem", ArgList[0], v4, v5);
    if ( *(_DWORD *)(this + 8) )
      sub_1000C300(*(void **)(this + 8));
    result = dword_1004CAD8;
    if ( dword_1004CAD8 )
      result = sub_1000E9A0();
    *(_DWORD *)(this + 4) = 0;
  }
  return result;
}
// 1004CAD8: using guessed type int dword_1004CAD8;
// 1000B0A0: using guessed type char var_20[16];
// 1000B0A0: using guessed type _DWORD ArgList[2];

//----- (1000B140) --------------------------------------------------------
_DWORD *__thiscall TinCatModules::Reconnector::operator=(_DWORD *this, _DWORD *a2)
{
  _DWORD *result; // eax

  result = this;
  *this = *a2;
  return result;
}

//----- (1000B150) --------------------------------------------------------
int __usercall sub_1000B150@<eax>(unsigned int a1@<eax>, int a2@<ecx>, int a3, const void *a4)
{
  _DWORD *v6; // eax
  _DWORD *v7; // eax
  void *v8; // ebx

  v6 = (_DWORD *)sub_10024240(*(_DWORD ***)(a3 + 48));
  if ( v6 )
  {
    while ( *v6 != a2 )
    {
      v6 = (_DWORD *)sub_10024270(*(_DWORD ***)(a3 + 48));
      if ( !v6 )
        goto LABEL_6;
    }
    j__free(v6);
    sub_100241E0(*(_DWORD ***)(a3 + 48));
  }
LABEL_6:
  if ( a4 && a1 )
  {
    v7 = operator new(a1 + 8);
    v8 = v7;
    if ( !v7 )
      return 0;
    *v7 = a2;
    v7[1] = a1;
    qmemcpy(v7 + 2, a4, a1);
    if ( (**(int (__thiscall ***)(int, _DWORD *))(a3 + 40))(a3 + 40, v7) == -1 )
    {
      j__free(v8);
      return 0;
    }
  }
  return 1;
}

//----- (1000B1F0) --------------------------------------------------------
int __cdecl sub_1000B1F0(_DWORD *a1, int a2)
{
  _DWORD *v2; // esi
  char *v3; // eax
  char *v4; // ebx

  v2 = (_DWORD *)sub_10024240((_DWORD **)a1[12]);
  if ( !v2 )
    return 1;
  while ( 1 )
  {
    v3 = (char *)operator new(v2[1] + 10);
    v4 = v3;
    if ( !v3 )
      break;
    *(_WORD *)v3 = 4;
    *(_DWORD *)(v3 + 2) = *v2;
    *(_DWORD *)(v3 + 6) = v2[1];
    qmemcpy(v3 + 10, v2 + 2, v2[1]);
    if ( *a1 )
      (*(void (__thiscall **)(_DWORD, int, int, char *, int, int, int))(*(_DWORD *)*a1 + 148))(
        *a1,
        -268435576,
        a2,
        v3,
        *(_DWORD *)(v3 + 6) + 10,
        98,
        24187);
    j__free(v4);
    v2 = (_DWORD *)sub_10024270((_DWORD **)a1[12]);
    if ( !v2 )
      return 1;
  }
  return 0;
}

//----- (1000B2A0) --------------------------------------------------------
_DWORD *__usercall sub_1000B2A0@<eax>(_DWORD *a1@<ebx>, int a2@<edi>)
{
  _DWORD *v2; // eax
  _DWORD *v3; // esi
  int v4; // eax
  void *v6; // [esp-4h] [ebp-8h]

  v2 = operator new(0x18u);
  v3 = v2;
  if ( !v2 )
    return 0;
  *v2 = 0;
  v2[1] = a2;
  *v2 = 1;
  v4 = (*(int (__thiscall **)(_DWORD, int, _DWORD *, _DWORD *, _DWORD *, _DWORD *))(*(_DWORD *)*a1 + 172))(
         *a1,
         a2,
         v2 + 2,
         v2 + 3,
         v2 + 4,
         v2 + 5);
  v6 = v3;
  if ( !v4 )
  {
LABEL_5:
    j__free(v6);
    return 0;
  }
  if ( (*(int (__thiscall **)(_DWORD *, _DWORD *))a1[2])(a1 + 2, v3) == -1 )
  {
    v6 = v3;
    goto LABEL_5;
  }
  return v3;
}

//----- (1000B300) --------------------------------------------------------
void *__usercall sub_1000B300@<eax>(_DWORD *a1@<edi>, int a2)
{
  _DWORD *v2; // eax
  void *v3; // esi

  v2 = operator new(0x18u);
  v3 = v2;
  if ( !v2 )
    return 0;
  *v2 = 0;
  v2[1] = a1[1];
  *v2 = *a1;
  v2[2] = a1[2];
  v2[3] = a1[3];
  v2[4] = a1[4];
  v2[5] = a1[5];
  if ( (**(int (__thiscall ***)(int, _DWORD *))(a2 + 8))(a2 + 8, v2) == -1 )
  {
    j__free(v3);
    return 0;
  }
  return v3;
}

//----- (1000B360) --------------------------------------------------------
void __usercall sub_1000B360(int a1@<ebx>, int a2@<edi>)
{
  _DWORD *v2; // esi
  _DWORD **v3; // ecx

  v2 = (_DWORD *)sub_10024240(*(_DWORD ***)(a2 + 16));
  if ( v2 )
  {
    while ( 1 )
    {
      v3 = *(_DWORD ***)(a2 + 16);
      if ( v2[1] == a1 )
        break;
      v2 = (_DWORD *)sub_10024270(v3);
      if ( !v2 )
        return;
    }
    sub_100241E0(v3);
    j__free(v2);
  }
}

//----- (1000B3A0) --------------------------------------------------------
int __usercall sub_1000B3A0@<eax>(int a1@<esi>, int a2)
{
  _DWORD *i; // edi
  int v3; // ebx
  _DWORD *v4; // eax

  for ( i = (_DWORD *)sub_10024240(*(_DWORD ***)(a1 + 16)); i; i = (_DWORD *)sub_10024270(*(_DWORD ***)(a1 + 16)) )
  {
    if ( a2 )
    {
      v3 = i[1];
      v4 = (_DWORD *)sub_10024240(*(_DWORD ***)(a1 + 48));
      if ( v4 )
      {
        while ( *v4 != v3 )
        {
          v4 = (_DWORD *)sub_10024270(*(_DWORD ***)(a1 + 48));
          if ( !v4 )
            goto LABEL_8;
        }
        j__free(v4);
        sub_100241E0(*(_DWORD ***)(a1 + 48));
      }
    }
LABEL_8:
    j__free(i);
  }
  return sub_10024200(*(_DWORD ***)(a1 + 16));
}
// 1000B3ED: conditional instruction was optimized away because edi.4!=0

//----- (1000B420) --------------------------------------------------------
int *__usercall sub_1000B420@<eax>(int *a1@<esi>)
{
  int v1; // ecx
  bool v2; // zf
  int *result; // eax
  int v4; // ecx
  int v5; // ecx
  __int16 v6; // [esp+30h] [ebp-20h] BYREF
  int v7[7]; // [esp+32h] [ebp-1Eh] BYREF

  v1 = *a1;
  v2 = *a1 == 0;
  v6 = 1;
  if ( !v2 )
    (*(void (__thiscall **)(int, int, int, __int16 *, int, int, int))(*(_DWORD *)v1 + 148))(
      v1,
      -268435576,
      -268435491,
      &v6,
      2,
      98,
      24187);
  for ( result = (int *)sub_10024240((_DWORD **)a1[4]); result; result = (int *)sub_10024270((_DWORD **)a1[4]) )
  {
    v7[1] = *result;
    v7[2] = result[1];
    v7[3] = result[2];
    v7[4] = result[3];
    v7[5] = result[4];
    v4 = *a1;
    v2 = *a1 == 0;
    v7[6] = result[5];
    HIWORD(v7[0]) = 2;
    if ( !v2 )
      (*(void (__thiscall **)(int, int, int, char *, int, int, int))(*(_DWORD *)v4 + 148))(
        v4,
        -268435576,
        -268435491,
        (char *)v7 + 2,
        26,
        98,
        24187);
  }
  v5 = *a1;
  v2 = *a1 == 0;
  v6 = 3;
  if ( !v2 )
    return (int *)(*(int (__thiscall **)(int, int, int, __int16 *, int, int, int))(*(_DWORD *)v5 + 148))(
                    v5,
                    -268435576,
                    -268435491,
                    &v6,
                    2,
                    98,
                    24187);
  return result;
}

//----- (1000B500) --------------------------------------------------------
int __usercall sub_1000B500@<eax>(int a1@<eax>)
{
  int result; // eax
  int v3; // edi
  int v4; // edx

  if ( !(*(int (__thiscall **)(int))(*(_DWORD *)(a1 + 8) + 96))(a1 + 8) )
    return 0;
  result = sub_10024240(*(_DWORD ***)(a1 + 16));
  v3 = result;
  if ( result )
  {
    while ( *(_DWORD *)result != 2 )
    {
      result = sub_10024270(*(_DWORD ***)(a1 + 16));
      if ( !result )
        goto LABEL_6;
    }
  }
  else
  {
LABEL_6:
    result = v3;
    if ( !v3 )
      return result;
  }
  v4 = **(_DWORD **)(a1 + 4);
  if ( *(_DWORD *)(result + 4) == *(_DWORD *)(a1 + 36) )
    (*(void (**)(void))(v4 + 4))();
  else
    (*(void (__stdcall **)(_DWORD, _DWORD, _DWORD, _DWORD))(v4 + 8))(
      *(_DWORD *)(result + 8),
      *(_DWORD *)(result + 12),
      *(_DWORD *)(result + 16),
      *(_DWORD *)(result + 20));
  return 1;
}

//----- (1000B580) --------------------------------------------------------
unsigned int __thiscall TinCatModules::Reconnector::Init(
        TinCatModules::Reconnector *this,
        struct ITinCatAPI *a2,
        struct TinCatModules::IReconnectorCallbacks *a3)
{
  unsigned int result; // eax

  result = *(_DWORD *)this;
  if ( *(_DWORD *)this )
  {
    if ( a2 && a3 )
    {
      *(_DWORD *)result = a2;
      *(_DWORD *)(*(_DWORD *)this + 4) = a3;
      return 1;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

//----- (1000B5B0) --------------------------------------------------------
void __thiscall TinCatModules::Reconnector::Remove(TinCatModules::Reconnector *this)
{
  if ( *(_DWORD *)this )
  {
    sub_1000B3A0(*(_DWORD *)this, 1);
    *(_DWORD *)(*(_DWORD *)this + 4) = 0;
    **(_DWORD **)this = 0;
    *(_DWORD *)(*(_DWORD *)this + 32) = 0;
    *(_DWORD *)(*(_DWORD *)this + 36) = -1;
  }
}

//----- (1000B5F0) --------------------------------------------------------
unsigned int __thiscall TinCatModules::Reconnector::HandleReceivedData(
        TinCatModules::Reconnector *this,
        unsigned int a2,
        unsigned int a3,
        unsigned __int16 a4,
        unsigned __int16 a5,
        char *a6,
        int a7)
{
  int v7; // esi
  void *i; // eax
  unsigned int result; // eax

  if ( a4 != 98 || a5 != 24187 )
    return 0;
  v7 = *(_DWORD *)this;
  if ( !*(_DWORD *)this || !*(_DWORD *)v7 )
    return 0;
  switch ( *(_WORD *)a6 )
  {
    case 1:
      for ( i = (void *)sub_10024240(*(_DWORD ***)(v7 + 16)); i; i = (void *)sub_10024270(*(_DWORD ***)(v7 + 16)) )
        j__free(i);
      sub_10024200(*(_DWORD ***)(v7 + 16));
      result = 0;
      break;
    case 2:
      sub_1000B300(a6 + 2, v7);
      result = 0;
      break;
    case 4:
      sub_1000B150(*(_DWORD *)(a6 + 6), *(_DWORD *)(a6 + 2), v7, a6 + 10);
      return 0;
    default:
      return 0;
  }
  return result;
}

//----- (1000B6A0) --------------------------------------------------------
unsigned int __thiscall TinCatModules::Reconnector::HandleAddedConnection(int **this, int a2)
{
  int *v3; // eax
  int v4; // eax
  int *v5; // ebx
  unsigned int result; // eax

  v3 = *this;
  if ( !*this || !*v3 )
    return 0;
  v4 = (*(int (__thiscall **)(int))(*(_DWORD *)*v3 + 88))(*v3);
  if ( !(*this)[8] && v4 == 1 )
    (*this)[8] = 1;
  v5 = *this;
  if ( (*this)[8] )
  {
    result = (unsigned int)sub_1000B2A0(v5, a2);
    if ( result )
    {
      sub_1000B420(*this);
      sub_1000B1F0(*this, a2);
      return 1;
    }
  }
  else
  {
    v5[9] = a2;
    return 1;
  }
  return result;
}

//----- (1000B740) --------------------------------------------------------
BOOL __thiscall TinCatModules::Reconnector::HandleRemovedConnection(int **this, int a2)
{
  int *v3; // eax
  int v4; // eax

  v3 = *this;
  if ( !*this || !*v3 )
    return 0;
  (*(void (__thiscall **)(int))(*(_DWORD *)*v3 + 88))(*v3);
  v4 = (int)*this;
  if ( (*this)[8] )
  {
    sub_1000B360(a2, v4);
    sub_1000B420(*this);
    return 1;
  }
  return sub_1000B500(v4) != 0;
}

//----- (1000B7A0) --------------------------------------------------------
int __thiscall TinCatModules::Reconnector::SetPreferredNextServer(int **this, unsigned int a2)
{
  int *v3; // eax
  int v4; // edi
  _DWORD *i; // eax

  v3 = *this;
  v4 = 0;
  if ( !*this || !*v3 || !v3[8] )
    return 0;
  for ( i = (_DWORD *)sub_10024240((_DWORD **)v3[4]); i; i = (_DWORD *)sub_10024270((_DWORD **)(*this)[4]) )
  {
    if ( i[1] == a2 )
    {
      *i = 2;
      v4 = 1;
    }
    else
    {
      *i = 1;
    }
  }
  sub_1000B420(*this);
  return v4;
}

//----- (1000B810) --------------------------------------------------------
char *__thiscall TinCatModules::Reconnector::SetUserData(
        TinCatModules::Reconnector *this,
        int a2,
        void *a3,
        unsigned int a4)
{
  char *result; // eax
  char *v5; // ebx
  int v6; // ecx

  result = (char *)operator new(a4 + 10);
  v5 = result;
  if ( result )
  {
    *(_DWORD *)(result + 2) = a2;
    *(_WORD *)result = 4;
    *(_DWORD *)(result + 6) = a4;
    qmemcpy(result + 10, a3, a4);
    v6 = **(_DWORD **)this;
    if ( v6 )
      (*(void (__thiscall **)(int, int, int, char *, int, int, int))(*(_DWORD *)v6 + 148))(
        v6,
        -268435576,
        -268435491,
        result,
        *(_DWORD *)(result + 6) + 10,
        98,
        24187);
    j__free(v5);
    return (char *)(sub_1000B150(a4, a2, *(_DWORD *)this, a3) != 0);
  }
  return result;
}

//----- (1000B8C0) --------------------------------------------------------
_DWORD *__thiscall TinCatModules::Reconnector::GetUserData(TinCatModules::Reconnector *this, unsigned int a2)
{
  _DWORD *v3; // eax

  v3 = (_DWORD *)sub_10024240(*(_DWORD ***)(*(_DWORD *)this + 48));
  if ( !v3 )
    return 0;
  while ( *v3 != a2 )
  {
    v3 = (_DWORD *)sub_10024270(*(_DWORD ***)(*(_DWORD *)this + 48));
    if ( !v3 )
      return 0;
  }
  return v3 + 2;
}

//----- (1000B900) --------------------------------------------------------
TinCatModules::Reconnector *__thiscall TinCatModules::Reconnector::Reconnector(TinCatModules::Reconnector *this)
{
  char *v2; // eax
  char *v3; // edi
  TinCatModules::Reconnector *result; // eax

  v2 = (char *)operator new(0x40u);
  v3 = v2;
  if ( v2 )
  {
    sub_10024FE0((DNameNode *)(v2 + 8));
    sub_10024FE0((DNameNode *)(v3 + 40));
  }
  else
  {
    v3 = 0;
  }
  *(_DWORD *)this = v3;
  *((_DWORD *)v3 + 8) = 0;
  *(_DWORD *)(*(_DWORD *)this + 4) = 0;
  **(_DWORD **)this = 0;
  result = this;
  *(_DWORD *)(*(_DWORD *)this + 36) = -1;
  return result;
}

//----- (1000B950) --------------------------------------------------------
void __thiscall TinCatModules::Reconnector::~Reconnector(TinCatModules::Reconnector *this)
{
  _DWORD *v2; // esi

  if ( *(_DWORD *)this )
  {
    sub_1000B3A0(*(_DWORD *)this, 1);
    *(_DWORD *)(*(_DWORD *)this + 4) = 0;
    **(_DWORD **)this = 0;
    *(_DWORD *)(*(_DWORD *)this + 32) = 0;
    *(_DWORD *)(*(_DWORD *)this + 36) = -1;
    v2 = *(_DWORD **)this;
    if ( *(_DWORD *)this )
    {
      sub_10025B40(v2 + 10);
      sub_10025B40(v2 + 2);
      j__free(v2);
      *(_DWORD *)this = 0;
    }
  }
}

//----- (1000B9B0) --------------------------------------------------------
int __cdecl sub_1000B9B0(int a1)
{
  int result; // eax

  result = a1;
  if ( a1 )
  {
    *(_DWORD *)a1 = 0;
    *(_BYTE *)(a1 + 16) = 0;
    *(_BYTE *)(a1 + 1040) = 0;
  }
  return result;
}

//----- (1000B9D0) --------------------------------------------------------
_DWORD *__cdecl sub_1000B9D0(_DWORD *a1, int a2)
{
  _DWORD *result; // eax

  result = a1;
  if ( a1 )
    *a1 = a2;
  return result;
}

//----- (1000B9E0) --------------------------------------------------------
int __cdecl sub_1000B9E0(int a1)
{
  int result; // eax

  result = a1;
  if ( a1 )
    return *(_DWORD *)a1;
  return result;
}

//----- (1000B9F0) --------------------------------------------------------
int __cdecl sub_1000B9F0(int a1, int a2)
{
  int result; // eax

  result = a1;
  if ( a1 )
  {
    *(_BYTE *)(a1 + 16) = 0;
    *(_BYTE *)(a1 + 1040) = 0;
    *(_DWORD *)a1 = a2;
  }
  return result;
}

//----- (1000BA10) --------------------------------------------------------
int __cdecl sub_1000BA10(int a1, int a2, int a3, int a4)
{
  if ( !a1 )
    return 0;
  *(_DWORD *)a1 = 0;
  *(_BYTE *)(a1 + 16) = 0;
  *(_BYTE *)(a1 + 1040) = 0;
  *(_DWORD *)(a1 + 4) = a2;
  *(_DWORD *)(a1 + 8) = a3;
  *(_DWORD *)(a1 + 12) = a4;
  return 1;
}

//----- (1000BA50) --------------------------------------------------------
__int16 __cdecl sub_1000BA50(int a1)
{
  __int16 result; // ax
  int v2; // eax

  if ( (dword_1004CA9C & 1) != 0 )
  {
    sub_1000C6F0(0, 8, "%s:%s : MEMORY SYSTEM ALREADY INITIALIZED !", aBaselibMem, aBlInitmemsyste);
    return 0;
  }
  else
  {
    if ( dword_1004CA94 )
      sub_1000C6F0(0, 8, "%s:%s : DIRTY MEMORY SYSTEM REINITIALIZED !", aBaselibMem, aBlInitmemsyste);
    v2 = dword_1004CA9C;
    if ( (dword_1004CA9C & 2) == 0 )
      v2 = a1;
    dword_1004CA9C = v2 & 0xFFFFFFFE;
    result = sub_1000E050((int)dword_1004CAA0, 2);
    if ( result != -1 )
    {
      dword_1004CA9C |= 1u;
      dword_1004CA98 = dword_1004CA94;
      return 0;
    }
  }
  return result;
}
// 1004CA94: using guessed type int dword_1004CA94;
// 1004CA98: using guessed type int dword_1004CA98;
// 1004CA9C: using guessed type int dword_1004CA9C;
// 1004CAA0: using guessed type HANDLE dword_1004CAA0[2];

//----- (1000BAF0) --------------------------------------------------------
__int16 sub_1000BAF0()
{
  if ( (dword_1004CA9C & 1) != 0 )
  {
    sub_1000E170(dword_1004CAA0, 0);
    dword_1004CA9C &= ~1u;
    return 0;
  }
  else
  {
    sub_1000C6F0(0, 16, "%s:%s : MEMORY SYSTEM NOT INITIALIZED !", aBaselibMem, aBlExitmemsyste);
    return -1;
  }
}
// 1004CA9C: using guessed type int dword_1004CA9C;
// 1004CAA0: using guessed type HANDLE dword_1004CAA0[2];

//----- (1000BB40) --------------------------------------------------------
void *__cdecl sub_1000BB40(signed int Size)
{
  size_t v1; // edi
  void *v2; // esi

  v1 = Size;
  if ( Size < 1 )
    v1 = 1;
  if ( (dword_1004CA9C & 1) != 0
    || (sub_1000C6F0(0, 8, "%s:%s : MEMORY SYSTEM NOT INITIALIZED !", aBaselibMem, aBlOrggetmem),
        (dword_1004CA9C & 1) != 0) )
  {
    sub_1000E090((int)dword_1004CAA0, 0xFFFFFFFF);
  }
  v2 = malloc(v1);
  if ( v2 )
  {
    sub_1000E0E0((int)dword_1004CAA0);
    return v2;
  }
  else
  {
    sub_1000C6F0(0, 16, "%s:%s : CANNOT ALLOC DOS MEMORY (SIZE: %ld) !", aBaselibMem, aBlOrggetmem, v1);
    if ( (dword_1004CA9C & 1) != 0 )
      sub_1000E0E0((int)dword_1004CAA0);
    return 0;
  }
}
// 1004CA9C: using guessed type int dword_1004CA9C;
// 1004CAA0: using guessed type HANDLE dword_1004CAA0[2];

//----- (1000BBF0) --------------------------------------------------------
__int16 __cdecl sub_1000BBF0(void *Block)
{
  if ( (dword_1004CA9C & 1) != 0
    || (sub_1000C6F0(0, 8, "%s:%s : MEMORY SYSTEM NOT INITIALIZED !", aBaselibMem, aBlOrgfreemem),
        (dword_1004CA9C & 1) != 0) )
  {
    sub_1000E090((int)dword_1004CAA0, 0xFFFFFFFF);
  }
  free(Block);
  if ( (dword_1004CA9C & 1) != 0 )
    sub_1000E0E0((int)dword_1004CAA0);
  return 0;
}
// 1004CA9C: using guessed type int dword_1004CA9C;
// 1004CAA0: using guessed type HANDLE dword_1004CAA0[2];

//----- (1000BC60) --------------------------------------------------------
void __cdecl sub_1000BC60(_BYTE *a1, _BYTE *a2, int a3)
{
  int v3; // esi

  v3 = a3;
  if ( a3 > 0 )
  {
    do
    {
      *a2++ = *a1++;
      --v3;
    }
    while ( v3 );
  }
}

//----- (1000BC80) --------------------------------------------------------
__int16 __usercall sub_1000BC80@<ax>(int a1@<ebx>, char *a2, char a3, unsigned int a4)
{
  int v4; // eax

  LOBYTE(a1) = a3;
  BYTE1(a1) = a3;
  v4 = a1 << 16;
  LOWORD(v4) = a1;
  memset32(a2, v4, a4 >> 2);
  memset(&a2[4 * (a4 >> 2)], a3, a4 & 3);
  return v4;
}

//----- (1000BCB0) --------------------------------------------------------
__int16 __cdecl sub_1000BCB0(void *a1)
{
  if ( !a1 )
    return -1;
  qmemcpy(a1, &unk_1004CAA8, 0x20u);
  return 0;
}

//----- (1000BCE0) --------------------------------------------------------
int __cdecl sub_1000BCE0(_BYTE *Block, int a2, char *a3, int a4, __int16 a5)
{
  _BYTE *v5; // edi
  int result; // eax
  _BYTE *v7; // eax
  char *v8; // ecx
  int v9; // esi

  v5 = sub_1000BB40(a2 + a4);
  result = 0;
  if ( v5 )
  {
    if ( a2 > 0 )
    {
      do
      {
        v5[result] = Block[result];
        ++result;
      }
      while ( result < a2 );
    }
    v7 = &v5[a2];
    if ( a4 > 0 )
    {
      v8 = (char *)(a3 - v7);
      v9 = a4;
      do
      {
        *v7 = v7[(_DWORD)v8];
        ++v7;
        --v9;
      }
      while ( v9 );
    }
    if ( a5 )
    {
      sub_1000BBF0(Block);
      sub_1000BBF0(a3);
    }
    return (int)v5;
  }
  return result;
}

//----- (1000BD50) --------------------------------------------------------
int __thiscall sub_1000BD50(char *this)
{
  int v2; // edx
  int v3; // esi
  int v4; // eax
  char *v5; // eax
  int v6; // esi
  int v7; // edx

  if ( !this )
    return -1;
  v2 = *((_DWORD *)this + 3);
  v3 = *((_DWORD *)this + 4);
  v4 = *(_DWORD *)this ^ v3 ^ v2 ^ *((_DWORD *)this + 1) ^ *((_DWORD *)this + 2) ^ *((_DWORD *)this + 6) ^ *((_DWORD *)this + 7);
  if ( !v4 )
    v4 = -1;
  if ( v4 != *((_DWORD *)this + 5) )
    return -2;
  if ( (v2 & 0x10) == 0 )
    return 0;
  v5 = &this[v3 + 48];
  v6 = 0;
  v7 = this + 32 - v5;
  while ( *(_DWORD *)&v5[v7] == -858993460 )
  {
    if ( *(_DWORD *)v5 != -858993460 )
      return -5;
    v6 += 4;
    v5 += 4;
    if ( v6 >= 16 )
      return 0;
  }
  if ( *(_DWORD *)v5 == -858993460 )
    return -4;
  else
    return -3;
}
// 1000BDB9: conditional instruction was optimized away because ecx.4!=CCCCCCCC

//----- (1000BDF0) --------------------------------------------------------
int __cdecl sub_1000BDF0(int (__cdecl *a1)(char *))
{
  int result; // eax
  int v2; // esi
  int v3; // edi
  int v4; // eax
  char Buffer[253]; // [esp+10h] [ebp-100h] BYREF
  __int16 v6; // [esp+10Dh] [ebp-3h]
  char v7; // [esp+10Fh] [ebp-1h]

  result = 0;
  memset(Buffer, 0, sizeof(Buffer));
  v6 = 0;
  v7 = 0;
  if ( a1 )
  {
    v2 = dword_1004CA94;
    if ( dword_1004CA94 )
    {
      while ( 1 )
      {
        v3 = v2 + 48;
        if ( (dword_1004CA9C & 0x20) == 0 )
          v3 = v2 + 32;
        v4 = sub_1000BD50((char *)v2);
        if ( v4 )
          break;
        result = *(_DWORD *)(v2 + 28);
        if ( result )
        {
          sprintf(
            Buffer,
            "ADR: 0x%08X LEN: %9ld FILE: %s(%u)",
            v3,
            *(_DWORD *)(v2 + 16),
            *(const char **)(v2 + 24),
            *(_DWORD *)(v2 + 28));
          result = a1(Buffer);
        }
        v2 = *(_DWORD *)(v2 + 4);
        if ( !v2 )
          return result;
      }
      sprintf(Buffer, "%s : CORRUPTED MEMORY BLOCK HEADER (ERROR: %d) !", aBaselibMem, v4);
      return a1(Buffer);
    }
  }
  return result;
}
// 1004CA94: using guessed type int dword_1004CA94;
// 1004CA9C: using guessed type int dword_1004CA9C;

//----- (1000BEB0) --------------------------------------------------------
_DWORD *__cdecl sub_1000BEB0(int a1, _BYTE *a2, const char *a3)
{
  _DWORD *v3; // esi
  _DWORD *v4; // eax
  unsigned int v6; // eax
  __int16 v7; // cx
  char *v8; // eax
  __int16 v9; // ax

  v3 = sub_1000BB40(424);
  if ( !v3 )
    return 0;
  v4 = sub_1000E120(2);
  v3[1] = v4;
  if ( !v4 )
  {
    sub_1000BBF0(v3);
    return 0;
  }
  v6 = (unsigned int)a2;
  v7 = a1;
  v3[2] = 255;
  v3[3] = -1;
  v3[4] = a2;
  *v3 = a1;
  v3[103] = 0;
  v3[104] = 0;
  if ( a3 )
  {
    v8 = (char *)sub_1000BB40(strlen(a3) + 1);
    v3[5] = v8;
    if ( !v8 )
    {
LABEL_7:
      sub_1000E1E0((HANDLE *)v3[1]);
      sub_1000BBF0(v3);
      return 0;
    }
    strcpy(v8, a3);
    v7 = a1;
    *v3 |= 0x1000u;
    v6 = (unsigned int)a2;
  }
  if ( (v7 & 0xC) == 0 )
    *v3 |= 4u;
  if ( (v7 & 0xE0) == 0 )
    *v3 |= 0x20u;
  if ( word_1004CAD4 == 1 )
  {
    v6 &= ~4u;
    LOBYTE(a2) = v6;
    v3[4] = v6;
  }
  if ( (v6 & 0x10) != 0 )
  {
    v6 = (unsigned int)sub_1000BB40(0x800000);
    v3[103] = v6;
    if ( !v6 )
      goto LABEL_7;
    HIBYTE(v7) = BYTE1(a1);
    v3[104] = 0;
    *(_BYTE *)v6 = 0;
    LOBYTE(v6) = (_BYTE)a2;
  }
  if ( (v6 & 4) != 0 )
  {
    if ( !a3 )
      v3[5] = aLogfileTxt;
    if ( (v7 & 0x400) != 0 )
      v9 = sub_1000E4F0((char *)v3[5], 8);
    else
      v9 = sub_1000E4F0((char *)v3[5], 4);
    *((_WORD *)v3 + 12) = v9;
    if ( v9 == -1 )
      goto LABEL_7;
    if ( (a1 & 0x800) != 0 )
    {
      sub_1000E620(v9);
      *((_WORD *)v3 + 12) = -1;
    }
  }
  return v3;
}
// 1004CAD4: using guessed type __int16 word_1004CAD4;

//----- (1000C030) --------------------------------------------------------
_DWORD *__cdecl sub_1000C030(_DWORD *a1)
{
  _DWORD *result; // eax

  result = a1;
  dword_1004CAC8 = (int)a1;
  *a1 |= 0x200u;
  return result;
}
// 1004CAC8: using guessed type int dword_1004CAC8;

//----- (1000C040) --------------------------------------------------------
_BYTE *__cdecl sub_1000C040(_BYTE *a1, int a2)
{
  char *v2; // ebx

  v2 = a1 + 26;
  a1[26] = 0;
  if ( (*a1 & 0x10) == 0 )
    strcat(v2, &aDebug[16 * sub_1000E9D0(a2)]);
  if ( (*a1 & 0x20) == 0 )
  {
    strcat(v2, asc_10049600);
    sub_1000DDC0(a1 + 282);
    strcat(v2, a1 + 282);
    strcat(v2, ") ");
  }
  return a1 + 26;
}

//----- (1000C150) --------------------------------------------------------
int __cdecl sub_1000C150(int a1)
{
  int result; // eax

  result = a1;
  if ( !a1 )
    return dword_1004CAC8;
  return result;
}
// 1004CAC8: using guessed type int dword_1004CAC8;

//----- (1000C160) --------------------------------------------------------
void sub_1000C160()
{
  word_1004CAD0 = 1;
}
// 1004CAD0: using guessed type __int16 word_1004CAD0;

//----- (1000C170) --------------------------------------------------------
void sub_1000C170()
{
  word_1004CAD0 = 0;
}
// 1004CAD0: using guessed type __int16 word_1004CAD0;

//----- (1000C180) --------------------------------------------------------
void sub_1000C180()
{
  word_1004CAD4 = 1;
}
// 1004CAD4: using guessed type __int16 word_1004CAD4;

//----- (1000C190) --------------------------------------------------------
void sub_1000C190()
{
  word_1004CAD4 = 0;
}
// 1004CAD4: using guessed type __int16 word_1004CAD4;

//----- (1000C1A0) --------------------------------------------------------
void __cdecl sub_1000C1A0(int a1)
{
  __int16 v1; // ax
  unsigned int v2; // eax
  char *v3; // edi
  const CHAR *v5; // edx
  char Buffer[15]; // [esp+4h] [ebp-110h] BYREF
  char v7; // [esp+13h] [ebp-101h] BYREF
  char Destination[256]; // [esp+14h] [ebp-100h] BYREF

  if ( a1 )
  {
    sub_1000E090(*(_DWORD *)(a1 + 4), 0xFFFFFFFF);
    if ( (*(_BYTE *)(a1 + 16) & 4) != 0 )
    {
      v1 = *(_WORD *)(a1 + 24);
      if ( v1 >= 0 )
      {
        sub_1000E620(v1);
        *(_WORD *)(a1 + 24) = -1;
      }
    }
    sub_1000DF80(Buffer);
    strncpy(Destination, *(const char **)(a1 + 20), 0xF0u);
    Destination[240] = 0;
    v7 = 0;
    v2 = strlen(Buffer) + 1;
    v3 = &v7;
    while ( *++v3 )
      ;
    v5 = *(const CHAR **)(a1 + 20);
    qmemcpy(v3, Buffer, v2);
    sub_1000E8B0(v5, Destination);
    if ( (*(_BYTE *)(a1 + 16) & 4) != 0 && (*(_DWORD *)a1 & 0x800) == 0 )
      *(_WORD *)(a1 + 24) = sub_1000E4F0(*(char **)(a1 + 20), 8);
    sub_1000E0E0(*(_DWORD *)(a1 + 4));
  }
}

//----- (1000C290) --------------------------------------------------------
void __cdecl sub_1000C290(int a1)
{
  __int16 v1; // ax
  __int16 v2; // di
  _BYTE *v3; // eax

  if ( a1 && *(_DWORD *)(a1 + 412) && *(_DWORD *)(a1 + 416) )
  {
    v1 = sub_1000E4F0(*(char **)(a1 + 20), 4);
    v2 = v1;
    if ( v1 >= 0 )
    {
      sub_1000E780(v1, *(void **)(a1 + 412), *(_DWORD *)(a1 + 416));
      sub_1000E620(v2);
    }
    v3 = *(_BYTE **)(a1 + 412);
    *(_DWORD *)(a1 + 416) = 0;
    *v3 = 0;
  }
}

//----- (1000C300) --------------------------------------------------------
__int16 __cdecl sub_1000C300(void *Block)
{
  if ( !Block )
    return -1;
  if ( Block == (void *)dword_1004CAC8 )
    dword_1004CAC8 = 0;
  sub_1000E090(*((_DWORD *)Block + 1), 0xFFFFFFFF);
  if ( (*((_BYTE *)Block + 16) & 4) != 0 )
  {
    sub_1000C290((int)Block);
    if ( *((_DWORD *)Block + 103) )
      sub_1000BBF0(*((void **)Block + 103));
    *((_DWORD *)Block + 103) = 0;
  }
  if ( (*(_DWORD *)Block & 0x1000) != 0 )
  {
    if ( *((_DWORD *)Block + 5) )
      sub_1000BBF0(*((void **)Block + 5));
    *((_DWORD *)Block + 5) = 0;
  }
  if ( (*((_BYTE *)Block + 16) & 4) != 0 && (*(_DWORD *)Block & 0x800) == 0 )
  {
    sub_1000E620(*((_WORD *)Block + 12));
    *((_WORD *)Block + 12) = -1;
  }
  sub_1000E0E0(*((_DWORD *)Block + 1));
  if ( (unsigned __int16)sub_1000E1E0(*((HANDLE **)Block + 1)) == 0xFFFF )
    return -1;
  sub_1000BBF0(Block);
  return 0;
}
// 1004CAC8: using guessed type int dword_1004CAC8;

//----- (1000C3D0) --------------------------------------------------------
__int16 __cdecl sub_1000C3D0(int a1, int a2, void *Buf)
{
  __int16 result; // ax
  _BYTE *v4; // eax
  char *v5; // edx

  if ( (*(_DWORD *)a1 & 0x800) == 0
    || (result = sub_1000E4F0(*(char **)(a1 + 20), 4), *(_WORD *)(a1 + 24) = result, result != -1) )
  {
    if ( word_1004CACC > 0 )
    {
      sprintf(::Buf, "%*c", word_1004CACC, 32);
      sub_1000E780(*(_WORD *)(a1 + 24), ::Buf, strlen(::Buf));
    }
    v4 = sub_1000C040((_BYTE *)a1, a2);
    if ( (*(_BYTE *)a1 & 0x10) == 0 && v4 )
      sub_1000E780(*(_WORD *)(a1 + 24), v4, strlen(v4));
    sub_1000E780(*(_WORD *)(a1 + 24), Buf, strlen((const char *)Buf));
    v5 = asc_10049574;
    if ( (*(_BYTE *)a1 & 4) == 0 )
      v5 = asc_10049578;
    sub_1000E780(*(_WORD *)(a1 + 24), v5, strlen(v5));
    if ( (*(_DWORD *)a1 & 0x800) != 0 )
    {
      sub_1000E620(*(_WORD *)(a1 + 24));
      *(_WORD *)(a1 + 24) = -1;
    }
    return 0;
  }
  return result;
}
// 1004CACC: using guessed type __int16 word_1004CACC;

//----- (1000C4F0) --------------------------------------------------------
void __cdecl sub_1000C4F0(int a1, int a2, const char *a3)
{
  unsigned int v3; // ebp
  int v4; // eax
  int v5; // ecx
  unsigned int v6; // eax

  if ( a1 && a3 && *(_DWORD *)(a1 + 412) )
  {
    v3 = strlen(a3);
    if ( v3 + *(_DWORD *)(a1 + 416) > 0x800000 )
      sub_1000C290(a1);
    v4 = *(_DWORD *)(a1 + 416);
    if ( v4 + v3 <= 0x800000 )
    {
      qmemcpy((void *)(v4 + *(_DWORD *)(a1 + 412)), a3, v3);
      v5 = *(_DWORD *)(a1 + 412);
      v6 = v3 + *(_DWORD *)(a1 + 416);
      *(_DWORD *)(a1 + 416) = v6;
      *(_BYTE *)(v6 + v5) = 0;
    }
  }
}

//----- (1000C580) --------------------------------------------------------
__int16 __cdecl sub_1000C580(int a1, int a2, char *a3)
{
  __int16 v3; // bp
  const char *v4; // eax
  void (__cdecl *v5)(char *); // esi

  v3 = 0;
  if ( (*(_BYTE *)(a1 + 16) & 8) != 0 )
  {
    v4 = sub_1000C040((_BYTE *)a1, a2);
    if ( (*(_BYTE *)a1 & 0x10) == 0 && v4 )
      printf("%s", v4);
    printf("%s\n", a3);
  }
  if ( (*(_BYTE *)(a1 + 16) & 0x10) != 0 )
    sub_1000C4F0(a1, a2, a3);
  if ( (*(_BYTE *)(a1 + 16) & 4) != 0 && sub_1000C3D0(a1, a2, a3) )
    v3 = -1;
  if ( (*(_BYTE *)(a1 + 16) & 2) != 0 )
  {
    v5 = *(void (__cdecl **)(char *))(a1 + 420);
    if ( v5 )
      v5(a3);
  }
  return v3;
}

//----- (1000C620) --------------------------------------------------------
__int16 __cdecl sub_1000C620(int a1, int a2, int a3, char *a4)
{
  int v4; // esi
  __int16 v6; // di

  v4 = a1;
  if ( !a1 )
  {
    v4 = dword_1004CAC8;
    if ( !dword_1004CAC8 )
      return -1;
  }
  if ( word_1004CAD0 == 1 )
    return 0;
  sub_1000E090(*(_DWORD *)(v4 + 4), 0xFFFFFFFF);
  if ( (*(_BYTE *)v4 & 1) != 0 )
    goto LABEL_9;
  if ( (a3 & *(_DWORD *)(v4 + 12)) == 0 )
  {
    sub_1000E0E0(*(_DWORD *)(v4 + 4));
    return 0;
  }
  if ( (a2 & *(_DWORD *)(v4 + 8)) == 0 )
  {
LABEL_9:
    sub_1000E0E0(*(_DWORD *)(v4 + 4));
    return 0;
  }
  v6 = sub_1000C580(v4, a2, a4);
  sub_1000E0E0(*(_DWORD *)(v4 + 4));
  return v6;
}
// 1004CAC8: using guessed type int dword_1004CAC8;
// 1004CAD0: using guessed type __int16 word_1004CAD0;

//----- (1000C6B0) --------------------------------------------------------
__int16 __cdecl sub_1000C6B0(int a1, int a2, char *a3)
{
  return sub_1000C620(a1, a2, -1, a3);
}

//----- (1000C6D0) --------------------------------------------------------
__int16 __cdecl sub_1000C6D0(int a1, char *a2)
{
  return sub_1000C620(a1, 64, -1, a2);
}

//----- (1000C6F0) --------------------------------------------------------
__int16 sub_1000C6F0(int a1, int a2, char *Format, ...)
{
  va_list va; // [esp+10h] [ebp+10h] BYREF

  va_start(va, Format);
  vsprintf(byte_1004D6E0, Format, va);
  return sub_1000C620(a1, a2, -1, byte_1004D6E0);
}

//----- (1000C720) --------------------------------------------------------
__int16 sub_1000C720(char *Format, ...)
{
  __int16 result; // ax
  int v2; // esi
  int *v3; // edi
  va_list ArgList; // [esp+Ch] [ebp+8h] BYREF

  va_start(ArgList, Format);
  result = vsprintf(byte_1004D6E0, Format, ArgList);
  v2 = dword_1004CAC8;
  if ( dword_1004CAC8 && word_1004CAD0 != 1 )
  {
    v3 = (int *)(dword_1004CAC8 + 4);
    sub_1000E090(*(_DWORD *)(dword_1004CAC8 + 4), 0xFFFFFFFF);
    if ( (*(_BYTE *)v2 & 1) == 0 && *(_DWORD *)(v2 + 12) && (*(_BYTE *)(v2 + 8) & 4) != 0 )
    {
      sub_1000C580(v2, 4, byte_1004D6E0);
      return sub_1000E0E0(*v3);
    }
    else
    {
      return sub_1000E0E0(*v3);
    }
  }
  return result;
}
// 1004CAC8: using guessed type int dword_1004CAC8;
// 1004CAD0: using guessed type __int16 word_1004CAD0;

//----- (1000C7C0) --------------------------------------------------------
__int16 sub_1000C7C0(char *Format, ...)
{
  __int16 result; // ax
  int v2; // esi
  int *v3; // edi
  va_list ArgList; // [esp+Ch] [ebp+8h] BYREF

  va_start(ArgList, Format);
  result = vsprintf(byte_1004D6E0, Format, ArgList);
  v2 = dword_1004CAC8;
  if ( dword_1004CAC8 && word_1004CAD0 != 1 )
  {
    v3 = (int *)(dword_1004CAC8 + 4);
    sub_1000E090(*(_DWORD *)(dword_1004CAC8 + 4), 0xFFFFFFFF);
    if ( (*(_BYTE *)v2 & 1) == 0 && *(_DWORD *)(v2 + 12) && (*(_BYTE *)(v2 + 8) & 0x10) != 0 )
    {
      sub_1000C580(v2, 16, byte_1004D6E0);
      return sub_1000E0E0(*v3);
    }
    else
    {
      return sub_1000E0E0(*v3);
    }
  }
  return result;
}
// 1004CAC8: using guessed type int dword_1004CAC8;
// 1004CAD0: using guessed type __int16 word_1004CAD0;

//----- (1000C860) --------------------------------------------------------
_DWORD *sub_1000C860()
{
  _DWORD *v0; // esi
  _DWORD *v1; // eax

  v0 = sub_1000BB40(16);
  if ( !v0 )
    return 0;
  v1 = sub_1000E120(2);
  *v0 = v1;
  if ( !v1 )
  {
    sub_1000BBF0(v0);
    return 0;
  }
  v0[2] = 0;
  v0[1] = 0;
  return v0;
}

//----- (1000C8A0) --------------------------------------------------------
__int16 __cdecl sub_1000C8A0(HANDLE **Block)
{
  __int16 result; // ax

  result = sub_1000E1E0(*Block);
  if ( result != -1 )
  {
    *Block = 0;
    sub_1000BBF0(Block);
    return 0;
  }
  return result;
}

//----- (1000C8D0) --------------------------------------------------------
__int16 __cdecl sub_1000C8D0(int a1, int a2, __int16 a3)
{
  int v3; // edx
  int v5; // ecx
  int v6; // [esp-4h] [ebp-8h]

  sub_1000E090(*(_DWORD *)a1, 0xFFFFFFFF);
  if ( a3 == 1 )
  {
    v3 = *(_DWORD *)(a1 + 4);
    *(_WORD *)(a1 + 12) = 1;
    v6 = *(_DWORD *)a1;
    *(_DWORD *)(a1 + 4) = a2 | v3;
  }
  else
  {
    v5 = *(_DWORD *)(a1 + 8);
    *(_WORD *)(a1 + 12) = 1;
    v6 = *(_DWORD *)a1;
    *(_DWORD *)(a1 + 8) = a2 | v5;
  }
  return sub_1000E0E0(v6);
}

//----- (1000C930) --------------------------------------------------------
int __cdecl sub_1000C930(int a1, __int16 a2)
{
  int v2; // edi
  int v4; // [esp-4h] [ebp-Ch]

  sub_1000E090(*(_DWORD *)a1, 0xFFFFFFFF);
  if ( a2 == 1 )
  {
    v2 = *(_DWORD *)(a1 + 8);
    v4 = *(_DWORD *)a1;
    *(_DWORD *)(a1 + 8) = 0;
  }
  else
  {
    v2 = *(_DWORD *)(a1 + 4);
    v4 = *(_DWORD *)a1;
    *(_DWORD *)(a1 + 4) = 0;
  }
  *(_WORD *)(a1 + 12) = 0;
  sub_1000E0E0(v4);
  return v2;
}

//----- (1000C990) --------------------------------------------------------
__int16 __cdecl sub_1000C990(int a1, int a2, int a3, char a4)
{
  int Error; // eax
  __int16 v5; // si

  Error = a1;
  if ( !a1 )
    Error = WSAGetLastError();
  v5 = 0;
  while ( Error != dword_10049634[17 * v5] )
  {
    if ( ++v5 >= 42 )
    {
      sub_1000C620(a2, 16, a3, "NET_ReportError: Unknown error code. Sorry.");
      return 0;
    }
  }
  if ( (a4 & 1) != 0 )
  {
    if ( a2 )
      sub_1000C620(a2, 16, a3, &aWsaSystemNotIn[68 * v5]);
  }
  return word_10049630[34 * v5];
}
// 10049630: using guessed type __int16 word_10049630[];
// 10049634: using guessed type int dword_10049634[];

//----- (1000CA10) --------------------------------------------------------
struct WSAData *__cdecl sub_1000CA10(WORD a1, int a2)
{
  struct WSAData *v2; // eax
  struct WSAData *v3; // esi

  v2 = (struct WSAData *)sub_1000BB40(412);
  v3 = v2;
  if ( !v2 )
    return 0;
  if ( WSAStartup(0x101u, v2) )
  {
    sub_1000C620(a2, 16, -1, "NET_Init: Cannot get WSA !");
    sub_1000BBF0(v3);
    return 0;
  }
  v3[1].wVersion = a1;
  *(_DWORD *)v3[1].szDescription = a2;
  *(_DWORD *)&v3[1].szDescription[4] = -1;
  return v3;
}

//----- (1000CA80) --------------------------------------------------------
__int16 __cdecl sub_1000CA80(void *Block)
{
  WSACleanup();
  sub_1000BBF0(Block);
  return 0;
}

//----- (1000CAA0) --------------------------------------------------------
_DWORD *__cdecl sub_1000CAA0(int a1, int a2)
{
  _DWORD *result; // eax

  result = sub_1000BB40(48);
  if ( result )
  {
    result[1] = a1;
    result[2] = a2;
    result[3] = -625280017;
    result[8] = a2;
  }
  return result;
}

//----- (1000CAD0) --------------------------------------------------------
__int16 __cdecl sub_1000CAD0(void **Block)
{
  if ( Block[1] )
    sub_1000BBF0(Block[1]);
  return sub_1000BBF0(Block);
}

//----- (1000CAF0) --------------------------------------------------------
__int16 __cdecl sub_1000CAF0(SOCKET s, char *buf, int a3, int len, int a5)
{
  int v5; // esi
  int v7; // eax
  int v8; // eax

  v5 = a3;
  if ( a3 <= 0 )
    return 0;
  while ( 1 )
  {
    v7 = len;
    if ( v5 <= len )
      v7 = v5;
    v8 = send(s, buf, v7, 0);
    if ( v8 == -1 )
      break;
    if ( v8 <= 0 )
      return -1;
    v5 -= v8;
    buf += v8;
    if ( v5 <= 0 )
      return 0;
  }
  sub_1000C990(0, a5, -1, 1);
  return -1;
}

//----- (1000CB50) --------------------------------------------------------
int __cdecl sub_1000CB50(SOCKET s, char *buf, int a3, int a4, int a5)
{
  int v5; // esi
  int v7; // eax
  int v8; // eax

  v5 = 0;
  if ( a3 <= 0 )
    return v5;
  while ( 1 )
  {
    v7 = a3 - v5;
    if ( a3 - v5 >= a4 )
      v7 = a4;
    v8 = recv(s, buf, v7, 0);
    if ( v8 == -1 )
    {
      sub_1000C990(0, a5, -1, 1);
      return -1;
    }
    if ( !v8 )
      break;
    v5 += v8;
    buf += v8;
    if ( v5 >= a3 )
      return v5;
  }
  return 0;
}

//----- (1000CBC0) --------------------------------------------------------
__int16 __cdecl sub_1000CBC0(SOCKET *a1, int a2, int len, int a4)
{
  __int16 result; // ax
  int v5; // eax
  int v6; // eax
  int v7; // edx

  if ( len < 28 )
    return -1;
  v5 = *(_DWORD *)(a2 + 4);
  if ( !v5 )
    return -1;
  v6 = sub_1000EA10(v5, *(_DWORD *)(a2 + 8));
  v7 = *(_DWORD *)(a2 + 8);
  *(_DWORD *)(a2 + 36) = v6;
  *(_DWORD *)(a2 + 32) = v7;
  result = sub_1000CAF0(*a1, (char *)(a2 + 12), 28, len, a4);
  if ( result != -1 )
    return (sub_1000CAF0(*a1, *(char **)(a2 + 4), *(_DWORD *)(a2 + 32), len, a4) != -1) - 1;
  return result;
}

//----- (1000CC50) --------------------------------------------------------
void *__cdecl sub_1000CC50(SOCKET *a1, int a2, int a3)
{
  void *v3; // esi
  int v4; // eax
  char *v6; // eax
  int v7; // eax
  int v8; // ecx
  int v9; // [esp-18h] [ebp-1Ch]
  signed int v10; // [esp-10h] [ebp-14h]

  v3 = sub_1000BB40(48);
  if ( !v3 )
    return 0;
  *((_DWORD *)v3 + 1) = 0;
  *((_DWORD *)v3 + 2) = 0;
  *((_DWORD *)v3 + 3) = -625280017;
  *((_DWORD *)v3 + 8) = 0;
  v4 = sub_1000CB50(*a1, (char *)v3 + 12, 28, 28, a3);
  if ( !v4 )
  {
LABEL_3:
    *(_WORD *)v3 = 2;
    return v3;
  }
  if ( v4 < 0 )
    goto LABEL_6;
  if ( v4 == 28 )
  {
    if ( *((_DWORD *)v3 + 3) == -625280017 )
    {
      v10 = *((_DWORD *)v3 + 8);
      *(_WORD *)v3 = 4;
      v6 = (char *)sub_1000BB40(v10);
      *((_DWORD *)v3 + 1) = v6;
      if ( v6 )
      {
        v9 = *((_DWORD *)v3 + 8);
        *((_DWORD *)v3 + 2) = v9;
        v7 = sub_1000CB50(*a1, v6, v9, a2, a3);
        if ( !v7 )
          goto LABEL_3;
        if ( v7 < 0 )
        {
LABEL_6:
          *(_WORD *)v3 = 1;
          return v3;
        }
        v8 = *((_DWORD *)v3 + 2);
        if ( v7 == v8 )
        {
          if ( !sub_1000EA50(*((_DWORD *)v3 + 1), v8, *((_DWORD *)v3 + 9)) )
            *(_WORD *)v3 = 8;
          return v3;
        }
        else
        {
          *(_WORD *)v3 = 7;
          return v3;
        }
      }
      else
      {
        *(_WORD *)v3 = 3;
        return v3;
      }
    }
    else
    {
      *(_WORD *)v3 = 6;
      return v3;
    }
  }
  else
  {
    *(_WORD *)v3 = 5;
    return v3;
  }
}

//----- (1000CD60) --------------------------------------------------------
__int16 __cdecl sub_1000CD60(SOCKET *Block)
{
  shutdown(*Block, 2);
  closesocket(*Block);
  return sub_1000BBF0(Block);
}

//----- (1000CD90) --------------------------------------------------------
SOCKET *__cdecl sub_1000CD90(u_short hostshort, int a2)
{
  SOCKET *result; // eax
  SOCKET *v3; // esi
  SOCKET v4; // eax
  SOCKET v5; // [esp-10h] [ebp-18h]
  char optval[4]; // [esp+4h] [ebp-4h] BYREF

  result = (SOCKET *)sub_1000BB40(560);
  v3 = result;
  if ( result )
  {
    v4 = socket(2, 1, 0);
    *v3 = v4;
    if ( v4 == -1 )
    {
      sub_1000C990(0, a2, -1, 1);
      sub_1000C620(a2, 16, -1, "NET_Init: Create socket failed !");
      sub_1000BBF0(v3);
      return 0;
    }
    else if ( v4 && (*(_DWORD *)optval = 1, setsockopt(v4, 0xFFFF, 4, optval, 4)) )
    {
      sub_1000C990(0, a2, -1, 1);
      sub_1000C620(a2, 16, -1, "NET_Init: Socket options failed !");
      closesocket(*v3);
      sub_1000BBF0(v3);
      return 0;
    }
    else
    {
      v3[131] = 0;
      v3[132] = 0;
      v3[133] = 0;
      v3[134] = 0;
      *((_WORD *)v3 + 262) = 2;
      *((_WORD *)v3 + 263) = htons(hostshort);
      v5 = *v3;
      v3[132] = 0;
      if ( bind(v5, (const struct sockaddr *)(v3 + 131), 16) )
      {
        sub_1000C990(0, a2, -1, 1);
        sub_1000C620(a2, 16, -1, "NET_Init: Bind failed !");
        closesocket(*v3);
        sub_1000BBF0(v3);
        return 0;
      }
      else if ( listen(*v3, 5) )
      {
        sub_1000C990(0, a2, -1, 1);
        sub_1000C620(a2, 16, -1, "NET_Init: Listen failed !");
        closesocket(*v3);
        sub_1000BBF0(v3);
        return 0;
      }
      else
      {
        return v3;
      }
    }
  }
  return result;
}

//----- (1000CF10) --------------------------------------------------------
SOCKET *__cdecl sub_1000CF10(int addrlen, int a2, int a3)
{
  int v3; // edi
  SOCKET *result; // eax
  SOCKET *v5; // esi
  SOCKET v6; // ecx
  int v7; // eax
  SOCKET v8; // eax
  int v9; // edi
  SOCKET v10; // [esp-14h] [ebp-20h]
  struct timeval timeout; // [esp+4h] [ebp-8h] BYREF

  v3 = addrlen;
  if ( !addrlen )
    return 0;
  result = (SOCKET *)sub_1000BB40(560);
  v5 = result;
  if ( result )
  {
    v6 = *(_DWORD *)v3;
    v7 = 1000 * a2;
    *(_DWORD *)(v3 + 264) = 0;
    timeout.tv_sec = 0;
    timeout.tv_usec = v7;
    *(_DWORD *)(v3 + 268) = v6;
    ++*(_DWORD *)(v3 + 264);
    if ( select(0, (fd_set *)(v3 + 264), 0, 0, &timeout) <= 0 )
    {
      sub_1000BBF0(v5);
      return 0;
    }
    else
    {
      if ( !_WSAFDIsSet(*(_DWORD *)v3, (fd_set *)(v3 + 264)) )
        return v5;
      v5[131] = 0;
      v5[132] = 0;
      v5[133] = 0;
      v5[134] = 0;
      v10 = *(_DWORD *)v3;
      addrlen = 16;
      v8 = accept(v10, (struct sockaddr *)(v5 + 131), &addrlen);
      *v5 = v8;
      if ( v8 == -1 )
      {
        v9 = a3;
        sub_1000C990(0, a3, -1, 1);
        sub_1000C620(v9, 16, -1, "NET_WaitForNewConnection: Accept failed !");
        sub_1000BBF0(v5);
        return 0;
      }
      else
      {
        return v5;
      }
    }
  }
  return result;
}

//----- (1000D010) --------------------------------------------------------
int __cdecl sub_1000D010(SOCKET s, int a2)
{
  int Error; // eax
  __int16 v3; // cx
  int v4; // esi
  u_long argp; // [esp+0h] [ebp-4h] BYREF

  argp = 1;
  if ( !ioctlsocket(s, -2147195266, &argp) )
    return 1;
  Error = WSAGetLastError();
  v3 = 0;
  while ( Error != dword_10049634[17 * v3] )
  {
    if ( ++v3 >= 42 )
    {
      v4 = a2;
      sub_1000C620(a2, 16, -1, "NET_ReportError: Unknown error code. Sorry.");
      goto LABEL_6;
    }
  }
  v4 = a2;
  if ( a2 )
    sub_1000C620(a2, 16, -1, &aWsaSystemNotIn[68 * v3]);
LABEL_6:
  sub_1000C620(v4, 16, -1, "NET_SetNonblocking: Ioctlsocket failed !");
  return 0;
}
// 10049634: using guessed type int dword_10049634[];

//----- (1000D0A0) --------------------------------------------------------
int __cdecl sub_1000D0A0(SOCKET s, int a2)
{
  int Error; // eax
  __int16 v3; // cx
  int v4; // esi
  u_long argp; // [esp+0h] [ebp-4h] BYREF

  argp = 0;
  if ( !ioctlsocket(s, -2147195266, &argp) )
    return 1;
  Error = WSAGetLastError();
  v3 = 0;
  while ( Error != dword_10049634[17 * v3] )
  {
    if ( ++v3 >= 42 )
    {
      v4 = a2;
      sub_1000C620(a2, 16, -1, "NET_ReportError: Unknown error code. Sorry.");
      goto LABEL_6;
    }
  }
  v4 = a2;
  if ( a2 )
    sub_1000C620(a2, 16, -1, &aWsaSystemNotIn[68 * v3]);
LABEL_6:
  sub_1000C620(v4, 16, -1, "NET_SetBlocking: Ioctlsocket failed !");
  return 0;
}
// 10049634: using guessed type int dword_10049634[];

//----- (1000D130) --------------------------------------------------------
int __cdecl sub_1000D130(SOCKET s, int a2, BOOL optval)
{
  int Error; // eax
  __int16 v4; // cx
  int v5; // esi

  optval = optval;
  if ( !setsockopt(s, 6, 1, (const char *)&optval, 4) )
    return 1;
  Error = WSAGetLastError();
  v4 = 0;
  while ( Error != dword_10049634[17 * v4] )
  {
    if ( ++v4 >= 42 )
    {
      v5 = a2;
      sub_1000C620(a2, 16, -1, "NET_ReportError: Unknown error code. Sorry.");
      goto LABEL_6;
    }
  }
  v5 = a2;
  if ( a2 )
    sub_1000C620(a2, 16, -1, &aWsaSystemNotIn[68 * v4]);
LABEL_6:
  sub_1000C620(v5, 16, -1, "NET_SetTCPNodelay: Failed setting the option !");
  return 0;
}
// 10049634: using guessed type int dword_10049634[];

//----- (1000D1C0) --------------------------------------------------------
SOCKET *__cdecl sub_1000D1C0(u_short hostshort, char a2, char a3, char a4, char a5, int a6, int *a7)
{
  int *v7; // ebp
  SOCKET *result; // eax
  SOCKET *v9; // esi
  SOCKET v10; // eax
  u_short v11; // ax
  SOCKET v12; // edx
  SOCKET v13; // ecx
  SOCKET v14; // ecx
  SOCKET v15; // edx

  v7 = a7;
  if ( !a7 )
    v7 = (int *)&a7;
  result = (SOCKET *)sub_1000BB40(560);
  v9 = result;
  if ( result )
  {
    v10 = socket(2, 1, 0);
    *v9 = v10;
    if ( v10 == -1 )
    {
      *v7 = sub_1000C990(0, a6, -1, 1);
      sub_1000C620(a6, 16, -1, "NET_Async_Connect: Create socket failed !");
      sub_1000BBF0(v9);
      return 0;
    }
    v9[131] = 0;
    v9[132] = 0;
    v9[133] = 0;
    v9[134] = 0;
    *((_WORD *)v9 + 262) = 2;
    v11 = htons(hostshort);
    *((_BYTE *)v9 + 529) = a3;
    v12 = *v9;
    *((_WORD *)v9 + 263) = v11;
    *((_BYTE *)v9 + 528) = a2;
    *((_BYTE *)v9 + 530) = a4;
    *((_BYTE *)v9 + 531) = a5;
    if ( !sub_1000D010(v12, a6) )
      goto LABEL_10;
    if ( connect(*v9, (const struct sockaddr *)(v9 + 131), 16) == -1 && WSAGetLastError() != 10035 )
    {
      *v7 = sub_1000C990(0, a6, -1, 1);
      sub_1000C620(a6, 16, -1, "NET_Async_Connect: connect failed !");
LABEL_10:
      closesocket(*v9);
      sub_1000BBF0(v9);
      return 0;
    }
    v13 = *v9;
    v9[66] = 0;
    v9[67] = v13;
    v14 = v9[66];
    v15 = *v9;
    v9[1] = 0;
    v9[66] = v14 + 1;
    v9[2] = v15;
    ++v9[1];
    return v9;
  }
  return result;
}

//----- (1000D320) --------------------------------------------------------
__int16 __cdecl sub_1000D320(char *name, _DWORD *a2, _DWORD *a3, _DWORD *a4, _DWORD *a5)
{
  const char *v5; // esi
  _DWORD *v6; // ebp
  _DWORD *v7; // ebx
  _DWORD *v8; // edi
  struct hostent *v9; // eax
  char **h_addr_list; // ecx

  v5 = name;
  if ( !name )
    return -1;
  if ( !a2 )
    return -1;
  v6 = a3;
  if ( !a3 )
    return -1;
  v7 = a4;
  if ( !a4 )
    return -1;
  v8 = a5;
  if ( !a5 )
    return -1;
  v9 = gethostbyname(name);
  if ( v9 )
    goto LABEL_12;
  name = (char *)inet_addr(v5);
  if ( name == (char *)-1 )
    return -2;
  v9 = gethostbyaddr((const char *)&name, 4, 2);
  if ( !v9 )
    return -3;
LABEL_12:
  if ( v9->h_addrtype != 2 || v9->h_length != 4 )
    return -4;
  h_addr_list = v9->h_addr_list;
  if ( !h_addr_list || !*h_addr_list )
    return -5;
  *a2 = (unsigned __int8)**h_addr_list;
  *v6 = *((unsigned __int8 *)*v9->h_addr_list + 1);
  *v7 = *((unsigned __int8 *)*v9->h_addr_list + 2);
  *v8 = *((unsigned __int8 *)*v9->h_addr_list + 3);
  return 0;
}

//----- (1000D410) --------------------------------------------------------
__int16 __cdecl sub_1000D410(unsigned __int8 *a1, _DWORD *a2, _DWORD *a3, _DWORD *a4, _DWORD *a5)
{
  if ( !a1 || !a2 || !a3 || !a4 || !a5 )
    return -1;
  *a2 = a1[4];
  *a3 = a1[5];
  *a4 = a1[6];
  *a5 = a1[7];
  return 0;
}

//----- (1000D470) --------------------------------------------------------
__int16 __cdecl sub_1000D470(int a1)
{
  int v1; // ecx
  SOCKET v3; // [esp-10h] [ebp-14h]
  int namelen; // [esp+0h] [ebp-4h] BYREF

  namelen = v1;
  *(_DWORD *)(a1 + 540) = 0;
  *(_DWORD *)(a1 + 544) = 0;
  *(_DWORD *)(a1 + 548) = 0;
  *(_DWORD *)(a1 + 552) = 0;
  v3 = *(_DWORD *)a1;
  namelen = 16;
  return (getsockname(v3, (struct sockaddr *)(a1 + 540), &namelen) != -1) - 1;
}
// 1000D470: variable 'v1' is possibly undefined

//----- (1000D4B0) --------------------------------------------------------
char *__cdecl sub_1000D4B0(__int16 a1, __int16 a2, int a3)
{
  char *v3; // esi
  char *result; // eax
  SOCKET v5; // eax
  int v6; // eax
  __int16 v7; // cx
  int Error; // eax
  __int16 v9; // cx
  int v10; // eax
  __int16 v11; // cx
  int v12; // eax
  __int16 v13; // cx
  u_short v14; // cx
  u_short v15; // ax
  int v16; // eax
  __int16 v17; // cx
  SOCKET v18; // [esp-10h] [ebp-18h]
  char optval[4]; // [esp+4h] [ebp-4h] BYREF

  v3 = (char *)sub_1000BB40(36);
  result = 0;
  if ( v3 )
  {
    *(_DWORD *)v3 = 0;
    *((_DWORD *)v3 + 1) = 0;
    *((_DWORD *)v3 + 2) = 0;
    *((_DWORD *)v3 + 3) = 0;
    *((_DWORD *)v3 + 4) = 0;
    *((_DWORD *)v3 + 5) = 0;
    *((_DWORD *)v3 + 6) = 0;
    *((_DWORD *)v3 + 7) = 0;
    *((_DWORD *)v3 + 8) = 0;
    *((_WORD *)v3 + 12) = a1;
    *(_WORD *)v3 = a2;
    *((_DWORD *)v3 + 7) = a3;
    v5 = socket(2, 2, 17);
    *((_DWORD *)v3 + 1) = v5;
    if ( v5 != -1 )
    {
      *(_DWORD *)optval = 1;
      if ( setsockopt(*((_DWORD *)v3 + 1), 0xFFFF, 32, optval, 4) )
      {
        Error = WSAGetLastError();
        v9 = 0;
        while ( Error != dword_10049634[17 * v9] )
        {
          if ( ++v9 >= 42 )
            goto LABEL_12;
        }
      }
      else if ( setsockopt(*((_DWORD *)v3 + 1), 0xFFFF, 4, optval, 4) )
      {
        v10 = WSAGetLastError();
        v11 = 0;
        while ( v10 != dword_10049634[17 * v11] )
        {
          if ( ++v11 >= 42 )
            goto LABEL_12;
        }
      }
      else if ( ioctlsocket(*((_DWORD *)v3 + 1), -2147195266, (u_long *)optval) )
      {
        v12 = WSAGetLastError();
        v13 = 0;
        while ( v12 != dword_10049634[17 * v13] )
        {
          if ( ++v13 >= 42 )
            goto LABEL_12;
        }
      }
      else
      {
        v14 = *(_WORD *)v3;
        *((_WORD *)v3 + 4) = 2;
        v15 = htons(v14);
        v18 = *((_DWORD *)v3 + 1);
        *((_WORD *)v3 + 5) = v15;
        *((_DWORD *)v3 + 3) = 0;
        if ( bind(v18, (const struct sockaddr *)(v3 + 8), 16) != -1 )
        {
          *((_DWORD *)v3 + 3) = -1;
          *((_DWORD *)v3 + 8) = 1;
          return v3;
        }
        v16 = WSAGetLastError();
        v17 = 0;
        while ( v16 != dword_10049634[17 * v17] )
        {
          if ( ++v17 >= 42 )
          {
LABEL_12:
            sub_1000C620(0, 16, -1, "NET_ReportError: Unknown error code. Sorry.");
            break;
          }
        }
      }
      closesocket(*((_DWORD *)v3 + 1));
      sub_1000BBF0(v3);
      return 0;
    }
    v6 = WSAGetLastError();
    v7 = 0;
    while ( v6 != dword_10049634[17 * v7] )
    {
      if ( ++v7 >= 42 )
      {
        sub_1000C620(0, 16, -1, "NET_ReportError: Unknown error code. Sorry.");
        break;
      }
    }
    sub_1000BBF0(v3);
    return 0;
  }
  return result;
}
// 10049634: using guessed type int dword_10049634[];

//----- (1000D6B0) --------------------------------------------------------
__int16 __cdecl sub_1000D6B0(_DWORD *Block)
{
  __int16 result; // ax

  if ( Block )
  {
    shutdown(Block[1], 2);
    closesocket(Block[1]);
    Block[8] = 0;
    return sub_1000BBF0(Block);
  }
  return result;
}

//----- (1000D6E0) --------------------------------------------------------
int __cdecl sub_1000D6E0(int a1, const void *a2, unsigned int a3)
{
  int result; // eax
  unsigned int v4; // edi
  int v5; // ebp
  _WORD *v6; // ebx
  int Error; // eax
  __int16 v8; // cx

  result = a1;
  if ( a1 )
  {
    v4 = a3;
    if ( a3 > *(_DWORD *)(a1 + 28) )
      return 0;
    if ( !a2 )
    {
      a3 = 0;
      v4 = 0;
    }
    v5 = v4 + 12;
    v6 = sub_1000BB40(v4 + 12);
    if ( !v6 )
      return 0;
    qmemcpy(v6 + 6, a2, v4);
    v6[1] = *(_WORD *)(a1 + 24);
    *v6 = -1314;
    *((_DWORD *)v6 + 1) = a3;
    *((_DWORD *)v6 + 2) = 0;
    *((_DWORD *)v6 + 2) = sub_1000EA10((int)v6, v5);
    if ( sendto(*(_DWORD *)(a1 + 4), (const char *)v6, v5, 0, (const struct sockaddr *)(a1 + 8), 16) == -1 )
    {
      Error = WSAGetLastError();
      v8 = 0;
      while ( Error != dword_10049634[17 * v8] )
      {
        if ( ++v8 >= 42 )
        {
          sub_1000C620(0, 16, -1, "NET_ReportError: Unknown error code. Sorry.");
          break;
        }
      }
      sub_1000BBF0(v6);
      return 0;
    }
    sub_1000BBF0(v6);
    return 1;
  }
  return result;
}
// 10049634: using guessed type int dword_10049634[];

//----- (1000D7D0) --------------------------------------------------------
int __cdecl sub_1000D7D0(int a1, const void *a2, unsigned int a3, _BYTE *a4)
{
  int v4; // edi
  int v5; // ebp
  int v6; // ebx
  int v8; // [esp+Ch] [ebp-4h]

  if ( !a1 || !a4 )
    return 0;
  v4 = *(_DWORD *)(a1 + 8);
  v5 = *(_DWORD *)(a1 + 12);
  v6 = *(_DWORD *)(a1 + 16);
  v8 = *(_DWORD *)(a1 + 20);
  *(_BYTE *)(a1 + 12) = *a4;
  *(_BYTE *)(a1 + 13) = a4[4];
  *(_BYTE *)(a1 + 14) = a4[8];
  *(_BYTE *)(a1 + 15) = a4[12];
  sub_1000D6E0(a1, a2, a3);
  *(_DWORD *)(a1 + 8) = v4;
  *(_DWORD *)(a1 + 12) = v5;
  *(_DWORD *)(a1 + 16) = v6;
  *(_DWORD *)(a1 + 20) = v8;
  return 1;
}

//----- (1000D850) --------------------------------------------------------
int __cdecl sub_1000D850(int a1, char *a2, unsigned int *a3, _DWORD *a4)
{
  signed int v4; // esi
  char *v5; // ebx
  unsigned int v6; // eax
  int Error; // eax
  __int16 v8; // cx
  unsigned int v10; // ebp
  int v11; // esi
  int v12; // eax
  int v13; // edx
  int v14; // ecx
  int v15; // edx
  SOCKET v16; // [esp-20h] [ebp-148h]
  int fromlen; // [esp+8h] [ebp-120h] BYREF
  struct timeval timeout; // [esp+Ch] [ebp-11Ch] BYREF
  struct sockaddr from; // [esp+14h] [ebp-114h] BYREF
  fd_set readfds; // [esp+24h] [ebp-104h] BYREF

  if ( !a1 )
    return 0;
  readfds.fd_array[0] = *(_DWORD *)(a1 + 4);
  readfds.fd_count = 1;
  timeout.tv_usec = 0;
  timeout.tv_sec = 0;
  if ( !select(0, &readfds, 0, 0, &timeout) )
    return 0;
  v4 = *(_DWORD *)(a1 + 28) + 12;
  v5 = (char *)sub_1000BB40(v4);
  if ( !v5 )
    return 0;
  v16 = *(_DWORD *)(a1 + 4);
  fromlen = 16;
  v6 = recvfrom(v16, v5, v4, 0, &from, &fromlen);
  if ( v6 == -1 )
  {
    Error = WSAGetLastError();
    v8 = 0;
    while ( Error != dword_10049634[17 * v8] )
    {
      if ( ++v8 >= 42 )
      {
        sub_1000C620(0, 16, -1, "NET_ReportError: Unknown error code. Sorry.");
        goto LABEL_9;
      }
    }
    goto LABEL_9;
  }
  if ( v6 < 0xC )
    goto LABEL_9;
  v10 = v6 - 12;
  if ( *((_DWORD *)v5 + 1) != v6 - 12 )
    goto LABEL_9;
  if ( *((_WORD *)v5 + 1) != *(_WORD *)(a1 + 24) )
    goto LABEL_9;
  if ( *(_WORD *)v5 != 0xFADE )
    goto LABEL_9;
  v11 = *((_DWORD *)v5 + 2);
  *((_DWORD *)v5 + 2) = 0;
  v12 = sub_1000EA10((int)v5, v6);
  *((_DWORD *)v5 + 2) = v12;
  if ( v11 != v12 )
    goto LABEL_9;
  if ( a2 )
  {
    if ( a3 && v10 <= *a3 )
    {
      qmemcpy(a2, v5 + 12, v10);
      goto LABEL_20;
    }
LABEL_9:
    sub_1000BBF0(v5);
    return 0;
  }
LABEL_20:
  if ( a4 )
  {
    v13 = (unsigned __int8)from.sa_data[3];
    *a4 = (unsigned __int8)from.sa_data[2];
    v14 = (unsigned __int8)from.sa_data[4];
    a4[1] = v13;
    v15 = (unsigned __int8)from.sa_data[5];
    a4[2] = v14;
    a4[3] = v15;
  }
  sub_1000BBF0(v5);
  *a3 = v10;
  return 1;
}
// 10049634: using guessed type int dword_10049634[];

//----- (1000D9E0) --------------------------------------------------------
SOCKET *__cdecl sub_1000D9E0(u_short hostshort, char a2, char a3, char a4, char a5, int a6, int a7, int *a8)
{
  int *v8; // edi
  SOCKET *result; // eax
  SOCKET *v10; // esi
  SOCKET v11; // eax
  u_short v12; // ax
  SOCKET v13; // edx
  int v14; // ebx
  __int16 v15; // ax
  SOCKET v16; // edx
  SOCKET v17; // ebx
  SOCKET v18; // edx
  char *v19; // [esp-18h] [ebp-28h]
  struct timeval timeout; // [esp+8h] [ebp-8h] BYREF

  v8 = a8;
  if ( !a8 )
    v8 = (int *)&a8;
  result = (SOCKET *)sub_1000BB40(560);
  v10 = result;
  if ( result )
  {
    v11 = socket(2, 1, 0);
    *v10 = v11;
    if ( v11 == -1 )
    {
      *v8 = sub_1000C990(0, a7, -1, 1);
      sub_1000C620(a7, 16, -1, "NET_Connect: Create socket failed.");
      sub_1000BBF0(v10);
      return 0;
    }
    v10[131] = 0;
    v10[132] = 0;
    v10[133] = 0;
    v10[134] = 0;
    *((_WORD *)v10 + 262) = 2;
    v12 = htons(hostshort);
    *((_BYTE *)v10 + 529) = a3;
    v13 = *v10;
    *((_WORD *)v10 + 263) = v12;
    *((_BYTE *)v10 + 528) = a2;
    *((_BYTE *)v10 + 530) = a4;
    *((_BYTE *)v10 + 531) = a5;
    if ( connect(v13, (const struct sockaddr *)(v10 + 131), 16) == -1 )
    {
      v14 = a7;
      v15 = sub_1000C990(0, a7, -1, 1);
      v19 = "NET_Connect: Connect failed.";
LABEL_8:
      *v8 = v15;
      sub_1000C620(v14, 16, -1, v19);
      closesocket(*v10);
LABEL_9:
      sub_1000BBF0(v10);
      return 0;
    }
    v16 = *v10;
    v10[66] = 0;
    v10[67] = v16;
    v17 = v10[66];
    v18 = *v10;
    v10[1] = 0;
    v10[66] = v17 + 1;
    v10[2] = v18;
    ++v10[1];
    timeout.tv_usec = 1000 * a6;
    timeout.tv_sec = 0;
    if ( !select(0, (fd_set *)(v10 + 66), (fd_set *)(v10 + 1), 0, &timeout) )
    {
      v14 = a7;
      v15 = sub_1000C990(0, a7, -1, 1);
      v19 = "NET_Connect: Select failed.";
      goto LABEL_8;
    }
    if ( sub_1000D470((int)v10) )
    {
      *v8 = sub_1000C990(0, a7, -1, 1);
      sub_1000C620(a7, 16, -1, "NET_Connect: GetLocalAddress failed.");
      closesocket(*v10);
      goto LABEL_9;
    }
    *((_WORD *)v10 + 271) = ntohs(*((_WORD *)v10 + 271));
    return v10;
  }
  return result;
}

//----- (1000DBC0) --------------------------------------------------------
__int16 __cdecl sub_1000DBC0(char *Block, int a2, int a3)
{
  int v3; // ecx
  int v4; // edx
  SOCKET v6; // ecx
  __int16 v7; // ax
  __int16 v8; // di
  char optval[4]; // [esp+8h] [ebp-114h] BYREF
  int optlen; // [esp+Ch] [ebp-110h] BYREF
  struct timeval timeout; // [esp+10h] [ebp-10Ch] BYREF
  fd_set exceptfds; // [esp+18h] [ebp-104h] BYREF

  v3 = *(_DWORD *)Block;
  timeout.tv_usec = 1000 * a2;
  *((_DWORD *)Block + 66) = 0;
  timeout.tv_sec = 0;
  *((_DWORD *)Block + 67) = v3;
  ++*((_DWORD *)Block + 66);
  v4 = *(_DWORD *)Block;
  *((_DWORD *)Block + 1) = 0;
  *((_DWORD *)Block + 2) = v4;
  ++*((_DWORD *)Block + 1);
  exceptfds.fd_array[0] = *(_DWORD *)Block;
  exceptfds.fd_count = 1;
  if ( select(0, (fd_set *)(Block + 264), (fd_set *)(Block + 4), &exceptfds, &timeout) <= 0 )
    return 1;
  if ( !_WSAFDIsSet(*(_DWORD *)Block, (fd_set *)(Block + 4)) )
  {
    if ( _WSAFDIsSet(*(_DWORD *)Block, &exceptfds) )
    {
      v6 = *(_DWORD *)Block;
      optlen = 4;
      if ( getsockopt(v6, 0xFFFF, 4103, optval, &optlen) )
        v7 = sub_1000C990(0, a3, -1, 1);
      else
        v7 = sub_1000C990(*(int *)optval, a3, -1, 1);
      v8 = v7;
      sub_1000C620(a3, 16, -1, "NET_CheckConnected: Connecting failed.");
      closesocket(*(_DWORD *)Block);
      sub_1000BBF0(Block);
      if ( v8 <= -1 )
        return v8;
      else
        return -1;
    }
    return 1;
  }
  if ( !sub_1000D0A0(*(_DWORD *)Block, a3) )
  {
    shutdown(*(_DWORD *)Block, 2);
    closesocket(*(_DWORD *)Block);
LABEL_7:
    sub_1000BBF0(Block);
    return -1;
  }
  if ( sub_1000D470((int)Block) )
  {
    sub_1000C990(0, a3, -1, 1);
    sub_1000C620(a3, 16, -1, "NET_CheckConnected: GetLocalAddress failed.");
    shutdown(*(_DWORD *)Block, 2);
    closesocket(*(_DWORD *)Block);
    goto LABEL_7;
  }
  *((_WORD *)Block + 271) = ntohs(*((_WORD *)Block + 271));
  return 0;
}

//----- (1000DDA0) --------------------------------------------------------
void __cdecl sub_1000DDA0(DWORD dwMilliseconds)
{
  if ( dwMilliseconds )
    Sleep(dwMilliseconds);
}

//----- (1000DDC0) --------------------------------------------------------
__int16 __cdecl sub_1000DDC0(char *Buffer)
{
  if ( Buffer )
    return (unsigned __int16)_strtime(Buffer);
  else
    return sub_1000C720("ERROR: %s:%s : STRING BUFFER NOT INITIALIZED !", aBltime, aTimeGettimestr);
}

//----- (1000DDF0) --------------------------------------------------------
__int16 __cdecl sub_1000DDF0(char *Buffer)
{
  if ( Buffer )
    return (unsigned __int16)_strdate(Buffer);
  else
    return sub_1000C720("ERROR: %s:%s : STRING BUFFER NOT INITIALIZED !", aBltime, aTimeGetdatestr);
}

//----- (1000DE20) --------------------------------------------------------
int __cdecl sub_1000DE20(WORD *a1)
{
  WORD wDay; // ax
  WORD wMonth; // dx
  WORD wHour; // cx
  WORD wSecond; // ax
  WORD wMinute; // dx
  WORD wMilliseconds; // cx
  struct _SYSTEMTIME SystemTime; // [esp+4h] [ebp-10h] BYREF

  if ( !a1 )
    return 0;
  GetLocalTime(&SystemTime);
  wDay = SystemTime.wDay;
  wMonth = SystemTime.wMonth;
  *a1 = SystemTime.wYear;
  wHour = SystemTime.wHour;
  a1[2] = wDay;
  wSecond = SystemTime.wSecond;
  a1[1] = wMonth;
  wMinute = SystemTime.wMinute;
  a1[3] = wHour;
  wMilliseconds = SystemTime.wMilliseconds;
  a1[5] = wSecond;
  a1[4] = wMinute;
  a1[6] = wMilliseconds;
  return 1;
}

//----- (1000DE90) --------------------------------------------------------
int __cdecl sub_1000DE90(WORD *a1, __int64 a2)
{
  WORD v2; // dx
  WORD v3; // ax
  WORD v4; // cx
  WORD v5; // dx
  WORD v6; // ax
  WORD v7; // ax
  DWORD v8; // ecx
  WORD wDay; // ax
  WORD wMonth; // dx
  WORD wHour; // cx
  WORD wSecond; // ax
  WORD wMinute; // dx
  WORD wMilliseconds; // cx
  struct _FILETIME FileTime; // [esp+4h] [ebp-18h] BYREF
  SYSTEMTIME SystemTime; // [esp+Ch] [ebp-10h] BYREF

  if ( !a1 )
    return 0;
  v2 = a1[2];
  v3 = *a1;
  SystemTime.wMonth = a1[1];
  v4 = a1[4];
  SystemTime.wDay = v2;
  v5 = a1[5];
  SystemTime.wYear = v3;
  v6 = a1[3];
  SystemTime.wMinute = v4;
  SystemTime.wSecond = v5;
  SystemTime.wHour = v6;
  v7 = a1[6];
  SystemTime.wDayOfWeek = 0;
  SystemTime.wMilliseconds = v7;
  if ( !SystemTimeToFileTime(&SystemTime, &FileTime) )
    return 0;
  v8 = (unsigned __int64)(10000 * a2 + *(_QWORD *)&FileTime) >> 32;
  FileTime.dwLowDateTime += 10000 * a2;
  FileTime.dwHighDateTime = v8;
  if ( !FileTimeToSystemTime(&FileTime, &SystemTime) )
    return 0;
  wDay = SystemTime.wDay;
  wMonth = SystemTime.wMonth;
  *a1 = SystemTime.wYear;
  wHour = SystemTime.wHour;
  a1[2] = wDay;
  wSecond = SystemTime.wSecond;
  a1[1] = wMonth;
  wMinute = SystemTime.wMinute;
  a1[3] = wHour;
  wMilliseconds = SystemTime.wMilliseconds;
  a1[5] = wSecond;
  a1[4] = wMinute;
  a1[6] = wMilliseconds;
  return 1;
}

//----- (1000DF80) --------------------------------------------------------
unsigned __int16 __cdecl sub_1000DF80(char *Buffer)
{
  WORD v1; // bp
  unsigned __int16 v2; // bx
  unsigned __int16 v3; // dx
  unsigned __int16 v4; // di
  unsigned __int16 v5; // cx
  unsigned __int16 result; // ax
  WORD v7; // [esp+10h] [ebp-10h] BYREF
  unsigned __int16 v8; // [esp+12h] [ebp-Eh]
  unsigned __int16 v9; // [esp+14h] [ebp-Ch]
  unsigned __int16 v10; // [esp+16h] [ebp-Ah]
  unsigned __int16 v11; // [esp+18h] [ebp-8h]
  unsigned __int16 v12; // [esp+1Ah] [ebp-6h]

  sub_1000DE20(&v7);
  v1 = v7;
  if ( v7 >= 0x76Cu )
  {
    if ( v7 > 0x834u )
      v1 = 2100;
  }
  else
  {
    v1 = 1900;
  }
  v2 = v8;
  if ( v8 )
  {
    if ( v8 > 0xCu )
      v2 = 12;
  }
  else
  {
    v2 = 1;
  }
  v3 = v9;
  if ( v9 )
  {
    if ( v9 > 0x1Fu )
      v3 = 31;
  }
  else
  {
    v3 = 1;
  }
  v4 = v10;
  if ( v10 > 0x17u )
    v4 = 23;
  v5 = v11;
  if ( v11 > 0x3Bu )
    v5 = 59;
  result = v12;
  if ( v12 > 0x3Bu )
    result = 59;
  if ( Buffer )
    return sprintf(Buffer, "%4u%02u%02u%02u%02u%02u", v1, v2, v3, v4, v5, result);
  return result;
}

//----- (1000E050) --------------------------------------------------------
__int16 __cdecl sub_1000E050(int a1, __int16 a2)
{
  BOOL v2; // eax
  HANDLE MutexA; // eax

  v2 = 1;
  if ( a2 == 1 )
  {
    *(_WORD *)a1 = 2;
  }
  else
  {
    *(_WORD *)a1 = 1;
    v2 = 0;
  }
  MutexA = CreateMutexA(0, v2, 0);
  *(_DWORD *)(a1 + 4) = MutexA;
  return (MutexA != 0) - 1;
}

//----- (1000E090) --------------------------------------------------------
__int16 __cdecl sub_1000E090(int a1, DWORD a2)
{
  DWORD v2; // eax
  DWORD v3; // eax

  v2 = a2;
  if ( a2 != -1 && a2 )
    v2 = a2;
  v3 = WaitForSingleObject(*(HANDLE *)(a1 + 4), v2);
  if ( v3 == 258 || v3 != 128 && v3 )
    return 0;
  *(_WORD *)a1 = 2;
  return 1;
}

//----- (1000E0E0) --------------------------------------------------------
__int16 __cdecl sub_1000E0E0(int a1)
{
  if ( a1 )
  {
    *(_WORD *)a1 = 1;
    return ReleaseMutex(*(HANDLE *)(a1 + 4)) - 1;
  }
  else
  {
    sub_1000C7C0("MUTX::MUTX_Unlock(): no mutx handle !");
    return -1;
  }
}

//----- (1000E120) --------------------------------------------------------
_DWORD *__cdecl sub_1000E120(__int16 a1)
{
  _DWORD *v1; // esi
  BOOL v2; // eax
  HANDLE MutexA; // eax

  v1 = sub_1000BB40(8);
  if ( !v1 )
    return 0;
  v2 = 1;
  if ( a1 == 1 )
  {
    *(_WORD *)v1 = 2;
  }
  else
  {
    *(_WORD *)v1 = 1;
    v2 = 0;
  }
  MutexA = CreateMutexA(0, v2, 0);
  v1[1] = MutexA;
  if ( !MutexA )
  {
    sub_1000BBF0(v1);
    return 0;
  }
  return v1;
}

//----- (1000E170) --------------------------------------------------------
__int16 __cdecl sub_1000E170(HANDLE *Block, __int16 a2)
{
  DWORD v2; // eax
  HANDLE v4; // [esp-4h] [ebp-8h]

  v2 = WaitForSingleObject(Block[1], 0xFFFFFFFF);
  if ( v2 != 258 && (v2 == 128 || !v2) )
    *(_WORD *)Block = 2;
  if ( CloseHandle(Block[1]) )
  {
    Block[1] = 0;
    if ( a2 )
      sub_1000BBF0(Block);
    return 0;
  }
  else
  {
    v4 = Block[1];
    *(_WORD *)Block = 1;
    ReleaseMutex(v4);
    return -1;
  }
}

//----- (1000E1E0) --------------------------------------------------------
int __cdecl sub_1000E1E0(HANDLE *Block)
{
  DWORD v1; // eax
  HANDLE v3; // [esp-4h] [ebp-8h]

  v1 = WaitForSingleObject(Block[1], 0xFFFFFFFF);
  if ( v1 != 258 && (v1 == 128 || !v1) )
    *(_WORD *)Block = 2;
  if ( CloseHandle(Block[1]) )
  {
    Block[1] = 0;
    sub_1000BBF0(Block);
    return 0;
  }
  else
  {
    v3 = Block[1];
    *(_WORD *)Block = 1;
    ReleaseMutex(v3);
    return -1;
  }
}

//----- (1000E240) --------------------------------------------------------
_DWORD *__cdecl sub_1000E240(BOOL bManualReset, BOOL bInitialState)
{
  _DWORD *v2; // esi
  HANDLE EventA; // eax

  v2 = sub_1000BB40(4);
  if ( v2 )
  {
    EventA = CreateEventA(0, bManualReset, bInitialState, 0);
    *v2 = EventA;
    if ( EventA )
    {
      return v2;
    }
    else
    {
      sub_1000BBF0(v2);
      sub_1000C6B0(0, 16, "Event object could not be created.");
      return 0;
    }
  }
  else
  {
    sub_1000C6B0(0, 16, "Event control data could not be created.");
    return 0;
  }
}

//----- (1000E2A0) --------------------------------------------------------
__int16 __cdecl sub_1000E2A0(HANDLE *Block)
{
  __int16 result; // ax

  if ( Block )
  {
    if ( *Block )
      CloseHandle(*Block);
    *Block = 0;
    return sub_1000BBF0(Block);
  }
  return result;
}

//----- (1000E2D0) --------------------------------------------------------
BOOL __cdecl sub_1000E2D0(HANDLE *a1)
{
  return a1 && *a1 && SetEvent(*a1);
}

//----- (1000E2F0) --------------------------------------------------------
BOOL __cdecl sub_1000E2F0(HANDLE *a1)
{
  return a1 && *a1 && ResetEvent(*a1);
}

//----- (1000E310) --------------------------------------------------------
BOOL __cdecl sub_1000E310(HANDLE *a1)
{
  return a1 && *a1 && WaitForSingleObject(*a1, 0xFFFFFFFF) != -1;
}

//----- (1000E340) --------------------------------------------------------
__int16 __cdecl sub_1000E340(
        int a1,
        LPTHREAD_START_ROUTINE lpStartAddress,
        LPVOID lpParameter,
        __int16 a4,
        SIZE_T dwStackSize)
{
  _DWORD *v5; // eax
  HANDLE Thread; // eax

  v5 = sub_1000C860();
  *(_DWORD *)(a1 + 4) = v5;
  if ( !v5 )
    return -1;
  Thread = CreateThread(0, dwStackSize, lpStartAddress, lpParameter, a4 != 1 ? 4 : 0, (LPDWORD)(a1 + 12));
  *(_DWORD *)(a1 + 8) = Thread;
  if ( !Thread )
  {
    sub_1000C8A0(*(HANDLE ***)(a1 + 4));
    return -1;
  }
  sub_1000C8D0(*(_DWORD *)(a1 + 4), 512, 2);
  return 0;
}

//----- (1000E3B0) --------------------------------------------------------
void __cdecl __noreturn sub_1000E3B0(int a1, DWORD dwExitCode)
{
  sub_1000C8D0(*(_DWORD *)(a1 + 4), 128, 2);
  ExitThread(dwExitCode);
}

//----- (1000E3E0) --------------------------------------------------------
int __cdecl sub_1000E3E0(int a1, int a2)
{
  DWORD v2; // esi

  sub_1000C8D0(*(_DWORD *)(a1 + 4), 32, 1);
  v2 = GetTickCount() + a2;
  if ( GetTickCount() >= v2 )
    return -1;
  while ( (sub_1000C930(*(_DWORD *)(a1 + 4), 1) & 0x80u) == 0 )
  {
    sub_1000DDA0(0x32u);
    if ( GetTickCount() >= v2 )
      return -1;
  }
  return 0;
}

//----- (1000E440) --------------------------------------------------------
__int16 __cdecl sub_1000E440(int a1)
{
  sub_1000C8A0(*(HANDLE ***)(a1 + 4));
  *(_DWORD *)(a1 + 4) = 0;
  return 0;
}

//----- (1000E460) --------------------------------------------------------
_BOOL2 __cdecl sub_1000E460(int a1)
{
  return (sub_1000C930(*(_DWORD *)(a1 + 4), 2) & 0x20) != 0;
}

//----- (1000E480) --------------------------------------------------------
void sub_1000E480()
{
  Sleep(0);
}

//----- (1000E490) --------------------------------------------------------
__int16 sub_1000E490()
{
  __int16 *v1; // eax
  int v2; // ecx

  if ( (dword_1004D540 & 1) != 0 )
  {
    sub_1000C6F0(0, 16, "%s:%s : SYSTEM ALREADY INITIALIZED !", aBaselibIo, aInitbl);
    return -1;
  }
  else
  {
    word_1004D544 = 0;
    v1 = word_1004D548;
    v2 = 50;
    do
    {
      *v1 = 0;
      v1 += 4;
      --v2;
    }
    while ( v2 );
    dword_1004D540 = 1;
    return 0;
  }
}
// 1004D540: using guessed type int dword_1004D540;
// 1004D544: using guessed type __int16 word_1004D544;
// 1004D548: using guessed type __int16 word_1004D548[];

//----- (1000E4F0) --------------------------------------------------------
__int16 __cdecl sub_1000E4F0(char *FileName, __int16 a2)
{
  __int16 v3; // ax
  __int16 v4; // di
  __int16 v5; // ax
  int v6; // eax

  if ( (dword_1004D540 & 1) != 0 )
  {
    v3 = 0;
    while ( word_1004D548[4 * v3] )
    {
      if ( ++v3 >= 50 )
        goto LABEL_8;
    }
    v4 = v3;
    if ( v3 == -1 )
    {
LABEL_8:
      sub_1000C6F0(0, 16, "%s:%s (FILE: %s): NO FILE SYSTEM HANDLE FREE !", aBaselibIo, aOpenfile, FileName);
      return -1;
    }
    v5 = 0;
    while ( a2 != word_1004A1A4[4 * v5] )
    {
      if ( ++v5 >= 5 )
      {
        sub_1000C6F0(0, 16, "%s:%s (FILE: %s): NO VALID FILE ACCESS MODE !", aBaselibIo, aOpenfile, FileName);
        return -1;
      }
    }
    v6 = _open(FileName, OpenFlag[2 * v5], 384);
    if ( v6 >= 0 )
    {
      FileHandle[2 * v4] = v6;
      word_1004D548[4 * v4] = 16;
      ++word_1004D544;
      return v4;
    }
    else
    {
      sub_1000C6F0(0, 16, "%s:%s (FILE: %s): CANNOT OPEN FILE, DOSHANDLE: %d !", aBaselibIo, aOpenfile, FileName, v6);
      return -1;
    }
  }
  else
  {
    sub_1000C6F0(0, 16, "%s:%s : SYSTEM NOT INITIALIZED !", aBaselibIo, aOpenfile);
    return -1;
  }
}
// 1004A1A4: using guessed type __int16 word_1004A1A4[];
// 1004A1A8: using guessed type int OpenFlag[9];
// 1004D540: using guessed type int dword_1004D540;
// 1004D544: using guessed type __int16 word_1004D544;
// 1004D548: using guessed type __int16 word_1004D548[];
// 1004D54C: using guessed type int FileHandle[101];

//----- (1000E620) --------------------------------------------------------
__int16 __cdecl sub_1000E620(__int16 a1)
{
  unsigned __int16 v2; // ax
  int v3; // eax

  if ( (dword_1004D540 & 1) != 0 )
  {
    if ( (unsigned __int16)a1 > 0x32u )
    {
      sub_1000C6F0(0, 16, "%s:%s: NO VALID HANDLE, HANDLE: %d !", aBaselibIo, aClosefile, a1);
      return -1;
    }
    else
    {
      v2 = word_1004D548[4 * a1];
      if ( (v2 & 0x10) != 0 )
      {
        v3 = _close(FileHandle[2 * a1]);
        if ( v3 >= 0 )
        {
          word_1004D548[4 * a1] = 0;
          --word_1004D544;
          return 0;
        }
        else
        {
          sub_1000C6F0(0, 16, "%s:%s : CANNT CLOSE FILE ! ERRORNUM: %d", aBaselibIo, aClosefile, v3);
          return -1;
        }
      }
      else
      {
        sub_1000C6F0(0, 16, "%s:%s : FILE NOT OPEN ! HANDLE: %d, STATUS: %u", aBaselibIo, aClosefile, a1, v2);
        return -1;
      }
    }
  }
  else
  {
    sub_1000C6F0(0, 16, "%s:%s : SYSTEM NOT INITIALIZED !", aBaselibIo, aClosefile);
    return -1;
  }
}
// 1004D540: using guessed type int dword_1004D540;
// 1004D544: using guessed type __int16 word_1004D544;
// 1004D548: using guessed type __int16 word_1004D548[];
// 1004D54C: using guessed type int FileHandle[101];

//----- (1000E710) --------------------------------------------------------
__int16 __cdecl sub_1000E710(__int16 a1, void *DstBuf, unsigned int MaxCharCount)
{
  unsigned __int16 v3; // ax
  int v4; // eax

  v3 = word_1004D548[4 * a1];
  if ( (v3 & 0x11) == 0 )
  {
    sub_1000C6F0(0, 16, "%s:%s : FILE NOT OPEN FOR READ ! HANDLE: %d STATUS: %u", aBaselibIo, aReadfile, a1, v3);
    return -1;
  }
  v4 = _read(FileHandle[2 * a1], DstBuf, MaxCharCount);
  if ( v4 < 0 )
  {
    sub_1000C6F0(0, 16, "%s:%s : CANNOT READ FILE ! HANDLE: %d, ERRORNUM: %d", aBaselibIo, aClosefile, a1, v4);
    return -1;
  }
  return 0;
}
// 1004D548: using guessed type __int16 word_1004D548[];
// 1004D54C: using guessed type int FileHandle[101];

//----- (1000E780) --------------------------------------------------------
__int16 __cdecl sub_1000E780(__int16 a1, void *Buf, unsigned int MaxCharCount)
{
  unsigned __int16 v3; // ax

  v3 = word_1004D548[4 * a1];
  if ( (v3 & 0x12) != 0 )
  {
    if ( _write(FileHandle[2 * a1], Buf, MaxCharCount) >= 0 )
    {
      return 0;
    }
    else
    {
      sub_1000C6F0(
        0,
        16,
        "%s:%s : CANNOT WRITE FILE ! HANDLE: %d, ERRNUM: %d",
        aBaselibIo,
        aWritefile,
        a1,
        (unsigned __int16)word_1004D548[4 * a1]);
      return -1;
    }
  }
  else
  {
    sub_1000C6F0(0, 16, "%s:%s : FILE NOT OPEN FOR WRITE ! HANDLE: %d, STATUS: %u", aBaselibIo, aWritefile, a1, v3);
    return -1;
  }
}
// 1004D548: using guessed type __int16 word_1004D548[];
// 1004D54C: using guessed type int FileHandle[101];

//----- (1000E810) --------------------------------------------------------
_off_t __cdecl sub_1000E810(char *FileName)
{
  int v1; // edi
  _off_t st_size; // esi
  struct _stat32 Stat; // [esp+8h] [ebp-24h] BYREF

  v1 = _open(FileName, 0);
  if ( v1 == -1 )
  {
    sub_1000C6F0(0, 16, "%s:%s : CANNOT OPEN FILE ! FILE: %s, DOSHANDLE: %d", aBaselibIo, aLengthfile, FileName, -1);
    return -1;
  }
  else if ( _fstat(v1, &Stat) == -1 )
  {
    sub_1000C6F0(0, 16, "%s:%s : DOS OPEN ERROR NO VALID HANDLE ! FILE: %s", aBaselibIo, aLengthfile, FileName);
    _close(v1);
    return -1;
  }
  else
  {
    st_size = Stat.st_size;
    _close(v1);
    return st_size;
  }
}

//----- (1000E8C0) --------------------------------------------------------
__int16 __cdecl sub_1000E8C0(int *a1)
{
  int *v1; // eax
  __int16 v3; // si
  _WORD *v4; // edi

  v1 = a1;
  if ( !a1 )
    v1 = &dword_1004D540;
  if ( (*(_BYTE *)v1 & 1) != 0 )
  {
    *v1 = 0;
    v3 = 0;
    v4 = v1 + 2;
    do
    {
      if ( *v4 )
      {
        if ( (*v4 & 0x10) != 0 )
          sub_1000E620(v3);
      }
      ++v3;
      v4 += 4;
    }
    while ( v3 < 50 );
    return 0;
  }
  else
  {
    sub_1000C6F0(0, 16, "%s:%s : SYSTEM NOT INITIALIZED !", aBaselibIo, aInitbl);
    return -1;
  }
}
// 1004D540: using guessed type int dword_1004D540;

//----- (1000E930) --------------------------------------------------------
void __cdecl sub_1000E930(char *Source, char *Destination, size_t Count)
{
  char v3; // cl

  if ( Count )
  {
    strncpy(Destination, Source, Count);
    if ( strlen(Source) >= Count )
      Destination[Count - 1] = v3;
  }
}
// 1000E960: variable 'v3' is possibly undefined

//----- (1000E970) --------------------------------------------------------
int sub_1000E970()
{
  if ( sub_1000BA50(32) == -1 || sub_1000E490() == -1 )
    return -1;
  dword_1004CAD8 = 1;
  return 0;
}
// 1004CAD8: using guessed type int dword_1004CAD8;

//----- (1000E9A0) --------------------------------------------------------
int sub_1000E9A0()
{
  sub_1000E8C0(0);
  if ( sub_1000BAF0() == -1 )
    return -1;
  dword_1004CAD8 = 0;
  return 0;
}
// 1004CAD8: using guessed type int dword_1004CAD8;

//----- (1000E9D0) --------------------------------------------------------
__int16 __cdecl sub_1000E9D0(int a1)
{
  int v1; // ecx
  __int16 result; // ax

  v1 = 1;
  result = 0;
  while ( (v1 & a1) == 0 )
  {
    v1 *= 2;
    if ( ++result >= 32 )
      return -1;
  }
  return result;
}

//----- (1000EA10) --------------------------------------------------------
int __cdecl sub_1000EA10(int a1, int a2)
{
  int result; // eax
  int i; // ecx

  result = 0;
  for ( i = 0; i < a2; ++i )
    result = dword_1004A8D8[(unsigned __int8)result ^ *(unsigned __int8 *)(i + a1)] ^ (result >> 8) & 0xFFFFFF;
  return result;
}
// 1004A8D8: using guessed type int dword_1004A8D8[260];

//----- (1000EA50) --------------------------------------------------------
BOOL __cdecl sub_1000EA50(int a1, int a2, int a3)
{
  return a3 == sub_1000EA10(a1, a2);
}

//----- (1000EA70) --------------------------------------------------------
int __usercall sub_1000EA70@<eax>(int a1@<eax>, _DWORD *a2@<ecx>)
{
  int v3; // edx

  if ( a1 > -10000 )
    return a2[2] + 16 * a1;
  if ( a1 == -10001 )
    return (int)(a2 + 16);
  if ( a1 == -10000 )
    return a2[4] + 48;
  v3 = *(_DWORD *)(a2[3] - 16 + 8);
  if ( -10001 - a1 > *(unsigned __int8 *)(v3 + 7) )
    return 0;
  else
    return v3 + 16 * (-10001 - a1);
}

//----- (1000EAC0) --------------------------------------------------------
int __cdecl sub_1000EAC0(_DWORD *a1, int a2)
{
  int v3; // esi
  unsigned int v4; // eax

  if ( a2 + ((a1[2] - a1[3]) >> 4) > 2048 )
    return 0;
  if ( a1[6] - a1[2] <= 16 * a2 )
    sub_10015A20(a1, a2);
  v3 = a1[5];
  v4 = 16 * a2 + a1[2];
  if ( *(_DWORD *)(v3 + 4) < v4 )
    *(_DWORD *)(v3 + 4) = v4;
  return 1;
}

//----- (1000EB20) --------------------------------------------------------
int __cdecl sub_1000EB20(int a1, int a2, int a3)
{
  int v3; // edi
  int result; // eax
  int v5; // esi
  int v6; // eax
  int v7; // ebp
  _DWORD *v8; // ecx
  int v9; // eax

  v3 = a3;
  result = -16 * a3;
  *(_DWORD *)(a1 + 8) += -16 * a3;
  if ( a3 > 0 )
  {
    v5 = 0;
    do
    {
      v6 = *(_DWORD *)(a1 + 8);
      v7 = *(_DWORD *)(v6 + v5);
      v8 = *(_DWORD **)(a2 + 8);
      v9 = v5 + v6;
      *v8 = v7;
      v8[2] = *(_DWORD *)(v9 + 8);
      result = *(_DWORD *)(v9 + 12);
      v8[3] = result;
      v5 += 16;
      --v3;
      *(_DWORD *)(a2 + 8) += 16;
    }
    while ( v3 );
  }
  return result;
}

//----- (1000EB80) --------------------------------------------------------
_DWORD *__cdecl sub_1000EB80(_DWORD *a1)
{
  _DWORD *result; // eax
  _DWORD *v2; // ecx

  if ( *(_DWORD *)(a1[4] + 36) >= *(_DWORD *)(a1[4] + 32) )
    sub_10016E30(a1);
  result = sub_10014A80(a1);
  v2 = (_DWORD *)a1[2];
  *v2 = 8;
  v2[2] = result;
  a1[2] += 16;
  return result;
}

//----- (1000EBC0) --------------------------------------------------------
int __cdecl sub_1000EBC0(int a1)
{
  return (*(_DWORD *)(a1 + 8) - *(_DWORD *)(a1 + 12)) >> 4;
}

//----- (1000EBD0) --------------------------------------------------------
int __cdecl sub_1000EBD0(int a1, int a2)
{
  int result; // eax
  int i; // ecx

  result = a1;
  if ( a2 < 0 )
  {
    *(_DWORD *)(a1 + 8) += 16 * a2 + 16;
  }
  else
  {
    for ( i = 16 * a2; *(_DWORD *)(a1 + 8) < (unsigned int)(i + *(_DWORD *)(a1 + 12)); *(_DWORD *)(a1 + 8) += 16 )
      **(_DWORD **)(a1 + 8) = 0;
    *(_DWORD *)(a1 + 8) = i + *(_DWORD *)(a1 + 12);
  }
  return result;
}

//----- (1000EC30) --------------------------------------------------------
_DWORD *__cdecl sub_1000EC30(_DWORD *a1, int a2)
{
  int v2; // eax
  _DWORD *result; // eax

  if ( a2 <= 0 )
    v2 = sub_1000EA70(a2, a1);
  else
    v2 = a1[3] + 16 * a2 - 16;
  for ( result = (_DWORD *)(v2 + 16); (unsigned int)result < a1[2]; result += 4 )
  {
    *(result - 4) = *result;
    *(result - 2) = result[2];
    *(result - 1) = result[3];
  }
  a1[2] -= 16;
  return result;
}

//----- (1000EC90) --------------------------------------------------------
_DWORD *__cdecl sub_1000EC90(_DWORD *a1, int a2)
{
  _DWORD *result; // eax
  _DWORD *i; // ecx
  _DWORD *v4; // ecx

  if ( a2 <= 0 )
    result = (_DWORD *)sub_1000EA70(a2, a1);
  else
    result = (_DWORD *)(a1[3] + 16 * a2 - 16);
  for ( i = (_DWORD *)a1[2]; i > result; i -= 4 )
  {
    *i = *(i - 4);
    i[2] = *(i - 2);
    i[3] = *(i - 1);
  }
  v4 = (_DWORD *)a1[2];
  *result = *v4;
  result[2] = v4[2];
  result[3] = v4[3];
  return result;
}

//----- (1000ECF0) --------------------------------------------------------
int __cdecl sub_1000ECF0(_DWORD *a1, int a2)
{
  _DWORD *v2; // edi
  _DWORD *v3; // eax
  int result; // eax

  v2 = (_DWORD *)(a1[2] - 16);
  if ( a2 <= 0 )
    v3 = (_DWORD *)sub_1000EA70(a2, a1);
  else
    v3 = (_DWORD *)(a1[3] + 16 * a2 - 16);
  *v3 = *v2;
  v3[2] = v2[2];
  v3[3] = v2[3];
  result = a1[2] - 16;
  a1[2] = result;
  return result;
}

//----- (1000ED40) --------------------------------------------------------
int __cdecl sub_1000ED40(_DWORD *a1, int a2)
{
  _DWORD *v2; // eax
  _DWORD *v3; // ecx
  int result; // eax

  if ( a2 <= 0 )
    v2 = (_DWORD *)sub_1000EA70(a2, a1);
  else
    v2 = (_DWORD *)(a1[3] + 16 * a2 - 16);
  v3 = (_DWORD *)a1[2];
  *v3 = *v2;
  v3[2] = v2[2];
  result = v2[3];
  v3[3] = result;
  a1[2] += 16;
  return result;
}

//----- (1000ED80) --------------------------------------------------------
int __cdecl sub_1000ED80(_DWORD *a1, int a2)
{
  unsigned int v2; // eax

  if ( a2 <= 0 )
  {
    v2 = sub_1000EA70(a2, a1);
  }
  else
  {
    v2 = a1[3] + 16 * a2 - 16;
    if ( v2 >= a1[2] )
      return -1;
  }
  if ( !v2 )
    return -1;
  return *(_DWORD *)v2;
}

//----- (1000EDB0) --------------------------------------------------------
const char *__cdecl sub_1000EDB0(int a1, int a2)
{
  if ( a2 == -1 )
    return "no value";
  else
    return (const char *)*(&off_1003F1A8 + a2);
}

//----- (1000EDD0) --------------------------------------------------------
BOOL __cdecl sub_1000EDD0(_DWORD *a1, int a2)
{
  _DWORD *v2; // eax

  if ( a2 <= 0 )
  {
    v2 = (_DWORD *)sub_1000EA70(a2, a1);
  }
  else
  {
    v2 = (_DWORD *)(a1[3] + 16 * a2 - 16);
    if ( (unsigned int)v2 >= a1[2] )
      return 0;
  }
  return v2 && *v2 == 6 && *(_BYTE *)(v2[2] + 6);
}

//----- (1000EE10) --------------------------------------------------------
BOOL __cdecl sub_1000EE10(_DWORD *a1, int a2)
{
  _DWORD *v2; // eax
  char v4[16]; // [esp+0h] [ebp-10h] BYREF

  if ( a2 <= 0 )
  {
    v2 = (_DWORD *)sub_1000EA70(a2, a1);
  }
  else
  {
    v2 = (_DWORD *)(a1[3] + 16 * a2 - 16);
    if ( (unsigned int)v2 >= a1[2] )
      return 0;
  }
  return v2 && (*v2 == 3 || sub_10016F30(v2, (int)v4));
}
// 1000EE10: using guessed type char var_10[16];

//----- (1000EE60) --------------------------------------------------------
BOOL __cdecl sub_1000EE60(_DWORD *a1, int a2)
{
  int *v2; // eax
  int v3; // eax

  if ( a2 <= 0 )
  {
    v2 = (int *)sub_1000EA70(a2, a1);
  }
  else
  {
    v2 = (int *)(a1[3] + 16 * a2 - 16);
    if ( (unsigned int)v2 >= a1[2] )
      return 0;
  }
  if ( !v2 )
    return 0;
  v3 = *v2;
  return v3 == 4 || v3 == 3;
}

//----- (1000EEA0) --------------------------------------------------------
BOOL __cdecl sub_1000EEA0(_DWORD *a1, int a2, int a3)
{
  unsigned int v3; // eax
  int v4; // edi
  int v5; // eax

  if ( a2 <= 0 )
  {
    v4 = sub_1000EA70(a2, a1);
  }
  else
  {
    v3 = a1[3] + 16 * a2 - 16;
    v4 = v3 < a1[2] ? v3 : 0;
  }
  if ( a3 <= 0 )
    v5 = sub_1000EA70(a3, a1);
  else
    v5 = (unsigned int)(a1[3] + 16 * a3 - 16) < a1[2] ? a1[3] + 16 * a3 - 16 : 0;
  return v4 && v5 && sub_10018E20(v4, v5);
}

//----- (1000EF10) --------------------------------------------------------
int __cdecl sub_1000EF10(_DWORD *a1, int a2, int a3)
{
  unsigned int v3; // eax
  double *v4; // edi
  double *v5; // eax

  if ( a2 <= 0 )
  {
    v4 = (double *)sub_1000EA70(a2, a1);
  }
  else
  {
    v3 = a1[3] + 16 * a2 - 16;
    v4 = v3 < a1[2] ? (double *)v3 : 0;
  }
  if ( a3 <= 0 )
    v5 = (double *)sub_1000EA70(a3, a1);
  else
    v5 = (unsigned int)(a1[3] + 16 * a3 - 16) < a1[2] ? (double *)(a1[3] + 16 * a3 - 16) : 0;
  if ( v4 && v5 )
    return sub_10017550(a1, v4, v5);
  else
    return 0;
}

//----- (1000EF80) --------------------------------------------------------
double __cdecl sub_1000EF80(_DWORD *a1, int a2)
{
  double *v2; // eax
  char v4[16]; // [esp+0h] [ebp-10h] BYREF

  if ( a2 <= 0 )
  {
    v2 = (double *)sub_1000EA70(a2, a1);
  }
  else
  {
    v2 = (double *)(a1[3] + 16 * a2 - 16);
    if ( (unsigned int)v2 >= a1[2] )
      return 0.0;
  }
  if ( !v2 )
    return 0.0;
  if ( *(_DWORD *)v2 != 3 )
  {
    v2 = (double *)sub_10016F30(v2, (int)v4);
    if ( !v2 )
      return 0.0;
  }
  return v2[1];
}
// 1000EF80: using guessed type char var_10[16];

//----- (1000EFD0) --------------------------------------------------------
BOOL __cdecl sub_1000EFD0(_DWORD *a1, int a2)
{
  _DWORD *v2; // eax

  if ( a2 <= 0 )
  {
    v2 = (_DWORD *)sub_1000EA70(a2, a1);
  }
  else
  {
    v2 = (_DWORD *)(a1[3] + 16 * a2 - 16);
    if ( (unsigned int)v2 >= a1[2] )
      return 0;
  }
  return v2 && *v2 && (*v2 != 1 || v2[2]);
}

//----- (1000F010) --------------------------------------------------------
int __cdecl sub_1000F010(_DWORD *a1, int a2)
{
  _DWORD *v2; // esi
  int v4; // esi

  if ( a2 <= 0 )
  {
    v2 = (_DWORD *)sub_1000EA70(a2, a1);
  }
  else
  {
    v2 = (_DWORD *)(a1[3] + 16 * a2 - 16);
    if ( (unsigned int)v2 >= a1[2] )
      return 0;
  }
  if ( !v2 )
    return 0;
  if ( *v2 == 4 )
    return v2[2] + 16;
  if ( sub_10016F80((int)a1, (int)v2) )
    v4 = v2[2] + 16;
  else
    v4 = 0;
  if ( *(_DWORD *)(a1[4] + 36) >= *(_DWORD *)(a1[4] + 32) )
    sub_10016E30(a1);
  return v4;
}

//----- (1000F080) --------------------------------------------------------
int __cdecl sub_1000F080(_DWORD *a1, int a2)
{
  _DWORD *v2; // esi

  if ( a2 <= 0 )
  {
    v2 = (_DWORD *)sub_1000EA70(a2, a1);
  }
  else
  {
    v2 = (_DWORD *)(a1[3] + 16 * a2 - 16);
    if ( (unsigned int)v2 >= a1[2] )
      return 0;
  }
  if ( !v2 )
    return 0;
  if ( *v2 == 4 )
    return *(_DWORD *)(v2[2] + 12);
  if ( !sub_10016F80((int)a1, (int)v2) )
    return 0;
  return *(_DWORD *)(v2[2] + 12);
}

//----- (1000F0E0) --------------------------------------------------------
int __cdecl sub_1000F0E0(_DWORD *a1, int a2)
{
  _DWORD *v2; // eax

  if ( a2 <= 0 )
  {
    v2 = (_DWORD *)sub_1000EA70(a2, a1);
  }
  else
  {
    v2 = (_DWORD *)(a1[3] + 16 * a2 - 16);
    if ( (unsigned int)v2 >= a1[2] )
      return 0;
  }
  if ( !v2 )
    return 0;
  if ( *v2 == 2 )
    return v2[2];
  if ( *v2 != 7 )
    return 0;
  return v2[2] + 16;
}

//----- (1000F120) --------------------------------------------------------
int __cdecl sub_1000F120(_DWORD *a1, int a2)
{
  _DWORD *v2; // eax

  if ( a2 <= 0 )
  {
    v2 = (_DWORD *)sub_1000EA70(a2, a1);
  }
  else
  {
    v2 = (_DWORD *)(a1[3] + 16 * a2 - 16);
    if ( (unsigned int)v2 >= a1[2] )
      return 0;
  }
  if ( !v2 || *v2 != 8 )
    return 0;
  return v2[2];
}

//----- (1000F150) --------------------------------------------------------
int __cdecl sub_1000F150(_DWORD *a1, int a2)
{
  _DWORD *v2; // eax
  int result; // eax

  if ( a2 <= 0 )
  {
    v2 = (_DWORD *)sub_1000EA70(a2, a1);
  }
  else
  {
    v2 = (_DWORD *)(a1[3] + 16 * a2 - 16);
    if ( (unsigned int)v2 >= a1[2] )
      return 0;
  }
  if ( !v2 )
    return 0;
  switch ( *v2 )
  {
    case 2:
    case 7:
      result = sub_1000F0E0(a1, a2);
      break;
    case 5:
    case 6:
    case 8:
      result = v2[2];
      break;
    default:
      return 0;
  }
  return result;
}

//----- (1000F1C0) --------------------------------------------------------
int __cdecl sub_1000F1C0(int a1)
{
  int result; // eax

  result = a1;
  **(_DWORD **)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 8) += 16;
  return result;
}

//----- (1000F1E0) --------------------------------------------------------
int __cdecl sub_1000F1E0(int a1, double a2)
{
  int result; // eax
  int v3; // ecx

  result = a1;
  v3 = *(_DWORD *)(a1 + 8);
  *(double *)(v3 + 8) = a2;
  *(_DWORD *)v3 = 3;
  *(_DWORD *)(a1 + 8) += 16;
  return result;
}

//----- (1000F200) --------------------------------------------------------
int __cdecl sub_1000F200(_DWORD *a1, char *a2, unsigned int a3)
{
  _DWORD *v3; // edi
  int result; // eax

  if ( *(_DWORD *)(a1[4] + 36) >= *(_DWORD *)(a1[4] + 32) )
    sub_10016E30(a1);
  v3 = (_DWORD *)a1[2];
  *v3 = 4;
  v3[2] = sub_100194B0((int)a1, a2, a3);
  result = a1[2] + 16;
  a1[2] = result;
  return result;
}

//----- (1000F250) --------------------------------------------------------
int __cdecl sub_1000F250(_DWORD *a1, char *a2)
{
  int result; // eax
  unsigned int v3; // ebx
  _DWORD *v4; // edi

  if ( a2 )
  {
    v3 = strlen(a2);
    if ( *(_DWORD *)(a1[4] + 36) >= *(_DWORD *)(a1[4] + 32) )
      sub_10016E30(a1);
    v4 = (_DWORD *)a1[2];
    *v4 = 4;
    v4[2] = sub_100194B0((int)a1, a2, v3);
    result = a1[2] + 16;
    a1[2] = result;
  }
  else
  {
    result = (int)a1;
    *(_DWORD *)a1[2] = 0;
    a1[2] += 16;
  }
  return result;
}

//----- (1000F2C0) --------------------------------------------------------
int __cdecl sub_1000F2C0(_DWORD *a1, char *Str, int a3)
{
  if ( *(_DWORD *)(a1[4] + 36) >= *(_DWORD *)(a1[4] + 32) )
    sub_10016E30(a1);
  return sub_10018F30(a1, Str, a3);
}

//----- (1000F2F0) --------------------------------------------------------
int __cdecl sub_1000F2F0(_DWORD *a1, char *Str, int a3)
{
  if ( *(_DWORD *)(a1[4] + 36) >= *(_DWORD *)(a1[4] + 32) )
    sub_10016E30(a1);
  return sub_10018F30(a1, Str, (int)&a3);
}

//----- (1000F320) --------------------------------------------------------
int __cdecl sub_1000F320(_DWORD *a1, int a2, int a3)
{
  int v3; // ebx
  _BYTE *v4; // eax
  _DWORD *v5; // edx
  _DWORD *v6; // ecx
  _DWORD *v7; // ecx
  int result; // eax

  if ( *(_DWORD *)(a1[4] + 36) >= *(_DWORD *)(a1[4] + 32) )
    sub_10016E30(a1);
  v3 = a3;
  v4 = sub_10019580(a1, a3);
  *((_DWORD *)v4 + 3) = a2;
  a1[2] -= 16 * a3;
  if ( a3 )
  {
    v5 = &v4[16 * a3 + 16];
    do
    {
      v5 -= 4;
      v6 = (_DWORD *)((char *)v5 + a1[2] - (_DWORD)v4 - 16);
      --v3;
      *v5 = *v6;
      v5[2] = v6[2];
      v5[3] = v6[3];
    }
    while ( v3 );
  }
  v7 = (_DWORD *)a1[2];
  v7[2] = v4;
  *v7 = 6;
  result = a1[2] + 16;
  a1[2] = result;
  return result;
}

//----- (1000F3B0) --------------------------------------------------------
__int64 __cdecl sub_1000F3B0(int a1, int a2)
{
  _DWORD *v2; // ecx
  __int64 result; // rax

  LODWORD(result) = a1;
  v2 = *(_DWORD **)(a1 + 8);
  HIDWORD(result) = a2 != 0;
  *v2 = 1;
  v2[2] = HIDWORD(result);
  *(_DWORD *)(a1 + 8) += 16;
  return result;
}

//----- (1000F3E0) --------------------------------------------------------
int __cdecl sub_1000F3E0(_DWORD *a1, int a2)
{
  _DWORD *v2; // eax
  _DWORD *v3; // eax
  _DWORD *v4; // ecx
  int result; // eax

  if ( a2 <= 0 )
    v2 = (_DWORD *)sub_1000EA70(a2, a1);
  else
    v2 = (_DWORD *)(a1[3] + 16 * a2 - 16);
  v3 = sub_10017230(a1, v2, (double *)(a1[2] - 16), 0);
  v4 = (_DWORD *)(a1[2] - 16);
  *v4 = *v3;
  v4[2] = v3[2];
  result = v3[3];
  v4[3] = result;
  return result;
}

//----- (1000F430) --------------------------------------------------------
int __cdecl sub_1000F430(_DWORD *a1, int a2)
{
  int v2; // eax
  _DWORD *v3; // eax
  _DWORD *v4; // ecx
  int result; // eax

  if ( a2 <= 0 )
    v2 = sub_1000EA70(a2, a1);
  else
    v2 = a1[3] + 16 * a2 - 16;
  v3 = sub_10019DF0(*(_DWORD *)(v2 + 8), (double *)(a1[2] - 16));
  v4 = (_DWORD *)(a1[2] - 16);
  *v4 = *v3;
  v4[2] = v3[2];
  result = v3[3];
  v4[3] = result;
  return result;
}

//----- (1000F480) --------------------------------------------------------
int __cdecl sub_1000F480(_DWORD *a1, int a2, int a3)
{
  int v3; // eax
  _DWORD *v4; // eax
  _DWORD *v5; // ecx
  int result; // eax

  if ( a2 <= 0 )
    v3 = sub_1000EA70(a2, a1);
  else
    v3 = a1[3] + 16 * a2 - 16;
  v4 = sub_10019D20(*(_DWORD *)(v3 + 8), a3);
  v5 = (_DWORD *)a1[2];
  *v5 = *v4;
  v5[2] = v4[2];
  v5[3] = v4[3];
  result = a1[2] + 16;
  a1[2] = result;
  return result;
}

//----- (1000F4D0) --------------------------------------------------------
int __cdecl sub_1000F4D0(_DWORD *a1)
{
  _DWORD *v1; // edi
  int result; // eax

  if ( *(_DWORD *)(a1[4] + 36) >= *(_DWORD *)(a1[4] + 32) )
    sub_10016E30(a1);
  v1 = (_DWORD *)a1[2];
  *v1 = 5;
  v1[2] = sub_10019C10(a1, 0, 0);
  result = a1[2] + 16;
  a1[2] = result;
  return result;
}

//----- (1000F510) --------------------------------------------------------
int __cdecl sub_1000F510(_DWORD *a1, int a2)
{
  _DWORD *v2; // eax
  int v4; // ecx
  _DWORD *v5; // eax

  if ( a2 <= 0 )
  {
    v2 = (_DWORD *)sub_1000EA70(a2, a1);
  }
  else
  {
    v2 = (_DWORD *)(a1[3] + 16 * a2 - 16);
    if ( (unsigned int)v2 >= a1[2] )
      return 0;
  }
  if ( !v2 )
    return 0;
  if ( *v2 == 5 )
  {
    v4 = *(_DWORD *)(v2[2] + 8);
  }
  else
  {
    if ( *v2 != 7 )
      return 0;
    v4 = *(_DWORD *)(v2[2] + 8);
  }
  if ( !v4 || v4 == *(_DWORD *)(a1[4] + 72) )
    return 0;
  v5 = (_DWORD *)a1[2];
  *v5 = 5;
  v5[2] = v4;
  a1[2] += 16;
  return 1;
}

//----- (1000F580) --------------------------------------------------------
int __cdecl sub_1000F580(_DWORD *a1, int a2)
{
  _DWORD *v2; // eax
  int v3; // eax
  _DWORD *v4; // eax
  _DWORD *v5; // ecx
  int result; // eax

  if ( a2 <= 0 )
    v2 = (_DWORD *)sub_1000EA70(a2, a1);
  else
    v2 = (_DWORD *)(a1[3] + 16 * a2 - 16);
  if ( *v2 != 6 || (v3 = v2[2], *(_BYTE *)(v3 + 6)) )
    v4 = a1 + 16;
  else
    v4 = (_DWORD *)(v3 + 16);
  v5 = (_DWORD *)a1[2];
  *v5 = *v4;
  v5[2] = v4[2];
  result = v4[3];
  v5[3] = result;
  a1[2] += 16;
  return result;
}

//----- (1000F5D0) --------------------------------------------------------
int __cdecl sub_1000F5D0(_DWORD *a1, int a2)
{
  _DWORD *v2; // eax
  int result; // eax

  if ( a2 <= 0 )
    v2 = (_DWORD *)sub_1000EA70(a2, a1);
  else
    v2 = (_DWORD *)(a1[3] + 16 * a2 - 16);
  sub_100172A0(a1, v2, (double *)(a1[2] - 32), (_DWORD *)(a1[2] - 16));
  result = a1[2] - 32;
  a1[2] = result;
  return result;
}

//----- (1000F610) --------------------------------------------------------
int __cdecl sub_1000F610(_DWORD *a1, int a2)
{
  int v2; // eax
  int v3; // edi
  _DWORD *v4; // eax
  int result; // eax

  if ( a2 <= 0 )
    v2 = sub_1000EA70(a2, a1);
  else
    v2 = a1[3] + 16 * a2 - 16;
  v3 = a1[2];
  v4 = sub_10019E50(a1, *(_DWORD *)(v2 + 8), (double *)(v3 - 32));
  *v4 = *(_DWORD *)(v3 - 16);
  v4[2] = *(_DWORD *)(v3 - 8);
  v4[3] = *(_DWORD *)(v3 - 4);
  result = a1[2] - 32;
  a1[2] = result;
  return result;
}

//----- (1000F670) --------------------------------------------------------
int __cdecl sub_1000F670(_DWORD *a1, int a2, int a3)
{
  int v3; // eax
  _DWORD *v4; // esi
  _DWORD *v5; // eax
  int result; // eax

  if ( a2 <= 0 )
    v3 = sub_1000EA70(a2, a1);
  else
    v3 = a1[3] + 16 * a2 - 16;
  v4 = (_DWORD *)(a1[2] - 16);
  v5 = sub_1001A3D0(a1, *(_DWORD *)(v3 + 8), a3);
  *v5 = *v4;
  v5[2] = v4[2];
  v5[3] = v4[3];
  result = a1[2] - 16;
  a1[2] = result;
  return result;
}

//----- (1000F6D0) --------------------------------------------------------
int __cdecl sub_1000F6D0(_DWORD *a1, int a2)
{
  _DWORD *v2; // eax
  int v3; // ecx
  int v4; // edx
  int v5; // ecx
  int result; // eax

  if ( a2 <= 0 )
    v2 = (_DWORD *)sub_1000EA70(a2, a1);
  else
    v2 = (_DWORD *)(a1[3] + 16 * a2 - 16);
  v3 = a1[2];
  v4 = *(_DWORD *)(v3 - 16);
  v5 = v3 - 16;
  if ( !v4 )
    v5 = a1[4] + 64;
  if ( *v2 == 5 || *v2 == 7 )
  {
    *(_DWORD *)(v2[2] + 8) = *(_DWORD *)(v5 + 8);
    a1[2] -= 16;
    return 1;
  }
  else
  {
    result = 0;
    a1[2] -= 16;
  }
  return result;
}

//----- (1000F740) --------------------------------------------------------
int __cdecl sub_1000F740(_DWORD *a1, int a2)
{
  _DWORD *v2; // eax
  _DWORD *v3; // edx
  int v4; // eax
  _DWORD *v5; // eax

  if ( a2 <= 0 )
    v2 = (_DWORD *)sub_1000EA70(a2, a1);
  else
    v2 = (_DWORD *)(a1[3] + 16 * a2 - 16);
  v3 = (_DWORD *)(a1[2] - 16);
  a1[2] = v3;
  if ( *v2 != 6 )
    return 0;
  v4 = v2[2];
  if ( *(_BYTE *)(v4 + 6) )
    return 0;
  v5 = (_DWORD *)(v4 + 16);
  *v5 = *v3;
  v5[1] = v3[1];
  v5[2] = v3[2];
  v5[3] = v3[3];
  return 1;
}

//----- (1000F7B0) --------------------------------------------------------
char __cdecl sub_1000F7B0(int a1, int a2, int a3)
{
  return sub_10015FC0(a1, (char *)(*(_DWORD *)(a1 + 8) - 16 * (a2 + 1)), a3);
}

//----- (1000F7D0) --------------------------------------------------------
char __cdecl sub_1000F7D0(int a1, int a2)
{
  return sub_10015FC0(a1, *(char **)a2, *(_DWORD *)(a2 + 4));
}

//----- (1000F7F0) --------------------------------------------------------
int __cdecl sub_1000F7F0(_DWORD *a1, int a2, int a3, int a4)
{
  int v4; // ecx
  int v5; // eax
  int v6; // ecx
  int v8; // [esp-4h] [ebp-10h]
  int v9[2]; // [esp+4h] [ebp-8h] BYREF

  if ( a4 )
  {
    if ( a4 <= 0 )
      v5 = sub_1000EA70(a4, a1);
    else
      v5 = a1[3] + 16 * a4 - 16;
    v4 = v5 - a1[7];
  }
  else
  {
    v4 = 0;
  }
  v8 = v4;
  v6 = a1[7];
  v9[0] = a1[2] - 16 * (a2 + 1);
  v9[1] = a3;
  return sub_10016390((int)a1, (void (__cdecl *)(int, int))sub_1000F7D0, (int)v9, v9[0] - v6, v8);
}

//----- (1000F860) --------------------------------------------------------
int __cdecl sub_1000F860(_DWORD *a1, int a2, int a3, void *a4)
{
  void *v4; // eax
  int v5; // eax
  _DWORD v7[5]; // [esp+0h] [ebp-14h] BYREF

  v4 = a4;
  if ( !a4 )
    v4 = &unk_1003E150;
  sub_1001A4B0(v7, a2, a3, (int)v4);
  v5 = sub_1001A460((int)v7);
  return sub_10016260(a1, (int)v7, v5 == 27);
}
// 1000F860: using guessed type _DWORD var_14[5];

//----- (1000F8B0) --------------------------------------------------------
int __cdecl sub_1000F8B0(int a1, int a2, int a3)
{
  int v3; // eax
  int v4; // edx
  int v5; // eax
  int v6; // eax

  v3 = *(_DWORD *)(a1 + 8);
  v4 = *(_DWORD *)(v3 - 16);
  v5 = v3 - 16;
  if ( v4 != 6 )
    return 0;
  v6 = *(_DWORD *)(v5 + 8);
  if ( *(_BYTE *)(v6 + 6) || *(_BYTE *)(v6 + 7) )
    return 0;
  sub_1001AB20(a1, *(_DWORD *)(v6 + 12), a2, a3);
  return 1;
}

//----- (1000F900) --------------------------------------------------------
int __cdecl sub_1000F900(int a1)
{
  return *(_DWORD *)(*(_DWORD *)(a1 + 16) + 32) >> 10;
}

//----- (1000F910) --------------------------------------------------------
int __cdecl sub_1000F910(int a1)
{
  return *(_DWORD *)(*(_DWORD *)(a1 + 16) + 36) >> 10;
}

//----- (1000F920) --------------------------------------------------------
char __cdecl sub_1000F920(_DWORD *a1, unsigned int a2)
{
  int v2; // eax

  if ( a2 <= 0x3FFFFF )
    *(_DWORD *)(a1[4] + 32) = a2 << 10;
  else
    *(_DWORD *)(a1[4] + 32) = -1;
  v2 = a1[4];
  if ( *(_DWORD *)(v2 + 36) >= *(_DWORD *)(v2 + 32) )
    LOBYTE(v2) = sub_10016E30(a1);
  return v2;
}

//----- (1000F960) --------------------------------------------------------
void __cdecl __noreturn sub_1000F960(_DWORD *a1)
{
  sub_1001B420(a1);
}

//----- (1000F970) --------------------------------------------------------
int __cdecl sub_1000F970(_DWORD *a1, int a2)
{
  int v2; // eax
  int result; // eax
  int v4; // ecx
  int v5; // ecx

  if ( a2 <= 0 )
    v2 = sub_1000EA70(a2, a1);
  else
    v2 = a1[3] + 16 * a2 - 16;
  result = sub_10019F50(a1, *(_DWORD *)(v2 + 8), a1[2] - 16);
  v4 = a1[2];
  if ( result )
    v5 = v4 + 16;
  else
    v5 = v4 - 16;
  a1[2] = v5;
  return result;
}

//----- (1000F9C0) --------------------------------------------------------
char __cdecl sub_1000F9C0(_DWORD *a1, int a2)
{
  int v2; // eax
  _DWORD *v3; // edi

  v2 = a1[4];
  if ( *(_DWORD *)(v2 + 36) >= *(_DWORD *)(v2 + 32) )
    LOBYTE(v2) = sub_10016E30(a1);
  if ( a2 < 2 )
  {
    if ( !a2 )
    {
      v3 = (_DWORD *)a1[2];
      *v3 = 4;
      v3[2] = sub_100194B0((int)a1, 0, 0);
      v2 = a1[2] + 16;
      a1[2] = v2;
    }
  }
  else
  {
    sub_10017760(a1, a2, ((a1[2] - a1[3]) >> 4) - 1);
    v2 = 16 - 16 * a2;
    a1[2] += v2;
  }
  return v2;
}

//----- (1000FA40) --------------------------------------------------------
_DWORD *__cdecl sub_1000FA40(_DWORD *a1, int a2)
{
  _DWORD *v2; // eax
  _DWORD *v3; // ecx

  if ( *(_DWORD *)(a1[4] + 36) >= *(_DWORD *)(a1[4] + 32) )
    sub_10016E30(a1);
  v2 = sub_10019540(a1, a2);
  v3 = (_DWORD *)a1[2];
  v3[2] = v2;
  *v3 = 7;
  a1[2] += 16;
  return v2 + 4;
}

//----- (1000FA90) --------------------------------------------------------
int __cdecl sub_1000FA90(_DWORD *a1)
{
  int v1; // ebx
  int v2; // edi
  int v4; // [esp+14h] [ebp-4h]

  sub_100155B0(a1, 1, 5);
  v1 = sub_10014F40(a1, 1);
  sub_100155B0(a1, 2, 6);
  v2 = 1;
  v4 = 1;
  if ( v1 < 1 )
    return 0;
  while ( 1 )
  {
    sub_1000ED40(a1, 2);
    sub_1000F1E0((int)a1, (double)v4);
    sub_1000F480(a1, 1, v2);
    sub_1000F7B0((int)a1, 2, 1);
    if ( sub_1000ED80(a1, -1) )
      break;
    sub_1000EBD0((int)a1, -2);
    v4 = ++v2;
    if ( v2 > v1 )
      return 0;
  }
  return 1;
}

//----- (1000FB30) --------------------------------------------------------
int __cdecl sub_1000FB30(_DWORD *a1)
{
  sub_100155B0(a1, 1, 5);
  sub_100155B0(a1, 2, 6);
  sub_1000F1C0((int)a1);
  if ( !sub_1000F970(a1, 1) )
    return 0;
  while ( 1 )
  {
    sub_1000ED40(a1, 2);
    sub_1000ED40(a1, -3);
    sub_1000ED40(a1, -3);
    sub_1000F7B0((int)a1, 2, 1);
    if ( sub_1000ED80(a1, -1) )
      break;
    sub_1000EBD0((int)a1, -3);
    if ( !sub_1000F970(a1, 1) )
      return 0;
  }
  return 1;
}

//----- (1000FBC0) --------------------------------------------------------
int __cdecl sub_1000FBC0(_DWORD *a1)
{
  int v2; // [esp+Ch] [ebp-4h]

  sub_100155B0(a1, 1, 5);
  v2 = sub_10014F40(a1, 1);
  sub_1000F1E0((int)a1, (double)v2);
  return 1;
}

//----- (1000FC00) --------------------------------------------------------
int __cdecl sub_1000FC00(_DWORD *a1)
{
  double v1; // st7

  sub_100155B0(a1, 1, 5);
  v1 = sub_10015700(a1, 2);
  sub_10014E70(a1, 1, (unsigned __int64)v1);
  return 0;
}

//----- (1000FC30) --------------------------------------------------------
int __cdecl sub_1000FC30(_DWORD *a1)
{
  int v1; // ebp
  int v2; // eax
  int v3; // esi
  int v4; // ebx
  unsigned __int64 v5; // rax
  int i; // esi

  v1 = sub_1000EBC0((int)a1);
  sub_100155B0(a1, 1, 5);
  v2 = sub_10014F40(a1, 1);
  v3 = v2 + 1;
  if ( v1 == 2 )
  {
    v4 = v2 + 1;
  }
  else
  {
    v5 = (unsigned __int64)sub_10015700(a1, 2);
    v4 = v5;
    if ( (int)v5 > v3 )
      v3 = v5;
    v1 = 3;
  }
  sub_10014E70(a1, 1, v3);
  for ( i = v3 - 1; i >= v4; --i )
  {
    sub_1000F480(a1, 1, i);
    sub_1000F670(a1, 1, i + 1);
  }
  sub_1000ED40(a1, v1);
  sub_1000F670(a1, 1, v4);
  return 0;
}

//----- (1000FCD0) --------------------------------------------------------
int __cdecl sub_1000FCD0(_DWORD *a1)
{
  int v1; // ebp
  int v2; // esi

  sub_100155B0(a1, 1, 5);
  v1 = sub_10014F40(a1, 1);
  v2 = (unsigned __int64)sub_10015780(a1, 2, (double)v1);
  if ( v1 <= 0 )
    return 0;
  sub_10014E70(a1, 1, v1 - 1);
  sub_1000F480(a1, 1, v2);
  for ( ; v2 < v1; ++v2 )
  {
    sub_1000F480(a1, 1, v2 + 1);
    sub_1000F670(a1, 1, v2);
  }
  sub_1000F1C0((int)a1);
  sub_1000F670(a1, 1, v1);
  return 1;
}

//----- (1000FD70) --------------------------------------------------------
int __cdecl sub_1000FD70(_DWORD *a1)
{
  _BYTE *v1; // ebp
  int v2; // edi
  int v3; // ebx
  _BYTE *v5; // [esp+18h] [ebp-210h] BYREF
  _DWORD v6[131]; // [esp+1Ch] [ebp-20Ch] BYREF

  v1 = (_BYTE *)sub_100156A0(a1, 2, byte_1003D986, (int *)&v5);
  v2 = (unsigned __int64)sub_10015780(a1, 3, 1.0);
  v3 = (unsigned __int64)sub_10015780(a1, 4, 0.0);
  sub_100155B0(a1, 1, 5);
  if ( !v3 )
    v3 = sub_10014F40(a1, 1);
  sub_10015270((int)a1, v6);
  for ( ; v2 <= v3; ++v2 )
  {
    sub_1000F480(a1, 1, v2);
    if ( !sub_1000EE60(a1, -1) )
      sub_10015510(a1, 1, "table contains non-strings");
    sub_100151D0((int)v6);
    if ( v2 != v3 )
      sub_10015120((int)v6, v1, v5);
  }
  sub_10015180((int)v6);
  return 1;
}
// 1000FD70: using guessed type _DWORD var_20C[131];

//----- (1000FE70) --------------------------------------------------------
void __cdecl sub_1000FE70(_DWORD *a1, int a2, int a3)
{
  int v3; // ebx
  int v4; // ebp
  BOOL v5; // edi
  int v6; // eax
  int v7; // ebp
  int v8; // edi
  BOOL v9; // ebx
  int v10; // eax
  BOOL v11; // ebx
  int v12; // eax
  int v13; // ebp
  int v14; // ebx
  BOOL v15; // edi
  int v16; // eax
  BOOL v17; // edi
  int v18; // eax
  int v19; // edi
  int v20; // ebp
  int v21; // ebx
  int v22; // eax
  int v23; // edx
  int v24; // [esp+8h] [ebp-4h]

  v3 = a3;
  v4 = a2;
  if ( a2 < a3 )
  {
    while ( 1 )
    {
      sub_1000F480(a1, 1, v4);
      sub_1000F480(a1, 1, v3);
      if ( sub_1000ED80(a1, 2) )
      {
        sub_1000ED40(a1, 2);
        sub_1000ED40(a1, -2);
        sub_1000ED40(a1, -4);
        sub_1000F7B0((int)a1, 2, 1);
        v5 = sub_1000EFD0(a1, -1);
        sub_1000EBD0((int)a1, -2);
        v6 = v5;
      }
      else
      {
        v6 = sub_1000EF10(a1, -1, -2);
      }
      if ( v6 )
      {
        sub_1000F670(a1, 1, v4);
        sub_1000F670(a1, 1, v3);
      }
      else
      {
        sub_1000EBD0((int)a1, -3);
      }
      v7 = v3 - a2;
      if ( v3 - a2 == 1 )
        break;
      v8 = (v3 + a2) / 2;
      sub_1000F480(a1, 1, v8);
      sub_1000F480(a1, 1, a2);
      if ( sub_1000ED80(a1, 2) )
      {
        sub_1000ED40(a1, 2);
        sub_1000ED40(a1, -3);
        sub_1000ED40(a1, -3);
        sub_1000F7B0((int)a1, 2, 1);
        v9 = sub_1000EFD0(a1, -1);
        sub_1000EBD0((int)a1, -2);
        v10 = v9;
        v3 = a3;
      }
      else
      {
        v10 = sub_1000EF10(a1, -2, -1);
      }
      if ( v10 )
      {
        sub_1000F670(a1, 1, v8);
        sub_1000F670(a1, 1, a2);
      }
      else
      {
        sub_1000EBD0((int)a1, -2);
        sub_1000F480(a1, 1, v3);
        if ( sub_1000ED80(a1, 2) )
        {
          sub_1000ED40(a1, 2);
          sub_1000ED40(a1, -2);
          sub_1000ED40(a1, -4);
          sub_1000F7B0((int)a1, 2, 1);
          v11 = sub_1000EFD0(a1, -1);
          sub_1000EBD0((int)a1, -2);
          v12 = v11;
          v3 = a3;
        }
        else
        {
          v12 = sub_1000EF10(a1, -1, -2);
        }
        if ( v12 )
        {
          sub_1000F670(a1, 1, v8);
          sub_1000F670(a1, 1, v3);
        }
        else
        {
          sub_1000EBD0((int)a1, -3);
        }
      }
      if ( v7 == 2 )
        break;
      sub_1000F480(a1, 1, v8);
      sub_1000ED40(a1, -1);
      v13 = v3 - 1;
      v24 = v3 - 1;
      sub_1000F480(a1, 1, v3 - 1);
      sub_1000F670(a1, 1, v8);
      sub_1000F670(a1, 1, v3 - 1);
      v14 = a2;
      while ( 1 )
      {
        while ( 1 )
        {
          sub_1000F480(a1, 1, ++v14);
          if ( sub_1000ED80(a1, 2) )
          {
            sub_1000ED40(a1, 2);
            sub_1000ED40(a1, -2);
            sub_1000ED40(a1, -4);
            sub_1000F7B0((int)a1, 2, 1);
            v15 = sub_1000EFD0(a1, -1);
            sub_1000EBD0((int)a1, -2);
            v16 = v15;
          }
          else
          {
            v16 = sub_1000EF10(a1, -1, -2);
          }
          if ( !v16 )
            break;
          if ( v14 > a3 )
            sub_10014BC0(a1, "invalid order function for sorting");
          sub_1000EBD0((int)a1, -2);
        }
        while ( 1 )
        {
          sub_1000F480(a1, 1, --v13);
          if ( sub_1000ED80(a1, 2) )
          {
            sub_1000ED40(a1, 2);
            sub_1000ED40(a1, -4);
            sub_1000ED40(a1, -3);
            sub_1000F7B0((int)a1, 2, 1);
            v17 = sub_1000EFD0(a1, -1);
            sub_1000EBD0((int)a1, -2);
            v18 = v17;
          }
          else
          {
            v18 = sub_1000EF10(a1, -3, -1);
          }
          if ( !v18 )
            break;
          if ( v13 < a2 )
            sub_10014BC0(a1, "invalid order function for sorting");
          sub_1000EBD0((int)a1, -2);
        }
        if ( v13 < v14 )
          break;
        sub_1000F670(a1, 1, v14);
        sub_1000F670(a1, 1, v13);
      }
      sub_1000EBD0((int)a1, -4);
      sub_1000F480(a1, 1, v24);
      sub_1000F480(a1, 1, v14);
      sub_1000F670(a1, 1, v24);
      sub_1000F670(a1, 1, v14);
      v19 = a3;
      v20 = a2;
      if ( v14 - a2 >= a3 - v14 )
      {
        v22 = v14 + 1;
        v23 = v14 - 1;
        v21 = a3;
        a3 = v23;
        v19 = v23;
      }
      else
      {
        v21 = v14 - 1;
        v22 = a2;
        a2 = v21 + 2;
        v20 = v21 + 2;
      }
      sub_1000FE70(a1, v22, v21);
      if ( v20 >= v19 )
        break;
      v3 = a3;
      v4 = a2;
    }
  }
}

//----- (10010260) --------------------------------------------------------
int __cdecl sub_10010260(_DWORD *a1)
{
  int v1; // edi

  sub_100155B0(a1, 1, 5);
  v1 = sub_10014F40(a1, 1);
  sub_10014D00(a1, 40, byte_1003D986);
  if ( sub_1000ED80(a1, 2) > 0 )
    sub_100155B0(a1, 2, 6);
  sub_1000EBD0((int)a1, 2);
  sub_1000FE70(a1, 1, v1);
  return 0;
}

//----- (100102C0) --------------------------------------------------------
int __cdecl sub_100102C0(_DWORD *a1)
{
  double v1; // st7

  v1 = sub_10015700(a1, 1);
  sub_1000F1E0((int)a1, fabs(v1));
  return 1;
}

//----- (100102F0) --------------------------------------------------------
int __cdecl sub_100102F0(_DWORD *a1)
{
  double v1; // st7

  v1 = sub_10015700(a1, 1);
  sub_1000F1E0((int)a1, sin(v1));
  return 1;
}

//----- (10010320) --------------------------------------------------------
int __cdecl sub_10010320(_DWORD *a1)
{
  double v1; // st7

  v1 = sub_10015700(a1, 1);
  sub_1000F1E0((int)a1, cos(v1));
  return 1;
}

//----- (10010350) --------------------------------------------------------
int __cdecl sub_10010350(_DWORD *a1)
{
  double v1; // st7

  v1 = sub_10015700(a1, 1);
  sub_1000F1E0((int)a1, tan(v1));
  return 1;
}

//----- (10010380) --------------------------------------------------------
int __cdecl sub_10010380(_DWORD *a1)
{
  double v1; // st7

  v1 = sub_10015700(a1, 1);
  sub_1000F1E0((int)a1, asin(v1));
  return 1;
}

//----- (100103B0) --------------------------------------------------------
int __cdecl sub_100103B0(_DWORD *a1)
{
  double v1; // st7

  v1 = sub_10015700(a1, 1);
  sub_1000F1E0((int)a1, acos(v1));
  return 1;
}

//----- (100103E0) --------------------------------------------------------
int __cdecl sub_100103E0(_DWORD *a1)
{
  double v1; // st7

  v1 = sub_10015700(a1, 1);
  sub_1000F1E0((int)a1, atan2(v1, 1.0));
  return 1;
}

//----- (10010410) --------------------------------------------------------
int __cdecl sub_10010410(_DWORD *a1)
{
  double v1; // st7
  double v3; // [esp+Ch] [ebp-8h]

  v3 = sub_10015700(a1, 1);
  v1 = sub_10015700(a1, 2);
  sub_1000F1E0((int)a1, atan2(v3, v1));
  return 1;
}

//----- (10010450) --------------------------------------------------------
int __cdecl sub_10010450(_DWORD *a1)
{
  double X; // st7
  double v2; // st7

  X = sub_10015700(a1, 1);
  v2 = ceil(X);
  sub_1000F1E0((int)a1, v2);
  return 1;
}

//----- (10010480) --------------------------------------------------------
int __cdecl sub_10010480(_DWORD *a1)
{
  double X; // st7
  double v2; // st7

  X = sub_10015700(a1, 1);
  v2 = floor(X);
  sub_1000F1E0((int)a1, v2);
  return 1;
}

//----- (100104B0) --------------------------------------------------------
int __cdecl sub_100104B0(_DWORD *a1)
{
  double v1; // st7
  double v3; // [esp+Ch] [ebp-8h]

  v3 = sub_10015700(a1, 1);
  v1 = sub_10015700(a1, 2);
  sub_1000F1E0((int)a1, fmod(v3, v1));
  return 1;
}

//----- (10010500) --------------------------------------------------------
int __cdecl sub_10010500(_DWORD *a1)
{
  double v1; // st7

  v1 = sub_10015700(a1, 1);
  sub_1000F1E0((int)a1, sqrt(v1));
  return 1;
}

//----- (10010530) --------------------------------------------------------
int __cdecl sub_10010530(_DWORD *a1)
{
  double v1; // st7
  double v3; // [esp+Ch] [ebp-8h]

  v3 = sub_10015700(a1, 1);
  v1 = sub_10015700(a1, 2);
  sub_1000F1E0((int)a1, pow(v3, v1));
  return 1;
}

//----- (10010580) --------------------------------------------------------
int __cdecl sub_10010580(_DWORD *a1)
{
  double v1; // st7

  v1 = sub_10015700(a1, 1);
  sub_1000F1E0((int)a1, __FYL2X__(v1, 0.69314718055994528623));
  return 1;
}

//----- (100105B0) --------------------------------------------------------
int __cdecl sub_100105B0(_DWORD *a1)
{
  double v1; // st7

  v1 = sub_10015700(a1, 1);
  sub_1000F1E0((int)a1, __FYL2X__(v1, 0.30102999566398119802));
  return 1;
}

//----- (100105E0) --------------------------------------------------------
int __cdecl sub_100105E0(_DWORD *a1)
{
  double v1; // st7

  v1 = sub_10015700(a1, 1) * 1.442695040888963387;
  _ST6 = v1;
  __asm { frndint }
  sub_1000F1E0((int)a1, __FSCALE__(__F2XM1__(v1 - _ST6) + 1.0, _ST6));
  return 1;
}

//----- (10010620) --------------------------------------------------------
int __cdecl sub_10010620(_DWORD *a1)
{
  double v1; // st7

  v1 = sub_10015700(a1, 1);
  sub_1000F1E0((int)a1, v1 * 57.29577951308232);
  return 1;
}

//----- (10010650) --------------------------------------------------------
int __cdecl sub_10010650(_DWORD *a1)
{
  double v1; // st7

  v1 = sub_10015700(a1, 1);
  sub_1000F1E0((int)a1, v1 * 0.0174532925199433);
  return 1;
}

//----- (10010680) --------------------------------------------------------
int __cdecl sub_10010680(_DWORD *a1)
{
  double X; // st7
  double v2; // st7
  int Y; // [esp+10h] [ebp-4h] BYREF

  X = sub_10015700(a1, 1);
  v2 = frexp(X, &Y);
  sub_1000F1E0((int)a1, v2);
  sub_1000F1E0((int)a1, (double)Y);
  return 2;
}

//----- (100106D0) --------------------------------------------------------
int __cdecl sub_100106D0(_DWORD *a1)
{
  double X; // st7
  double v2; // st7
  int v4; // [esp+8h] [ebp-8h]

  v4 = (unsigned __int64)sub_10015700(a1, 2);
  X = sub_10015700(a1, 1);
  v2 = ldexp(X, v4);
  sub_1000F1E0((int)a1, v2);
  return 1;
}

//----- (10010710) --------------------------------------------------------
int __cdecl sub_10010710(_DWORD *a1)
{
  int v1; // ebx
  int i; // esi
  double v3; // st7
  double v5; // [esp+18h] [ebp-8h]

  v1 = sub_1000EBC0((int)a1);
  v5 = sub_10015700(a1, 1);
  for ( i = 2; i <= v1; ++i )
  {
    v3 = sub_10015700(a1, i);
    if ( v3 < v5 )
      v5 = v3;
  }
  sub_1000F1E0((int)a1, v5);
  return 1;
}

//----- (10010790) --------------------------------------------------------
int __cdecl sub_10010790(_DWORD *a1)
{
  int v1; // ebx
  int i; // esi
  double v3; // st7
  double v5; // [esp+18h] [ebp-8h]

  v1 = sub_1000EBC0((int)a1);
  v5 = sub_10015700(a1, 1);
  for ( i = 2; i <= v1; ++i )
  {
    v3 = sub_10015700(a1, i);
    if ( v3 > v5 )
      v5 = v3;
  }
  sub_1000F1E0((int)a1, v5);
  return 1;
}

//----- (10010810) --------------------------------------------------------
int __cdecl sub_10010810(_DWORD *a1)
{
  int v1; // eax
  int v2; // eax
  int v3; // ebx
  unsigned __int64 v4; // rax
  double v5; // st7
  int v7; // [esp+14h] [ebp-Ch]
  double v8; // [esp+18h] [ebp-8h]

  v8 = (double)(rand() % 0x7FFF) * 0.00003051850947599719;
  v1 = sub_1000EBC0((int)a1);
  if ( v1 )
  {
    v2 = v1 - 1;
    if ( v2 )
    {
      if ( v2 != 1 )
        sub_10014BC0(a1, "wrong number of arguments");
      v3 = (unsigned __int64)sub_10015700(a1, 1);
      v4 = (unsigned __int64)sub_10015700(a1, 2);
      if ( v3 > (int)v4 )
        sub_10015510(a1, 2, "interval is empty");
      v5 = (double)(int)(v3 + (unsigned __int64)floor((double)((int)v4 - v3 + 1) * v8));
    }
    else
    {
      v7 = (unsigned __int64)sub_10015700(a1, 1);
      if ( v7 < 1 )
        sub_10015510(a1, 1, "interval is empty");
      v5 = (double)(int)((unsigned __int64)floor((double)v7 * v8) + 1);
    }
  }
  else
  {
    v5 = v8;
  }
  sub_1000F1E0((int)a1, v5);
  return 1;
}

//----- (10010940) --------------------------------------------------------
int __cdecl sub_10010940(_DWORD *a1)
{
  double v1; // st7

  v1 = sub_10015700(a1, 1);
  srand((unsigned __int64)v1);
  return 0;
}

//----- (10010960) --------------------------------------------------------
int __cdecl sub_10010960(_DWORD *a1)
{
  unsigned int v2; // [esp+Ch] [ebp-8h] BYREF

  sub_10015630(a1, 1, (int *)&v2);
  sub_1000F1E0((int)a1, (double)v2);
  return 1;
}

//----- (100109A0) --------------------------------------------------------
int __cdecl sub_100109A0(_DWORD *a1)
{
  int v1; // eax
  int v2; // esi
  int v3; // ebp
  unsigned __int64 v4; // rax
  int v5; // esi
  int v6; // ebx
  unsigned __int64 v7; // rax
  int v9; // [esp+18h] [ebp-4h] BYREF

  v1 = sub_10015630(a1, 1, &v9);
  v2 = v9;
  v3 = v1;
  v4 = (unsigned __int64)sub_10015700(a1, 2);
  if ( (v4 & 0x80000000) != 0i64 )
    v5 = v4 + v2 + 1;
  else
    v5 = v4;
  v6 = v9;
  v7 = (unsigned __int64)sub_10015780(a1, 3, -1.0);
  if ( (v7 & 0x80000000) != 0i64 )
    LODWORD(v7) = v7 + v6 + 1;
  if ( v5 < 1 )
    v5 = 1;
  if ( (int)v7 > v9 )
    LODWORD(v7) = v9;
  if ( v5 > (int)v7 )
    sub_1000F200(a1, byte_1003D986, 0);
  else
    sub_1000F200(a1, (char *)(v5 + v3 - 1), v7 - v5 + 1);
  return 1;
}

//----- (10010A50) --------------------------------------------------------
int __cdecl sub_10010A50(_DWORD *a1)
{
  int v1; // edi
  unsigned int i; // esi
  unsigned int v4; // [esp+8h] [ebp-210h] BYREF
  int v5[131]; // [esp+Ch] [ebp-20Ch] BYREF
  void *retaddr; // [esp+218h] [ebp+0h] BYREF

  v1 = sub_10015630(a1, 1, (int *)&v4);
  sub_10015270((int)a1, v5);
  for ( i = 0; i < v4; ++v5[0] )
  {
    if ( v5[0] >= (unsigned int)&retaddr )
      sub_100150E0((int)v5);
    *(_BYTE *)v5[0] = tolower(*(unsigned __int8 *)(i + v1));
    ++i;
  }
  sub_10015180((int)v5);
  return 1;
}

//----- (10010AF0) --------------------------------------------------------
int __cdecl sub_10010AF0(_DWORD *a1)
{
  int v1; // edi
  unsigned int i; // esi
  unsigned int v4; // [esp+8h] [ebp-210h] BYREF
  int v5[131]; // [esp+Ch] [ebp-20Ch] BYREF
  void *retaddr; // [esp+218h] [ebp+0h] BYREF

  v1 = sub_10015630(a1, 1, (int *)&v4);
  sub_10015270((int)a1, v5);
  for ( i = 0; i < v4; ++v5[0] )
  {
    if ( v5[0] >= (unsigned int)&retaddr )
      sub_100150E0((int)v5);
    *(_BYTE *)v5[0] = sub_10028174(*(unsigned __int8 *)(i + v1));
    ++i;
  }
  sub_10015180((int)v5);
  return 1;
}

//----- (10010B90) --------------------------------------------------------
int __cdecl sub_10010B90(_DWORD *a1)
{
  _BYTE *v1; // ebx
  int v2; // edi
  _BYTE *v4; // [esp+Ch] [ebp-210h] BYREF
  _DWORD v5[131]; // [esp+10h] [ebp-20Ch] BYREF

  v1 = (_BYTE *)sub_10015630(a1, 1, (int *)&v4);
  v2 = (unsigned __int64)sub_10015700(a1, 2);
  sub_10015270((int)a1, v5);
  if ( v2 > 0 )
  {
    do
    {
      sub_10015120((int)v5, v1, v4);
      --v2;
    }
    while ( v2 );
  }
  sub_10015180((int)v5);
  return 1;
}
// 10010B90: using guessed type _DWORD var_20C[131];

//----- (10010C10) --------------------------------------------------------
int __cdecl sub_10010C10(_DWORD *a1)
{
  int v1; // eax
  unsigned int v2; // edi
  int v3; // ebx
  unsigned __int64 v4; // rax
  bool v5; // cc
  unsigned int v7; // [esp+14h] [ebp-8h] BYREF

  v1 = sub_10015630(a1, 1, (int *)&v7);
  v2 = v7;
  v3 = v1;
  v4 = (unsigned __int64)sub_10015780(a1, 2, 1.0);
  v5 = (int)v4 <= 0;
  if ( (v4 & 0x80000000) != 0i64 )
  {
    LODWORD(v4) = v4 + v2 + 1;
    v5 = (int)v4 <= 0;
  }
  if ( v5 || (unsigned int)v4 > v7 )
    return 0;
  sub_1000F1E0((int)a1, (double)*(unsigned __int8 *)(v4 + v3 - 1));
  return 1;
}

//----- (10010C90) --------------------------------------------------------
int __cdecl sub_10010C90(_DWORD *a1)
{
  int v1; // ebp
  int i; // esi
  unsigned __int64 v3; // rax
  char v4; // bl
  int v6[131]; // [esp+Ch] [ebp-20Ch] BYREF
  void *retaddr; // [esp+218h] [ebp+0h] BYREF

  v1 = sub_1000EBC0((int)a1);
  sub_10015270((int)a1, v6);
  for ( i = 1; i <= v1; ++v6[0] )
  {
    v3 = (unsigned __int64)sub_10015700(a1, i);
    v4 = v3;
    if ( (unsigned __int8)v3 != (_DWORD)v3 )
      sub_10015510(a1, i, "invalid value");
    if ( v6[0] >= (unsigned int)&retaddr )
      sub_100150E0((int)v6);
    *(_BYTE *)v6[0] = v4;
    ++i;
  }
  sub_10015180((int)v6);
  return 1;
}

//----- (10010D40) --------------------------------------------------------
int __cdecl sub_10010D40(int a1, _BYTE *a2, _BYTE *a3, int a4)
{
  sub_10015120(a4, a2, a3);
  return 1;
}

//----- (10010D60) --------------------------------------------------------
int __cdecl sub_10010D60(_DWORD *a1)
{
  _DWORD v2[131]; // [esp+4h] [ebp-20Ch] BYREF

  sub_100155B0(a1, 1, 6);
  sub_10015270((int)a1, v2);
  if ( !sub_1000F8B0((int)a1, (int)sub_10010D40, (int)v2) )
    sub_10014BC0(a1, "unable to dump given function");
  sub_10015180((int)v2);
  return 1;
}
// 10010D60: using guessed type _DWORD var_20C[131];

//----- (10010DD0) --------------------------------------------------------
char *__usercall sub_10010DD0@<eax>(char *a1@<eax>, int a2@<edi>)
{
  int v3; // eax
  char *v4; // esi
  char v6; // cl

  v3 = *a1;
  v4 = a1 + 1;
  if ( v3 == 37 )
  {
    if ( !*v4 )
      sub_10014BC0(*(_DWORD **)(a2 + 8), "malformed pattern (ends with `%')");
    return v4 + 1;
  }
  else if ( v3 == 91 )
  {
    if ( *v4 == 94 )
      ++v4;
    do
    {
      if ( !*v4 )
        sub_10014BC0(*(_DWORD **)(a2 + 8), "malformed pattern (missing `]')");
      v6 = *v4++;
      if ( v6 == 37 )
      {
        if ( *v4 )
          ++v4;
      }
    }
    while ( *v4 != 93 );
    return v4 + 1;
  }
  else
  {
    return v4;
  }
}

//----- (10010E40) --------------------------------------------------------
BOOL __usercall sub_10010E40@<eax>(int a1@<eax>, int a2@<edi>)
{
  int v3; // esi
  BOOL result; // eax
  int v5; // [esp+0h] [ebp-8h]

  switch ( tolower(v5) )
  {
    case 'a':
      v3 = isalpha(a1);
      goto LABEL_12;
    case 'c':
      v3 = iscntrl(a1);
      goto LABEL_12;
    case 'd':
      v3 = isdigit(a1);
      goto LABEL_12;
    case 'l':
      v3 = islower(a1);
      goto LABEL_12;
    case 'p':
      v3 = ispunct(a1);
      goto LABEL_12;
    case 's':
      v3 = isspace(a1);
      goto LABEL_12;
    case 'u':
      v3 = isupper(a1);
      goto LABEL_12;
    case 'w':
      v3 = isalnum(a1);
      goto LABEL_12;
    case 'x':
      v3 = isxdigit(a1);
      goto LABEL_12;
    case 'z':
      v3 = a1 == 0;
LABEL_12:
      if ( islower(a2) )
        result = v3;
      else
        result = v3 == 0;
      break;
    default:
      result = a2 == a1;
      break;
  }
  return result;
}
// 10010E44: variable 'v5' is possibly undefined

//----- (10010F50) --------------------------------------------------------
BOOL __usercall sub_10010F50@<eax>(int a1@<eax>, int a2@<ebx>, unsigned int a3)
{
  int v3; // esi
  unsigned int v4; // ecx
  unsigned __int8 *v5; // esi
  unsigned __int8 *v6; // ebp
  int v7; // edi
  int v8; // eax
  int v10; // [esp+Ch] [ebp-4h]

  v3 = a1;
  v10 = 1;
  if ( *(_BYTE *)(a1 + 1) == 94 )
  {
    v10 = 0;
    v3 = a1 + 1;
  }
  v4 = a3;
  v5 = (unsigned __int8 *)(v3 + 1);
  if ( (unsigned int)v5 < a3 )
  {
    v6 = v5 + 2;
    do
    {
      if ( *v5 == 37 )
      {
        v7 = (char)*++v5;
        ++v6;
        if ( sub_10010E40(a2, v7) )
          return v10;
        v4 = a3;
      }
      else if ( v5[1] == 45 && (unsigned int)v6 < v4 )
      {
        v8 = *v5;
        v5 += 2;
        v6 += 2;
        if ( v8 <= a2 && a2 <= *v5 )
          return v10;
      }
      else if ( *v5 == a2 )
      {
        return v10;
      }
      ++v5;
      ++v6;
    }
    while ( (unsigned int)v5 < v4 );
  }
  return v10 == 0;
}

//----- (10010FF0) --------------------------------------------------------
char *__usercall sub_10010FF0@<eax>(char *a1@<eax>, _BYTE *a2@<ecx>, int a3@<ebx>)
{
  char v5; // al
  unsigned int v7; // ecx
  int v8; // edx
  char *v9; // esi
  int v10; // ebp
  int i; // edi
  int v12; // eax

  if ( !*a1 || !a1[1] )
    sub_10014BC0(*(_DWORD **)(a3 + 8), "unbalanced pattern");
  v5 = *a1;
  if ( *a2 != *a1 )
    return 0;
  v7 = *(_DWORD *)(a3 + 4);
  v8 = a1[1];
  v9 = a2 + 1;
  v10 = v5;
  for ( i = 1; (unsigned int)v9 < v7; ++v9 )
  {
    v12 = *v9;
    if ( v12 == v8 )
    {
      if ( !--i )
        return v9 + 1;
    }
    else if ( v12 == v10 )
    {
      ++i;
    }
  }
  return 0;
}

//----- (10011060) --------------------------------------------------------
char *__usercall sub_10011060@<eax>(unsigned __int8 *a1@<eax>, int a2, unsigned __int8 *a3, int a4)
{
  unsigned __int8 *v4; // ebp
  int v6; // edi
  unsigned __int8 v7; // al
  int v8; // ebx
  BOOL v9; // eax
  char *result; // eax
  int v11; // [esp+Ch] [ebp-4h]

  v4 = a3;
  v6 = 0;
  v11 = 0;
  if ( (unsigned int)a3 < *(_DWORD *)(a2 + 4) )
  {
    while ( 1 )
    {
      v7 = *a1;
      v8 = *v4;
      if ( *a1 == 37 )
        break;
      if ( v7 != 46 )
      {
        if ( v7 == 91 )
          v9 = sub_10010F50((int)a1, v8, a4 - 1);
        else
          v9 = v8 == v7;
LABEL_8:
        if ( !v9 )
          goto LABEL_10;
      }
      ++v6;
      ++v4;
      v11 = v6;
      if ( (unsigned int)v4 >= *(_DWORD *)(a2 + 4) )
      {
LABEL_10:
        if ( v6 >= 0 )
          goto LABEL_11;
        return 0;
      }
    }
    v9 = sub_10010E40(*v4, (char)a1[1]);
    v6 = v11;
    goto LABEL_8;
  }
LABEL_11:
  while ( 1 )
  {
    result = sub_100112B0(a2, (char *)&a3[v6], (char *)(a4 + 1));
    if ( result )
      break;
    if ( --v6 < 0 )
      return 0;
  }
  return result;
}

//----- (10011110) --------------------------------------------------------
char *__usercall sub_10011110@<eax>(char *a1@<eax>, int a2, unsigned __int8 *a3, int a4)
{
  int v4; // edi
  char *v5; // esi
  char *result; // eax
  unsigned __int8 v7; // al
  int v8; // ebx
  BOOL v9; // eax

  v4 = a4;
  v5 = a1;
  for ( result = sub_100112B0(a2, a1, (char *)(a4 + 1)); !result; result = sub_100112B0(a2, ++v5, (char *)(v4 + 1)) )
  {
    if ( (unsigned int)v5 >= *(_DWORD *)(a2 + 4) )
      return 0;
    v7 = *a3;
    v8 = (unsigned __int8)*v5;
    if ( *a3 == 37 )
    {
      v9 = sub_10010E40((unsigned __int8)*v5, (char)a3[1]);
      v4 = a4;
    }
    else
    {
      if ( v7 == 46 )
        continue;
      if ( v7 == 91 )
        v9 = sub_10010F50((int)a3, v8, v4 - 1);
      else
        v9 = v8 == v7;
    }
    if ( !v9 )
      return 0;
  }
  return result;
}

//----- (100111B0) --------------------------------------------------------
char *__usercall sub_100111B0@<eax>(char *a1@<ebx>, int a2@<esi>, char *a3, int a4)
{
  int v4; // edi
  char *result; // eax

  v4 = *(_DWORD *)(a2 + 12);
  if ( v4 >= 32 )
    sub_10014BC0(*(_DWORD **)(a2 + 8), "too many captures");
  *(_DWORD *)(a2 + 8 * v4 + 16) = a1;
  *(_DWORD *)(a2 + 8 * v4 + 20) = a4;
  *(_DWORD *)(a2 + 12) = v4 + 1;
  result = sub_100112B0(a2, a1, a3);
  if ( !result )
    --*(_DWORD *)(a2 + 12);
  return result;
}

//----- (10011200) --------------------------------------------------------
char *__usercall sub_10011200@<eax>(char *a1@<ebx>, int a2@<esi>, char *a3)
{
  int v3; // eax
  _DWORD *v4; // ecx
  int v5; // edi
  char *result; // eax

  v3 = *(_DWORD *)(a2 + 12) - 1;
  if ( v3 < 0 )
LABEL_5:
    sub_10014BC0(*(_DWORD **)(a2 + 8), "invalid pattern capture");
  v4 = (_DWORD *)(a2 + 8 * v3 + 20);
  while ( *v4 != -1 )
  {
    --v3;
    v4 -= 2;
    if ( v3 < 0 )
      goto LABEL_5;
  }
  v5 = v3;
  *(_DWORD *)(a2 + 8 * v3 + 20) = &a1[-*(_DWORD *)(a2 + 8 * v3 + 16)];
  result = sub_100112B0(a2, a1, a3);
  if ( !result )
    *(_DWORD *)(a2 + 8 * v5 + 20) = -1;
  return result;
}

//----- (10011260) --------------------------------------------------------
char *__usercall sub_10011260@<eax>(int a1@<eax>, int a2@<ecx>, char *a3@<ebx>)
{
  int v3; // eax
  unsigned int v4; // edx

  v3 = a1 - 49;
  if ( v3 < 0 || v3 >= *(_DWORD *)(a2 + 12) || *(_DWORD *)(a2 + 8 * v3 + 20) == -1 )
    sub_10014BC0(*(_DWORD **)(a2 + 8), "invalid capture index");
  v4 = *(_DWORD *)(a2 + 8 * v3 + 20);
  if ( *(_DWORD *)(a2 + 4) - (int)a3 >= v4
    && !memcmp(*(const void **)(a2 + 8 * v3 + 16), a3, *(_DWORD *)(a2 + 8 * v3 + 20)) )
  {
    return &a3[v4];
  }
  else
  {
    return 0;
  }
}

//----- (100112B0) --------------------------------------------------------
char *__cdecl sub_100112B0(int a1, char *a2, char *a3)
{
  char *v4; // ebp
  unsigned __int8 v5; // al
  char v6; // al
  char *v7; // ebp
  char *v8; // eax
  unsigned __int8 v9; // cl
  unsigned int v10; // edi
  char *result; // eax
  char *v12; // ebx
  int v13; // edx
  unsigned __int8 v14; // al
  int v15; // ecx
  BOOL v16; // eax
  int v17; // ecx

LABEL_1:
  v4 = a3;
  while ( 2 )
  {
    switch ( *v4 )
    {
      case 0:
        return a2;
      case 36:
        if ( v4[1] )
          goto LABEL_20;
        return a2 != *(char **)(a1 + 4) ? 0 : a2;
      case 37:
        v5 = v4[1];
        if ( v5 == 98 )
        {
          a2 = sub_10010FF0(v4 + 2, a2, a1);
          if ( !a2 )
            return 0;
          v4 += 4;
          continue;
        }
        if ( v5 != 102 )
        {
          if ( !isdigit(v5) )
          {
LABEL_20:
            v12 = sub_10010DD0(v4, a1);
            v13 = a1;
            if ( (unsigned int)a2 >= *(_DWORD *)(a1 + 4) )
              goto LABEL_30;
            v14 = *v4;
            v15 = (unsigned __int8)*a2;
            if ( *v4 == 37 )
            {
              v16 = sub_10010E40((unsigned __int8)*a2, v4[1]);
              goto LABEL_27;
            }
            if ( v14 == 46 )
              goto LABEL_29;
            if ( v14 != 91 )
            {
              v16 = v15 == v14;
              goto LABEL_28;
            }
            v16 = sub_10010F50((int)v4, v15, (unsigned int)(v12 - 1));
LABEL_27:
            v13 = a1;
LABEL_28:
            if ( v16 )
LABEL_29:
              v17 = 1;
            else
LABEL_30:
              v17 = 0;
            switch ( *v12 )
            {
              case '*':
                return sub_10011060((unsigned __int8 *)v4, v13, (unsigned __int8 *)a2, (int)v12);
              case '+':
                if ( !v17 )
                  return 0;
                return sub_10011060((unsigned __int8 *)v4, v13, (unsigned __int8 *)a2 + 1, (int)v12);
              case '-':
                return sub_10011110(a2, v13, (unsigned __int8 *)v4, (int)v12);
              case '?':
                if ( v17 )
                {
                  result = sub_100112B0(v13, a2 + 1, v12 + 1);
                  if ( result )
                    return result;
                }
                v4 = v12 + 1;
                continue;
              default:
                if ( !v17 )
                  return 0;
                ++a2;
                v4 = v12;
                continue;
            }
          }
          a2 = sub_10011260(v4[1], a1, a2);
          if ( !a2 )
            return 0;
          v4 += 2;
          continue;
        }
        v6 = v4[2];
        v7 = v4 + 2;
        if ( v6 != 91 )
          sub_10014BC0(*(_DWORD **)(a1 + 8), "missing `[' after `%%f' in pattern");
        v8 = sub_10010DD0(v7, a1);
        a3 = v8;
        if ( a2 == *(char **)a1 )
          v9 = 0;
        else
          v9 = *(a2 - 1);
        v10 = (unsigned int)(v8 - 1);
        if ( !sub_10010F50((int)v7, v9, (unsigned int)(v8 - 1)) && sub_10010F50((int)v7, (unsigned __int8)*a2, v10) )
          goto LABEL_1;
        return 0;
      case 40:
        if ( v4[1] == 41 )
          return sub_100111B0(a2, a1, v4 + 2, -2);
        else
          return sub_100111B0(a2, a1, v4 + 1, -1);
      case 41:
        return sub_10011200(a2, a1, v4 + 1);
      default:
        goto LABEL_20;
    }
  }
}

//----- (10011570) --------------------------------------------------------
char *__usercall sub_10011570@<eax>(char *result@<eax>, unsigned int a2, char *a3, unsigned int a4)
{
  char *v4; // ebx
  unsigned int v5; // edi
  size_t v6; // ebp
  char *v7; // eax
  char *v8; // eax
  int v9; // ebx
  bool v10; // zf
  unsigned int v11; // [esp+18h] [ebp+Ch]

  v4 = result;
  if ( a4 )
  {
    if ( a4 <= a2 )
    {
      v5 = a4 - 1;
      v6 = a2 - (a4 - 1);
      v11 = a4 - 1;
      if ( v6 )
      {
        while ( 1 )
        {
          v7 = (char *)memchr(v4, *a3, v6);
          if ( !v7 )
            break;
          v8 = v7 + 1;
          if ( !memcmp(v8, a3 + 1, v5) )
            return v8 - 1;
          v9 = v4 - v8;
          v10 = v9 + v6 == 0;
          v6 += v9;
          v4 = v8;
          if ( v10 )
            return 0;
          v5 = v11;
        }
      }
      return 0;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

//----- (100115E0) --------------------------------------------------------
int __usercall sub_100115E0@<eax>(int a1@<eax>, _DWORD *a2@<esi>)
{
  unsigned int v2; // edi

  v2 = a2[2 * a1 + 5];
  if ( v2 == -1 )
    sub_10014BC0((_DWORD *)a2[2], "unfinished capture");
  if ( v2 == -2 )
    return sub_1000F1E0(a2[2], (double)(a2[2 * a1 + 4] - *a2 + 1));
  else
    return sub_1000F200((_DWORD *)a2[2], (char *)a2[2 * a1 + 4], v2);
}

//----- (10011650) --------------------------------------------------------
int __usercall sub_10011650@<eax>(int a1@<eax>, char *a2@<ecx>, _DWORD *a3@<esi>)
{
  int v5; // eax
  char **v7; // edi
  char *v8; // ebx
  int v9; // [esp+10h] [ebp-8h]

  sub_10014D00((_DWORD *)a3[2], a3[3], "too many captures");
  v5 = a3[3];
  if ( v5 || !a2 )
  {
    v9 = 0;
    if ( v5 > 0 )
    {
      v7 = (char **)(a3 + 4);
      do
      {
        v8 = v7[1];
        if ( v8 == (char *)-1 )
          sub_10014BC0((_DWORD *)a3[2], "unfinished capture");
        if ( v8 == (char *)-2 )
          sub_1000F1E0(a3[2], (double)(int)&(*v7)[-*a3 + 1]);
        else
          sub_1000F200((_DWORD *)a3[2], *v7, (unsigned int)v7[1]);
        v7 += 2;
        ++v9;
      }
      while ( v9 < a3[3] );
    }
    return a3[3];
  }
  else
  {
    sub_1000F200((_DWORD *)a3[2], a2, a1 - (_DWORD)a2);
    return 1;
  }
}

//----- (10011720) --------------------------------------------------------
int __cdecl sub_10011720(_DWORD *a1)
{
  int v1; // ebx
  int v2; // eax
  unsigned int v3; // esi
  unsigned __int64 v4; // rax
  unsigned int v5; // esi
  char *v6; // esi
  char *v7; // ebx
  unsigned int v8; // ecx
  char *v10; // eax
  char *v11; // esi
  int v12; // [esp+14h] [ebp-124h]
  char *Str; // [esp+18h] [ebp-120h]
  int v14; // [esp+1Ch] [ebp-11Ch]
  unsigned int v15; // [esp+20h] [ebp-118h] BYREF
  unsigned int v16; // [esp+24h] [ebp-114h] BYREF
  int v17; // [esp+28h] [ebp-110h] BYREF
  unsigned int v18; // [esp+2Ch] [ebp-10Ch]
  _DWORD *v19; // [esp+30h] [ebp-108h]
  int v20; // [esp+34h] [ebp-104h]

  v1 = sub_10015630(a1, 1, (int *)&v15);
  v12 = v1;
  v2 = sub_10015630(a1, 2, (int *)&v16);
  v3 = v15;
  Str = (char *)v2;
  v4 = (unsigned __int64)sub_10015780(a1, 3, 1.0);
  if ( (v4 & 0x80000000) != 0i64 )
    LODWORD(v4) = v4 + v3 + 1;
  v5 = v4 - 1;
  if ( (int)v4 - 1 >= 0 )
  {
    if ( v5 > v15 )
      v5 = v15;
  }
  else
  {
    v5 = 0;
  }
  if ( sub_1000EFD0(a1, 4) || !strpbrk(Str, "^$*+?.([%-") )
  {
    v10 = sub_10011570((char *)(v5 + v1), v15 - v5, Str, v16);
    if ( v10 )
    {
      v11 = &v10[-v1];
      sub_1000F1E0((int)a1, (double)(int)&v10[-v1 + 1]);
      sub_1000F1E0((int)a1, (double)(unsigned int)&v11[v16]);
      return 2;
    }
    else
    {
LABEL_16:
      sub_1000F1C0((int)a1);
      return 1;
    }
  }
  else
  {
    if ( *Str == 94 )
    {
      ++Str;
      v14 = 1;
    }
    else
    {
      v14 = 0;
    }
    v6 = (char *)(v1 + v5);
    v19 = a1;
    v17 = v1;
    v18 = v1 + v15;
    while ( 1 )
    {
      v20 = 0;
      v7 = sub_100112B0((int)&v17, v6, Str);
      if ( v7 )
        break;
      v8 = (unsigned int)v6++;
      if ( v8 >= v18 || v14 )
        goto LABEL_16;
    }
    sub_1000F1E0((int)a1, (double)(int)&v6[-v12 + 1]);
    sub_1000F1E0((int)a1, (double)(int)&v7[-v12]);
    return sub_10011650(0, 0, &v17) + 2;
  }
}

//----- (10011900) --------------------------------------------------------
int __cdecl sub_10011900(_DWORD *a1)
{
  int v1; // ebp
  int v2; // esi
  char *v3; // esi
  char *v4; // eax
  int v5; // ebx
  char *v7; // eax
  char *v8; // [esp+18h] [ebp-114h]
  int v9; // [esp+18h] [ebp-114h]
  int v10; // [esp+1Ch] [ebp-110h] BYREF
  unsigned int v11; // [esp+20h] [ebp-10Ch]
  _DWORD *v12; // [esp+24h] [ebp-108h]
  int v13; // [esp+28h] [ebp-104h]

  v1 = sub_1000F010(a1, -10002);
  v2 = sub_1000F080(a1, -10002);
  v8 = (char *)sub_1000F010(a1, -10003);
  v12 = a1;
  v10 = v1;
  v11 = v1 + v2;
  v3 = (char *)(v1 + (unsigned __int64)sub_1000EF80(a1, -10004));
  if ( (unsigned int)v3 > v11 )
    return 0;
  while ( 1 )
  {
    v13 = 0;
    v4 = sub_100112B0((int)&v10, v3, v8);
    v5 = (int)v4;
    if ( v4 )
      break;
    if ( (unsigned int)++v3 > v11 )
      return 0;
  }
  v7 = &v4[-v1];
  v9 = v5 - v1;
  if ( (char *)v5 == v3 )
    v9 = (int)(v7 + 1);
  sub_1000F1E0((int)a1, (double)v9);
  sub_1000ECF0(a1, -10004);
  return sub_10011650(v5, v3, &v10);
}

//----- (100119F0) --------------------------------------------------------
int __cdecl sub_100119F0(_DWORD *a1)
{
  sub_10015630(a1, 1, 0);
  sub_10015630(a1, 2, 0);
  sub_1000EBD0((int)a1, 2);
  sub_1000F1E0((int)a1, 0.0);
  sub_1000F320(a1, (int)sub_10011900, 3);
  return 1;
}

//----- (10011A40) --------------------------------------------------------
int __usercall sub_10011A40@<eax>(_DWORD *a1@<eax>, _DWORD *a2@<ebx>, char *a3, int a4)
{
  _DWORD *v5; // edi
  int v6; // ebp
  int result; // eax
  unsigned int v8; // edi
  int v9; // eax
  int v10; // eax
  int v11; // eax
  unsigned int i; // [esp+8h] [ebp-4h]

  v5 = (_DWORD *)a1[2];
  if ( sub_1000EE60(v5, 3) )
  {
    v6 = sub_1000F010(v5, 3);
    result = sub_1000F080(v5, 3);
    v8 = 0;
    for ( i = result; v8 < i; ++v8 )
    {
      if ( *(_BYTE *)(v8 + v6) == 37 )
      {
        v9 = *(unsigned __int8 *)(v8 + v6 + 1);
        ++v8;
        if ( isdigit(v9) )
        {
          v10 = *(char *)(v8 + v6) - 49;
          if ( v10 < 0 || v10 >= a1[3] || a1[2 * v10 + 5] == -1 )
            sub_10014BC0((_DWORD *)a1[2], "invalid capture index");
          sub_100115E0(v10, a1);
          sub_100151D0((int)a2);
        }
        else
        {
          if ( *a2 >= (unsigned int)(a2 + 131) )
            sub_100150E0((int)a2);
          *(_BYTE *)(*a2)++ = *(_BYTE *)(v8 + v6);
        }
      }
      else
      {
        if ( *a2 >= (unsigned int)(a2 + 131) )
          sub_100150E0((int)a2);
        *(_BYTE *)(*a2)++ = *(_BYTE *)(v8 + v6);
      }
      result = i;
    }
  }
  else
  {
    sub_1000ED40(v5, 3);
    v11 = sub_10011650(a4, a3, a1);
    sub_1000F7B0((int)v5, v11, 1);
    if ( sub_1000EE60(v5, -1) )
      return sub_100151D0((int)a2);
    else
      return sub_1000EBD0((int)v5, -2);
  }
  return result;
}

//----- (10011B70) --------------------------------------------------------
int __cdecl sub_10011B70(_DWORD *a1)
{
  char *v1; // esi
  char *v2; // edi
  int v3; // ebx
  unsigned int v4; // eax
  char *v5; // eax
  char *v6; // edi
  int v8; // [esp+18h] [ebp-330h]
  int v9; // [esp+1Ch] [ebp-32Ch]
  char *v10; // [esp+24h] [ebp-324h]
  int v11; // [esp+28h] [ebp-320h] BYREF
  char *v12; // [esp+2Ch] [ebp-31Ch] BYREF
  unsigned int v13; // [esp+30h] [ebp-318h]
  _DWORD *v14; // [esp+34h] [ebp-314h]
  int v15; // [esp+38h] [ebp-310h]
  int v16[131]; // [esp+13Ch] [ebp-20Ch] BYREF
  void *retaddr; // [esp+348h] [ebp+0h] BYREF

  v1 = (char *)sub_10015630(a1, 1, &v11);
  v2 = (char *)sub_10015630(a1, 2, 0);
  v10 = v2;
  v3 = (unsigned __int64)sub_10015780(a1, 4, (double)(unsigned int)(v11 + 1));
  if ( *v2 == 94 )
  {
    v10 = ++v2;
    v9 = 1;
  }
  else
  {
    v9 = 0;
  }
  v8 = 0;
  if ( sub_1000EBC0((int)a1) < 3 || !sub_1000EE60(a1, 3) && sub_1000ED80(a1, 3) != 6 )
    sub_10015510(a1, 3, "string or function expected");
  sub_10015270((int)a1, v16);
  v4 = (unsigned int)&v1[v11];
  v14 = a1;
  v12 = v1;
  v13 = (unsigned int)&v1[v11];
  if ( v3 > 0 )
  {
    while ( 1 )
    {
      v15 = 0;
      v5 = sub_100112B0((int)&v12, v1, v2);
      v6 = v5;
      if ( v5 && (++v8, sub_10011A40(&v12, v16, v1, (int)v5), v6 > v1) )
      {
        v1 = v6;
      }
      else
      {
        v4 = v13;
        if ( (unsigned int)v1 >= v13 )
          goto LABEL_21;
        if ( v16[0] >= (unsigned int)&retaddr )
          sub_100150E0((int)v16);
        *(_BYTE *)v16[0]++ = *v1++;
      }
      if ( v9 || v8 >= v3 )
        break;
      v2 = v10;
    }
    v4 = v13;
  }
LABEL_21:
  sub_10015120((int)v16, v1, (_BYTE *)(v4 - (_DWORD)v1));
  sub_10015180((int)v16);
  sub_1000F1E0((int)a1, (double)v8);
  return 2;
}

//----- (10011D40) --------------------------------------------------------
int __usercall sub_10011D40@<eax>(_DWORD *a1@<edx>, int a2@<ecx>, int *a3@<esi>)
{
  _BYTE *v3; // edi
  _DWORD *v4; // ebx
  bool v5; // zf
  unsigned int v6; // eax
  int result; // eax
  bool v8; // cf
  int v9; // [esp+8h] [ebp-4h] BYREF

  v3 = (_BYTE *)sub_10015630(a1, a2, &v9);
  v4 = a3 + 131;
  if ( *a3 >= (unsigned int)(a3 + 131) )
    sub_100150E0((int)a3);
  *(_BYTE *)*a3 = 34;
  v5 = v9 == 0;
  ++*a3;
  if ( !v5 )
  {
    do
    {
      --v9;
      switch ( *v3 )
      {
        case 0:
          sub_10015120((int)a3, "\\000", (_BYTE *)4);
          break;
        case 0xA:
        case 0x22:
        case 0x5C:
          if ( *a3 >= (unsigned int)v4 )
            sub_100150E0((int)a3);
          *(_BYTE *)*a3 = 92;
          v6 = *a3 + 1;
          *a3 = v6;
          if ( v6 >= (unsigned int)v4 )
            sub_100150E0((int)a3);
          *(_BYTE *)*a3 = *v3;
          goto LABEL_14;
        default:
          if ( *a3 >= (unsigned int)v4 )
            sub_100150E0((int)a3);
          *(_BYTE *)*a3 = *v3;
LABEL_14:
          ++*a3;
          break;
      }
      ++v3;
    }
    while ( v9 );
  }
  result = *a3;
  v8 = *a3 < (unsigned int)v4;
  --v9;
  if ( !v8 )
    result = sub_100150E0((int)a3);
  *(_BYTE *)(*a3)++ = 34;
  return result;
}

//----- (10011E90) --------------------------------------------------------
const char *__usercall sub_10011E90@<eax>(const char *a1@<ebx>, _DWORD *a2, _BYTE *a3, _DWORD *a4)
{
  const char *v4; // esi
  int v5; // ecx
  int v6; // edi

  v4 = a1;
  if ( strchr("-+ #0", *a1) )
  {
    do
      v5 = *++v4;
    while ( strchr("-+ #0", v5) );
  }
  if ( isdigit(*(unsigned __int8 *)v4) )
    ++v4;
  if ( isdigit(*(unsigned __int8 *)v4) )
    ++v4;
  if ( *v4 == 46 )
  {
    ++v4;
    *a4 = 1;
    if ( isdigit(*(unsigned __int8 *)v4) )
      ++v4;
    if ( isdigit(*(unsigned __int8 *)v4) )
      ++v4;
  }
  if ( isdigit(*(unsigned __int8 *)v4) )
    sub_10014BC0(a2, "invalid format (width or precision too long)");
  v6 = v4 - a1;
  if ( v4 - a1 + 2 > 20 )
    sub_10014BC0(a2, "invalid format (too long)");
  *a3 = 37;
  strncpy(a3 + 1, a1, v6 + 1);
  a3[v6 + 2] = 0;
  return v4;
}

//----- (10011F80) --------------------------------------------------------
int __cdecl sub_10011F80(_DWORD *a1)
{
  int v1; // esi
  _BYTE *v2; // ebx
  unsigned __int8 v3; // al
  _BYTE *v4; // ebx
  const char *v5; // ebx
  int v6; // eax
  double v7; // st7
  unsigned __int64 v8; // rax
  double v9; // st7
  int v10; // eax
  int v12; // [esp+18h] [ebp-438h] BYREF
  unsigned int v13; // [esp+1Ch] [ebp-434h]
  int v14; // [esp+20h] [ebp-430h]
  int v15; // [esp+24h] [ebp-42Ch] BYREF
  unsigned int v16; // [esp+28h] [ebp-428h] BYREF
  char Format[20]; // [esp+2Ch] [ebp-424h] BYREF
  int v18[131]; // [esp+40h] [ebp-410h] BYREF
  char v19; // [esp+24Ch] [ebp-204h] BYREF
  char Buffer[512]; // [esp+250h] [ebp-200h] BYREF

  v1 = 1;
  v2 = (_BYTE *)sub_10015630(a1, 1, &v15);
  v13 = (unsigned int)&v2[v15];
  sub_10015270((int)a1, v18);
  while ( (unsigned int)v2 < v13 )
  {
    if ( *v2 == 37 )
    {
      v3 = v2[1];
      v4 = v2 + 1;
      if ( v3 == 37 )
      {
        if ( v18[0] >= (unsigned int)&v19 )
          sub_100150E0((int)v18);
        *(_BYTE *)v18[0]++ = *v4;
        v2 = v4 + 1;
      }
      else
      {
        v12 = 0;
        if ( isdigit(v3) && v4[1] == 36 )
          sub_10014BC0(a1, "obsolete option (d$) to `format'");
        v14 = ++v1;
        v5 = sub_10011E90(v4, a1, Format, &v12);
        v6 = *v5 - 69;
        v2 = v5 + 1;
        switch ( v6 )
        {
          case 0:
          case 2:
          case 32:
          case 33:
          case 34:
            v9 = sub_10015700(a1, v1);
            sprintf(Buffer, Format, v9);
            goto LABEL_21;
          case 19:
          case 42:
          case 48:
          case 51:
            v8 = (unsigned __int64)sub_10015700(a1, v1);
            sprintf(Buffer, Format, (_DWORD)v8);
            goto LABEL_21;
          case 30:
          case 31:
          case 36:
            v7 = sub_10015700(a1, v1);
            sprintf(Buffer, Format, (unsigned int)(unsigned __int64)v7);
            goto LABEL_21;
          case 44:
            sub_10011D40(a1, v1, v18);
            v1 = v14;
            break;
          case 46:
            v10 = sub_10015630(a1, v1, (int *)&v16);
            if ( v12 || v16 < 0x64 )
            {
              sprintf(Buffer, Format, v10);
LABEL_21:
              sub_10015120((int)v18, Buffer, (_BYTE *)strlen(Buffer));
            }
            else
            {
              sub_1000ED40(a1, v1);
              sub_100151D0((int)v18);
            }
            break;
          default:
            sub_10014BC0(a1, "invalid option to `format'");
        }
      }
    }
    else
    {
      if ( v18[0] >= (unsigned int)&v19 )
        sub_100150E0((int)v18);
      *(_BYTE *)v18[0]++ = *v2++;
    }
  }
  sub_10015180((int)v18);
  return 1;
}

//----- (10012220) --------------------------------------------------------
int __usercall sub_10012220@<eax>(int a1@<eax>, int a2@<edi>, _DWORD *a3@<esi>)
{
  int *v4; // eax
  char *v5; // eax
  int *v6; // eax

  if ( a1 )
  {
    sub_1000F3B0((int)a3, 1);
    return 1;
  }
  else
  {
    sub_1000F1C0((int)a3);
    v4 = _errno();
    if ( a2 )
    {
      strerror(*v4);
      sub_1000F2F0(a3, "%s: %s", a2);
    }
    else
    {
      v5 = strerror(*v4);
      sub_1000F2F0(a3, "%s", (int)v5);
    }
    v6 = _errno();
    sub_1000F1E0((int)a3, (double)*v6);
    return 3;
  }
}

//----- (100122A0) --------------------------------------------------------
int __cdecl sub_100122A0(_DWORD *a1)
{
  _DWORD *v1; // eax

  v1 = (_DWORD *)sub_10014C70(a1, 1, "FILE*");
  if ( v1 )
  {
    if ( *v1 )
      sub_1000F200(a1, "file", 4u);
    else
      sub_1000F200(a1, "closed file", 0xBu);
    return 1;
  }
  else
  {
    sub_1000F1C0((int)a1);
    return 1;
  }
}

//----- (10012300) --------------------------------------------------------
int __usercall sub_10012300@<eax>(int a1@<ebx>, _DWORD *a2@<edi>)
{
  int v2; // eax

  v2 = sub_10014C70(a2, a1, "FILE*");
  if ( !v2 )
    sub_10015510(a2, a1, "bad file");
  if ( !*(_DWORD *)v2 )
    sub_10014BC0(a2, "attempt to use a closed file");
  return *(_DWORD *)v2;
}

//----- (10012340) --------------------------------------------------------
int __usercall sub_10012340@<eax>(_DWORD *a1@<edi>)
{
  FILE **v1; // eax
  FILE *v2; // esi

  v1 = (FILE **)sub_10014C70(a1, 1, "FILE*");
  if ( !v1 )
    sub_10015510(a1, 1, "bad file");
  if ( !*v1 )
    sub_10014BC0(a1, "attempt to use a closed file");
  v2 = *v1;
  if ( *v1 == &stru_1004B120 || v2 == &File || v2 == &Stream )
    return 0;
  if ( fclose(v2) )
    return 0;
  *(_DWORD *)sub_1000F0E0(a1, 1) = 0;
  return 1;
}

//----- (100123D0) --------------------------------------------------------
int __cdecl sub_100123D0(_DWORD *a1)
{
  int *v2; // eax
  char *v3; // eax
  int *v4; // eax

  if ( sub_1000ED80(a1, 1) == -1 )
  {
    sub_1000F250(a1, "_output");
    sub_1000F430(a1, -10002);
  }
  if ( sub_10012340(a1) )
  {
    sub_1000F3B0((int)a1, 1);
    return 1;
  }
  else
  {
    sub_1000F1C0((int)a1);
    v2 = _errno();
    v3 = strerror(*v2);
    sub_1000F2F0(a1, "%s", (int)v3);
    v4 = _errno();
    sub_1000F1E0((int)a1, (double)*v4);
    return 3;
  }
}

//----- (10012460) --------------------------------------------------------
int __cdecl sub_10012460(_DWORD *a1)
{
  _DWORD *v1; // eax

  v1 = (_DWORD *)sub_10014C70(a1, 1, "FILE*");
  if ( !v1 )
    sub_10015510(a1, 1, "bad file");
  if ( *v1 )
    sub_10012340(a1);
  return 0;
}

//----- (100124A0) --------------------------------------------------------
int __cdecl sub_100124A0(_DWORD *a1)
{
  _DWORD *v1; // eax
  const void *v2; // eax
  char Buffer[32]; // [esp+8h] [ebp-20h] BYREF

  v1 = (_DWORD *)sub_10014C70(a1, 1, "FILE*");
  if ( !v1 )
    sub_10015510(a1, 1, "bad file");
  if ( *v1 )
  {
    v2 = (const void *)sub_1000F0E0(a1, 1);
    sprintf(Buffer, "%p", v2);
  }
  else
  {
    strcpy(Buffer, "closed");
  }
  sub_1000F2F0(a1, "file (%s)", (int)Buffer);
  return 1;
}

//----- (10012530) --------------------------------------------------------
int __cdecl sub_10012530(_DWORD *a1)
{
  char *v1; // ebx
  int v2; // ebp
  _DWORD *v3; // edi
  int v4; // eax
  int *v5; // eax
  char *v6; // eax
  int *v7; // eax

  v1 = (char *)sub_10015630(a1, 1, 0);
  v2 = sub_100156A0(a1, 2, "r", 0);
  v3 = sub_1000FA40(a1, 4);
  *v3 = 0;
  sub_10014C50(a1, "FILE*");
  sub_1000F6D0(a1, -2);
  v4 = sub_10027490(v1, v2);
  *v3 = v4;
  if ( v4 )
    return 1;
  sub_1000F1C0((int)a1);
  v5 = _errno();
  if ( v1 )
  {
    strerror(*v5);
    sub_1000F2F0(a1, "%s: %s", (int)v1);
  }
  else
  {
    v6 = strerror(*v5);
    sub_1000F2F0(a1, "%s", (int)v6);
  }
  v7 = _errno();
  sub_1000F1E0((int)a1, (double)*v7);
  return 3;
}

//----- (10012600) --------------------------------------------------------
void __cdecl __noreturn sub_10012600(_DWORD *a1)
{
  sub_10014BC0(a1, "`popen' not supported");
}

//----- (10012620) --------------------------------------------------------
int __cdecl sub_10012620(_DWORD *a1)
{
  _DWORD *v1; // edi
  FILE *v2; // eax
  int *v3; // eax
  char *v4; // eax
  int *v5; // eax

  v1 = sub_1000FA40(a1, 4);
  *v1 = 0;
  sub_10014C50(a1, "FILE*");
  sub_1000F6D0(a1, -2);
  v2 = tmpfile();
  *v1 = v2;
  if ( v2 )
    return 1;
  sub_1000F1C0((int)a1);
  v3 = _errno();
  v4 = strerror(*v3);
  sub_1000F2F0(a1, "%s", (int)v4);
  v5 = _errno();
  sub_1000F1E0((int)a1, (double)*v5);
  return 3;
}

//----- (100126A0) --------------------------------------------------------
int __usercall sub_100126A0@<eax>(_DWORD *a1@<eax>, char *a2, int a3)
{
  char *v4; // esi
  _DWORD *v5; // ebx
  int v6; // eax
  int *v7; // eax
  const char *v8; // eax

  if ( sub_1000ED80(a1, 1) > 0 )
  {
    v4 = (char *)sub_1000F010(a1, 1);
    sub_1000F250(a1, a2);
    if ( v4 )
    {
      v5 = sub_1000FA40(a1, 4);
      *v5 = 0;
      sub_10014C50(a1, "FILE*");
      sub_1000F6D0(a1, -2);
      v6 = sub_10027490(v4, a3);
      *v5 = v6;
      if ( !v6 )
      {
        v7 = _errno();
        strerror(*v7);
        sub_1000F2F0(a1, "%s: %s", (int)v4);
        v8 = (const char *)sub_1000F010(a1, -1);
        sub_10015510(a1, 1, v8);
      }
    }
    else
    {
      sub_10012300(1, a1);
      sub_1000ED40(a1, 1);
    }
    sub_1000F610(a1, -10002);
  }
  sub_1000F250(a1, a2);
  sub_1000F430(a1, -10002);
  return 1;
}

//----- (10012780) --------------------------------------------------------
int __cdecl sub_10012780(_DWORD *a1)
{
  return sub_100126A0(a1, "_input", (int)"r");
}

//----- (100127A0) --------------------------------------------------------
int __cdecl sub_100127A0(_DWORD *a1)
{
  return sub_100126A0(a1, "_output", (int)"w");
}

//----- (100127C0) --------------------------------------------------------
int __cdecl sub_100127C0(int a1)
{
  FILE *Stream; // ecx
  int v3[2]; // [esp+8h] [ebp-8h] BYREF

  if ( sub_100289DB(Stream, (int)"%lf", (int)v3) != 1 )
    return 0;
  sub_1000F1E0(a1, *(double *)v3);
  return 1;
}
// 100127CD: variable 'Stream' is possibly undefined

//----- (10012800) --------------------------------------------------------
BOOL __usercall sub_10012800@<eax>(FILE *a1@<edi>, _DWORD *a2)
{
  char *v2; // esi
  unsigned int v3; // eax
  int v5[131]; // [esp+8h] [ebp-20Ch] BYREF

  sub_10015270((int)a2, v5);
  v2 = (char *)sub_100150E0((int)v5);
  if ( fgets(v2, 512, a1) )
  {
    while ( 1 )
    {
      v3 = strlen(v2);
      if ( v2[v3 - 1] == 10 )
        break;
      v5[0] += v3;
      v2 = (char *)sub_100150E0((int)v5);
      if ( !fgets(v2, 512, a1) )
        goto LABEL_4;
    }
    v5[0] = v5[0] + v3 - 1;
    sub_10015180((int)v5);
    return 1;
  }
  else
  {
LABEL_4:
    sub_10015180((int)v5);
    return sub_1000F080(a2, -1) != 0;
  }
}

//----- (100128D0) --------------------------------------------------------
BOOL __usercall sub_100128D0@<eax>(size_t a1@<eax>, FILE *a2@<ebx>, _DWORD *a3)
{
  size_t v4; // esi
  void *v5; // eax
  size_t v6; // eax
  int v8[131]; // [esp+Ch] [ebp-20Ch] BYREF

  sub_10015270((int)a3, v8);
  v4 = 512;
  do
  {
    v5 = (void *)sub_100150E0((int)v8);
    if ( v4 > a1 )
      v4 = a1;
    v6 = sub_10028C0F(v5, 1u, v4, a2);
    a1 -= v6;
    v8[0] += v6;
  }
  while ( a1 && v6 == v4 );
  sub_10015180((int)v8);
  return !a1 || sub_1000F080(a3, -1);
}

//----- (10012970) --------------------------------------------------------
int __usercall sub_10012970@<eax>(FILE *a1@<eax>, _DWORD *a2@<esi>, int a3)
{
  int v4; // eax
  int v5; // edi
  int v6; // eax
  int v7; // ebp
  unsigned __int64 v9; // rax
  int v10; // edi
  _BYTE *v11; // eax
  int v12; // [esp+0h] [ebp-14h]
  int v13; // [esp+10h] [ebp-4h]

  v4 = sub_1000EBC0(v12);
  v5 = v4 - 1;
  if ( v4 != 1 )
  {
    sub_10014D00(a2, v5 + 20, "too many arguments");
    v7 = a3;
    v6 = 1;
    while ( 1 )
    {
      v13 = v5 - 1;
      if ( !v6 )
        goto LABEL_4;
      if ( sub_1000ED80(a2, v7) == 3 )
      {
        v9 = (unsigned __int64)sub_1000EF80(a2, v7);
        if ( (_DWORD)v9 )
        {
          v6 = sub_100128D0(v9, a1, a2);
        }
        else
        {
          v10 = fgetc(a1);
          ungetc_0(v10, a1);
          sub_1000F200(a2, 0, 0);
          v6 = v10 != -1;
        }
      }
      else
      {
        v11 = (_BYTE *)sub_1000F010(a2, v7);
        if ( !v11 || *v11 != 42 )
          sub_10015510(a2, v7, "invalid option");
        switch ( v11[1] )
        {
          case 'a':
            sub_100128D0(0xFFFFFFFF, a1, a2);
            v6 = 1;
            break;
          case 'l':
            v6 = sub_10012800(a1, a2);
            break;
          case 'n':
            v6 = sub_100127C0((int)a2);
            break;
          case 'w':
            sub_10014BC0(a2, "obsolete option `*w' to `read'");
          default:
            sub_10015510(a2, v7, "invalid format");
        }
      }
      v5 = v13;
      ++v7;
      if ( !v13 )
        goto LABEL_3;
    }
  }
  v6 = sub_10012800(a1, a2);
  v7 = a3 + 1;
LABEL_3:
  if ( !v6 )
  {
LABEL_4:
    sub_1000EBD0((int)a2, -2);
    sub_1000F1C0((int)a2);
  }
  return v7 - a3;
}
// 10012977: variable 'v12' is possibly undefined

//----- (10012AF0) --------------------------------------------------------
int __cdecl sub_10012AF0(_DWORD *a1)
{
  FILE **v1; // eax

  sub_1000F250(a1, "_input");
  sub_1000F430(a1, -10002);
  v1 = (FILE **)sub_10014C70(a1, -1, "FILE*");
  if ( !v1 )
    sub_10015510(a1, -1, "bad file");
  if ( !*v1 )
    sub_10014BC0(a1, "attempt to use a closed file");
  return sub_10012970(*v1, a1, 1);
}

//----- (10012B60) --------------------------------------------------------
int __cdecl sub_10012B60(_DWORD *a1)
{
  FILE **v1; // eax

  v1 = (FILE **)sub_10014C70(a1, 1, "FILE*");
  if ( !v1 )
    sub_10015510(a1, 1, "bad file");
  if ( !*v1 )
    sub_10014BC0(a1, "attempt to use a closed file");
  return sub_10012970(*v1, a1, 2);
}

//----- (10012BB0) --------------------------------------------------------
int __cdecl sub_10012BB0(_DWORD *a1)
{
  FILE *v1; // edi

  v1 = *(FILE **)sub_1000F0E0(a1, -10003);
  if ( !v1 )
    sub_10014BC0(a1, "file is already closed");
  if ( sub_10012800(v1, a1) )
    return 1;
  if ( sub_1000EFD0(a1, -10004) )
  {
    sub_1000EBD0((int)a1, 0);
    sub_1000ED40(a1, -10003);
    sub_10012340(a1);
  }
  return 0;
}

//----- (10012C30) --------------------------------------------------------
int __usercall sub_10012C30@<eax>(int a1@<eax>, _DWORD *a2@<edi>, FILE *Stream)
{
  int v4; // eax
  int v5; // esi
  double v6; // st7
  void *v8; // eax
  size_t v9; // eax
  int *v10; // eax
  char *v11; // eax
  int *v12; // eax
  int v13; // [esp+4h] [ebp-14h]
  size_t ElementCount; // [esp+10h] [ebp-8h] BYREF
  int v15; // [esp+14h] [ebp-4h]

  v4 = sub_1000EBC0(v13) - 1;
  v5 = 1;
  if ( !v4 )
  {
LABEL_9:
    sub_1000F3B0((int)a2, 1);
    return 1;
  }
  v15 = v4;
  do
  {
    if ( sub_1000ED80(a2, a1) == 3 )
    {
      if ( !v5 )
        goto LABEL_6;
      v6 = sub_1000EF80(a2, a1);
      if ( fprintf(Stream, "%.14g", v6) <= 0 )
        goto LABEL_6;
    }
    else
    {
      v8 = (void *)sub_10015630(a2, a1, (int *)&ElementCount);
      if ( !v5 || (v9 = sub_10028D62(v8, 1u, ElementCount, Stream), v9 != ElementCount) )
      {
LABEL_6:
        v5 = 0;
        goto LABEL_7;
      }
    }
    v5 = 1;
LABEL_7:
    ++a1;
    --v15;
  }
  while ( v15 );
  if ( v5 )
    goto LABEL_9;
  sub_1000F1C0((int)a2);
  v10 = _errno();
  v11 = strerror(*v10);
  sub_1000F2F0(a2, "%s", (int)v11);
  v12 = _errno();
  sub_1000F1E0((int)a2, (double)*v12);
  return 3;
}
// 10012C3E: variable 'v13' is possibly undefined

//----- (10012D30) --------------------------------------------------------
int __cdecl sub_10012D30(_DWORD *a1)
{
  FILE **v1; // eax

  sub_1000F250(a1, "_output");
  sub_1000F430(a1, -10002);
  v1 = (FILE **)sub_10014C70(a1, -1, "FILE*");
  if ( !v1 )
    sub_10015510(a1, -1, "bad file");
  if ( !*v1 )
    sub_10014BC0(a1, "attempt to use a closed file");
  return sub_10012C30(1, a1, *v1);
}

//----- (10012DA0) --------------------------------------------------------
int __cdecl sub_10012DA0(_DWORD *a1)
{
  FILE **v1; // eax

  v1 = (FILE **)sub_10014C70(a1, 1, "FILE*");
  if ( !v1 )
    sub_10015510(a1, 1, "bad file");
  if ( !*v1 )
    sub_10014BC0(a1, "attempt to use a closed file");
  return sub_10012C30(2, a1, *v1);
}

//----- (10012E00) --------------------------------------------------------
int __cdecl sub_10012E00(_DWORD *a1)
{
  FILE **v1; // eax
  FILE *v2; // ebx
  const char *v3; // eax
  int v4; // edi
  int v5; // ebp
  int *v6; // eax
  char *v7; // eax
  int *v8; // eax
  int v10; // [esp+18h] [ebp-4h]

  v1 = (FILE **)sub_10014C70(a1, 1, "FILE*");
  if ( !v1 )
    sub_10015510(a1, 1, "bad file");
  if ( !*v1 )
    sub_10014BC0(a1, "attempt to use a closed file");
  v2 = *v1;
  v3 = (const char *)sub_100156A0(a1, 2, "cur", 0);
  v4 = sub_10014BF0(v3, (const char **)off_1003E69C);
  v5 = (unsigned __int64)sub_10015780(a1, 3, 0.0);
  if ( v4 == -1 )
    sub_10015510(a1, 2, "invalid mode");
  if ( fseek(v2, v5, Origin[v4]) )
  {
    sub_1000F1C0((int)a1);
    v6 = _errno();
    v7 = strerror(*v6);
    sub_1000F2F0(a1, "%s", (int)v7);
    v8 = _errno();
    sub_1000F1E0((int)a1, (double)*v8);
    return 3;
  }
  else
  {
    v10 = ftell(v2);
    sub_1000F1E0((int)a1, (double)v10);
    return 1;
  }
}
// 1003E690: using guessed type int Origin[3];
// 1003E69C: using guessed type char *off_1003E69C[3];

//----- (10012F10) --------------------------------------------------------
int __cdecl sub_10012F10(_DWORD *a1)
{
  FILE **v1; // eax
  int *v3; // eax
  char *v4; // eax
  int *v5; // eax

  sub_1000F250(a1, "_output");
  sub_1000F430(a1, -10002);
  v1 = (FILE **)sub_10014C70(a1, -1, "FILE*");
  if ( !v1 )
    sub_10015510(a1, -1, "bad file");
  if ( !*v1 )
    sub_10014BC0(a1, "attempt to use a closed file");
  if ( fflush(*v1) )
  {
    sub_1000F1C0((int)a1);
    v3 = _errno();
    v4 = strerror(*v3);
    sub_1000F2F0(a1, "%s", (int)v4);
    v5 = _errno();
    sub_1000F1E0((int)a1, (double)*v5);
    return 3;
  }
  else
  {
    sub_1000F3B0((int)a1, 1);
    return 1;
  }
}

//----- (10012FD0) --------------------------------------------------------
int __cdecl sub_10012FD0(_DWORD *a1)
{
  FILE **v1; // eax
  int *v3; // eax
  char *v4; // eax
  int *v5; // eax

  v1 = (FILE **)sub_10014C70(a1, 1, "FILE*");
  if ( !v1 )
    sub_10015510(a1, 1, "bad file");
  if ( !*v1 )
    sub_10014BC0(a1, "attempt to use a closed file");
  if ( fflush(*v1) )
  {
    sub_1000F1C0((int)a1);
    v3 = _errno();
    v4 = strerror(*v3);
    sub_1000F2F0(a1, "%s", (int)v4);
    v5 = _errno();
    sub_1000F1E0((int)a1, (double)*v5);
    return 3;
  }
  else
  {
    sub_1000F3B0((int)a1, 1);
    return 1;
  }
}

//----- (10013070) --------------------------------------------------------
int __cdecl sub_10013070(_DWORD *a1)
{
  char *v1; // eax
  intptr_t v3; // [esp+Ch] [ebp-4h]

  v1 = (char *)sub_10015630(a1, 1, 0);
  v3 = sub_10029240(v1);
  sub_1000F1E0((int)a1, (double)v3);
  return 1;
}

//----- (100130B0) --------------------------------------------------------
int __cdecl sub_100130B0(_DWORD *a1)
{
  const CHAR *v1; // edi
  int v2; // eax

  v1 = (const CHAR *)sub_10015630(a1, 1, 0);
  v2 = sub_1002740A(v1);
  return sub_10012220(v2 == 0, (int)v1, a1);
}

//----- (100130E0) --------------------------------------------------------
int __cdecl sub_100130E0(_DWORD *a1)
{
  const CHAR *v1; // edi
  const CHAR *v2; // eax
  int v3; // eax

  v1 = (const CHAR *)sub_10015630(a1, 1, 0);
  v2 = (const CHAR *)sub_10015630(a1, 2, 0);
  v3 = sub_10027637(v1, v2);
  return sub_10012220(v3 == 0, (int)v1, a1);
}

//----- (10013120) --------------------------------------------------------
int __cdecl sub_10013120(_DWORD *a1)
{
  char Buffer[16]; // [esp+0h] [ebp-10h] BYREF

  if ( tmpnam(Buffer) != Buffer )
    sub_10014BC0(a1, "unable to generate a unique filename in `tmpname'");
  sub_1000F250(a1, Buffer);
  return 1;
}

//----- (10013170) --------------------------------------------------------
int __cdecl sub_10013170(_DWORD *a1)
{
  char *v1; // eax
  char *v2; // eax

  v1 = (char *)sub_10015630(a1, 1, 0);
  v2 = sub_10029363(v1);
  sub_1000F250(a1, v2);
  return 1;
}

//----- (100131A0) --------------------------------------------------------
int __cdecl sub_100131A0(int a1)
{
  clock_t v2; // [esp+8h] [ebp-4h]

  v2 = clock();
  sub_1000F1E0(a1, (double)v2 * 0.001);
  return 1;
}

//----- (100131D0) --------------------------------------------------------
int __cdecl sub_100131D0(_DWORD *a1)
{
  const char *v1; // esi
  struct tm *v2; // eax
  int tm_isdst; // esi
  char *Format; // [esp+14h] [ebp-10Ch]
  char *Formata; // [esp+14h] [ebp-10Ch]
  char *Formatb; // [esp+14h] [ebp-10Ch]
  char *Formatc; // [esp+14h] [ebp-10Ch]
  char *Formatd; // [esp+14h] [ebp-10Ch]
  char *Formate; // [esp+14h] [ebp-10Ch]
  char *Formatf; // [esp+14h] [ebp-10Ch]
  char *Formatg; // [esp+14h] [ebp-10Ch]
  char *Formath; // [esp+14h] [ebp-10Ch]
  struct tm *v14; // [esp+18h] [ebp-108h]
  __time32_t Time; // [esp+1Ch] [ebp-104h] BYREF
  char Buffer[256]; // [esp+20h] [ebp-100h] BYREF

  v1 = (const char *)sub_100156A0(a1, 1, "%c", 0);
  Format = (char *)v1;
  Time = (unsigned __int64)sub_10015780(a1, 2, -1.0);
  if ( Time == -1 )
    Time = time(0);
  if ( *v1 == 33 )
  {
    v2 = gmtime(&Time);
    ++v1;
    v14 = v2;
    Format = (char *)v1;
  }
  else
  {
    v2 = localtime(&Time);
    v14 = v2;
  }
  if ( v2 )
  {
    if ( !strcmp(v1, "*t") )
    {
      sub_1000F4D0(a1);
      Formata = (char *)v14->tm_sec;
      sub_1000F250(a1, "sec");
      sub_1000F1E0((int)a1, (double)(int)Formata);
      sub_1000F610(a1, -3);
      Formatb = (char *)v14->tm_min;
      sub_1000F250(a1, "min");
      sub_1000F1E0((int)a1, (double)(int)Formatb);
      sub_1000F610(a1, -3);
      Formatc = (char *)v14->tm_hour;
      sub_1000F250(a1, "hour");
      sub_1000F1E0((int)a1, (double)(int)Formatc);
      sub_1000F610(a1, -3);
      Formatd = (char *)v14->tm_mday;
      sub_1000F250(a1, "day");
      sub_1000F1E0((int)a1, (double)(int)Formatd);
      sub_1000F610(a1, -3);
      Formate = (char *)(v14->tm_mon + 1);
      sub_1000F250(a1, "month");
      sub_1000F1E0((int)a1, (double)(int)Formate);
      sub_1000F610(a1, -3);
      Formatf = (char *)(v14->tm_year + 1900);
      sub_1000F250(a1, "year");
      sub_1000F1E0((int)a1, (double)(int)Formatf);
      sub_1000F610(a1, -3);
      Formatg = (char *)(v14->tm_wday + 1);
      sub_1000F250(a1, "wday");
      sub_1000F1E0((int)a1, (double)(int)Formatg);
      sub_1000F610(a1, -3);
      Formath = (char *)(v14->tm_yday + 1);
      sub_1000F250(a1, "yday");
      sub_1000F1E0((int)a1, (double)(int)Formath);
      sub_1000F610(a1, -3);
      tm_isdst = v14->tm_isdst;
      sub_1000F250(a1, "isdst");
      sub_1000F3B0((int)a1, tm_isdst);
      sub_1000F610(a1, -3);
      return 1;
    }
    else
    {
      if ( !strftime(Buffer, 0x100u, Format, v2) )
        sub_10014BC0(a1, "`date' format too long");
      sub_1000F250(a1, Buffer);
      return 1;
    }
  }
  else
  {
    sub_1000F1C0((int)a1);
    return 1;
  }
}

//----- (10013460) --------------------------------------------------------
int __cdecl sub_10013460(_DWORD *a1)
{
  double v1; // st7
  int v2; // eax

  if ( sub_1000ED80(a1, 1) > 0 )
  {
    sub_100155B0(a1, 1, 5);
    sub_1000EBD0((int)a1, 1);
    sub_1000F250(a1, "sec");
    sub_1000F3E0(a1, -2);
    if ( sub_1000EE10(a1, -1) )
      sub_1000EF80(a1, -1);
    sub_1000EBD0((int)a1, -2);
    sub_1000F250(a1, "min");
    sub_1000F3E0(a1, -2);
    if ( sub_1000EE10(a1, -1) )
      sub_1000EF80(a1, -1);
    sub_1000EBD0((int)a1, -2);
    sub_1000F250(a1, "hour");
    sub_1000F3E0(a1, -2);
    if ( sub_1000EE10(a1, -1) )
      sub_1000EF80(a1, -1);
    sub_1000EBD0((int)a1, -2);
    sub_1000F250(a1, "day");
    sub_1000F3E0(a1, -2);
    if ( !sub_1000EE10(a1, -1) )
      sub_10014BC0(a1, "field `%s' missing in date table", "day");
    sub_1000EF80(a1, -1);
    sub_1000EBD0((int)a1, -2);
    sub_1000F250(a1, "month");
    sub_1000F3E0(a1, -2);
    if ( !sub_1000EE10(a1, -1) )
      sub_10014BC0(a1, "field `%s' missing in date table", "month");
    sub_1000EF80(a1, -1);
    sub_1000EBD0((int)a1, -2);
    sub_1000F250(a1, "year");
    sub_1000F3E0(a1, -2);
    if ( !sub_1000EE10(a1, -1) )
      sub_10014BC0(a1, "field `%s' missing in date table", "year");
    sub_1000EF80(a1, -1);
    sub_1000EBD0((int)a1, -2);
    sub_1000F250(a1, "isdst");
    sub_1000F3E0(a1, -2);
    sub_1000EFD0(a1, -1);
    sub_1000EBD0((int)a1, -2);
    v2 = sub_1002A0FE();
    if ( v2 == -1 )
    {
      sub_1000F1C0((int)a1);
      return 1;
    }
    v1 = (double)v2;
  }
  else
  {
    v1 = (double)time(0);
  }
  sub_1000F1E0((int)a1, v1);
  return 1;
}

//----- (100136F0) --------------------------------------------------------
int __cdecl sub_100136F0(_DWORD *a1)
{
  double v1; // st7
  double v2; // st7
  __time32_t v4; // [esp+4h] [ebp-8h]

  v4 = (unsigned __int64)sub_10015780(a1, 2, 0.0);
  v1 = sub_10015700(a1, 1);
  v2 = difftime((unsigned __int64)v1, v4);
  sub_1000F1E0((int)a1, v2);
  return 1;
}

//----- (10013740) --------------------------------------------------------
int __cdecl sub_10013740(_DWORD *a1)
{
  const char *v1; // edi
  const char *v2; // eax
  int v3; // ebx
  char *v4; // eax

  v1 = (const char *)sub_1000F010(a1, 1);
  v2 = (const char *)sub_100156A0(a1, 2, "all", 0);
  v3 = sub_10014BF0(v2, (const char **)off_1003E770);
  if ( !v1 && sub_1000ED80(a1, 1) > 0 )
    sub_10015510(a1, 1, "string expected");
  if ( v3 == -1 )
    sub_10015510(a1, 2, "invalid option");
  v4 = setlocale(Category[v3], v1);
  sub_1000F250(a1, v4);
  return 1;
}
// 1003E758: using guessed type int Category[6];
// 1003E770: using guessed type char *off_1003E770[6];

//----- (100137D0) --------------------------------------------------------
void __cdecl __noreturn sub_100137D0(_DWORD *a1)
{
  double v1; // st7

  v1 = sub_10015780(a1, 1, 0.0);
  exit((unsigned __int64)v1);
}

//----- (10013800) --------------------------------------------------------
int __cdecl sub_10013800(_DWORD *a1)
{
  _DWORD *v1; // eax

  v1 = (_DWORD *)sub_10014C70(a1, 1, "FILE*");
  if ( !v1 )
    sub_10015510(a1, 1, "bad file");
  if ( !*v1 )
    sub_10014BC0(a1, "attempt to use a closed file");
  sub_1000F200(a1, "FILE*", 5u);
  sub_1000F430(a1, -10000);
  sub_1000ED40(a1, 1);
  sub_1000F3B0((int)a1, 0);
  sub_1000F320(a1, (int)sub_10012BB0, 3);
  return 1;
}

//----- (10013880) --------------------------------------------------------
int __cdecl sub_10013880(_DWORD *a1)
{
  char *v2; // ebx
  _DWORD *v3; // edi
  int v4; // eax
  int *v5; // eax
  char *v6; // eax
  int v7; // edi

  if ( sub_1000ED80(a1, 1) > 0 )
  {
    v2 = (char *)sub_10015630(a1, 1, 0);
    v3 = sub_1000FA40(a1, 4);
    *v3 = 0;
    sub_10014C50(a1, "FILE*");
    sub_1000F6D0(a1, -2);
    v4 = sub_10027490(v2, (int)"r");
    *v3 = v4;
    if ( !v4 )
    {
      v5 = _errno();
      v6 = strerror(*v5);
      sub_10015510(a1, 1, v6);
    }
    v7 = sub_1000EBC0((int)a1);
    sub_1000F200(a1, "FILE*", 5u);
    sub_1000F430(a1, -10000);
    sub_1000ED40(a1, v7);
    sub_1000F3B0((int)a1, 1);
    sub_1000F320(a1, (int)sub_10012BB0, 3);
    return 1;
  }
  else
  {
    sub_1000F250(a1, "_input");
    sub_1000F430(a1, -10002);
    return sub_10013800(a1);
  }
}

//----- (10013960) --------------------------------------------------------
int __cdecl sub_10013960(_DWORD *a1)
{
  int v1; // ebp
  int i; // edi
  const char *v3; // ebx

  v1 = sub_1000EBC0((int)a1);
  sub_1000F250(a1, "tostring");
  sub_1000F3E0(a1, -10001);
  for ( i = 1; i <= v1; ++i )
  {
    sub_1000ED40(a1, -1);
    sub_1000ED40(a1, i);
    sub_1000F7B0((int)a1, 1, 1);
    v3 = (const char *)sub_1000F010(a1, -1);
    if ( !v3 )
      sub_10014BC0(a1, "`tostring' must return a string to `print'");
    if ( i > 1 )
      fputs("\t", &File);
    fputs(v3, &File);
    sub_1000EBD0((int)a1, -2);
  }
  fputs("\n", &File);
  return 0;
}

//----- (10013A20) --------------------------------------------------------
int __cdecl sub_10013A20(_DWORD *a1)
{
  int v1; // edi
  double v2; // st7
  const char *v4; // ebx
  char *v5; // edi
  char *EndPtr[2]; // [esp+10h] [ebp-8h] BYREF

  v1 = (unsigned __int64)sub_10015780(a1, 2, 10.0);
  if ( v1 == 10 )
  {
    sub_10015600(a1, 1);
    if ( sub_1000EE10(a1, 1) )
    {
      v2 = sub_1000EF80(a1, 1);
      sub_1000F1E0((int)a1, v2);
      return 1;
    }
  }
  else
  {
    v4 = (const char *)sub_10015630(a1, 1, 0);
    if ( v1 < 2 || v1 > 36 )
      sub_10015510(a1, 2, "base out of range");
    v5 = (char *)strtoul(v4, EndPtr, v1);
    if ( v4 != EndPtr[0] )
    {
      for ( ; isspace((unsigned __int8)*EndPtr[0]); ++EndPtr[0] )
        ;
      if ( !*EndPtr[0] )
      {
        EndPtr[1] = v5;
        sub_1000F1E0((int)a1, (double)(unsigned int)v5);
        return 1;
      }
    }
  }
  sub_1000F1C0((int)a1);
  return 1;
}

//----- (10013B50) --------------------------------------------------------
void __cdecl __noreturn sub_10013B50(_DWORD *a1)
{
  int v1; // edi

  v1 = (unsigned __int64)sub_10015780(a1, 2, 1.0);
  sub_10015600(a1, 1);
  if ( sub_1000EE60(a1, 1) )
  {
    if ( v1 )
    {
      sub_10014B50(a1, v1);
      sub_1000ED40(a1, 1);
      sub_1000F9C0(a1, 2);
      sub_1000F960(a1);
    }
  }
  sub_1000ED40(a1, 1);
  sub_1000F960(a1);
}

//----- (10013BD0) --------------------------------------------------------
int __cdecl sub_10013BD0(_DWORD *a1)
{
  sub_10015600(a1, 1);
  if ( sub_1000F510(a1, 1) )
    sub_10014D30(a1, 1, "__metatable");
  else
    sub_1000F1C0((int)a1);
  return 1;
}

//----- (10013C20) --------------------------------------------------------
int __cdecl sub_10013C20(_DWORD *a1)
{
  int v1; // edi

  v1 = sub_1000ED80(a1, 2);
  sub_100155B0(a1, 1, 5);
  if ( v1 && v1 != 5 )
    sub_10015510(a1, 2, "nil or table expected");
  if ( sub_10014D30(a1, 1, "__metatable") )
    sub_10014BC0(a1, "cannot change a protected metatable");
  sub_1000EBD0((int)a1, 2);
  sub_1000F6D0(a1, 1);
  return 1;
}

//----- (10013CA0) --------------------------------------------------------
int __usercall sub_10013CA0@<eax>(_DWORD *a1@<esi>)
{
  int result; // eax
  int v2; // edi
  _DWORD v3[24]; // [esp+Ch] [ebp-60h] BYREF

  if ( sub_1000ED80(a1, 1) == 6 )
    return sub_1000ED40(a1, 1);
  v2 = (unsigned __int64)sub_10015780(a1, 1, 1.0);
  if ( v2 < 0 )
    sub_10015510(a1, 1, "level must be non-negative");
  if ( !sub_1001ABE0((int)a1, v2, (int)v3) )
    sub_10015510(a1, 1, "invalid level");
  sub_1001B610(a1, "f", v3);
  result = sub_1000ED80(a1, -1);
  if ( !result )
    sub_10014BC0(a1, "no function environment for tail call at level %d", v2);
  return result;
}
// 10013CA0: using guessed type _DWORD var_60[24];

//----- (10013D50) --------------------------------------------------------
int __cdecl sub_10013D50(_DWORD *a1)
{
  sub_10013CA0(a1);
  sub_1000F580(a1, -1);
  sub_1000F200(a1, "__fenv", 6u);
  sub_1000F430(a1, -2);
  if ( !sub_1000ED80(a1, -1) )
    sub_1000EBD0((int)a1, -2);
  return 1;
}

//----- (10013DA0) --------------------------------------------------------
int __cdecl sub_10013DA0(_DWORD *a1)
{
  sub_100155B0(a1, 2, 5);
  sub_10013CA0(a1);
  sub_1000F580(a1, -1);
  sub_1000F200(a1, "__fenv", 6u);
  sub_1000F430(a1, -2);
  if ( sub_1000ED80(a1, -1) )
    sub_10014BC0(a1, "`setfenv' cannot change a protected environment");
  sub_1000EBD0((int)a1, -3);
  sub_1000ED40(a1, 2);
  if ( sub_1000EE10(a1, 1) && 0.0 == sub_1000EF80(a1, 1) )
  {
    sub_1000ECF0(a1, -10001);
    return 0;
  }
  else
  {
    if ( !sub_1000F740(a1, -2) )
      sub_10014BC0(a1, "`setfenv' cannot change environment of given function");
    return 0;
  }
}

//----- (10013E60) --------------------------------------------------------
int __cdecl sub_10013E60(_DWORD *a1)
{
  int v1; // eax

  sub_10015600(a1, 1);
  sub_10015600(a1, 2);
  v1 = sub_1000EEA0(a1, 1, 2);
  sub_1000F3B0((int)a1, v1);
  return 1;
}

//----- (10013E90) --------------------------------------------------------
int __cdecl sub_10013E90(_DWORD *a1)
{
  sub_100155B0(a1, 1, 5);
  sub_10015600(a1, 2);
  sub_1000F430(a1, 1);
  return 1;
}

//----- (10013EC0) --------------------------------------------------------
int __cdecl sub_10013EC0(_DWORD *a1)
{
  sub_100155B0(a1, 1, 5);
  sub_10015600(a1, 2);
  sub_10015600(a1, 3);
  sub_1000F610(a1, 1);
  return 1;
}

//----- (10013F00) --------------------------------------------------------
int __cdecl sub_10013F00(int a1)
{
  int v1; // eax
  int v3; // [esp+Ch] [ebp-4h]

  v1 = sub_1000F910(a1);
  sub_1000F1E0(a1, (double)v1);
  v3 = sub_1000F900(a1);
  sub_1000F1E0(a1, (double)v3);
  return 2;
}

//----- (10013F50) --------------------------------------------------------
int __cdecl sub_10013F50(_DWORD *a1)
{
  double v1; // st7

  v1 = sub_10015780(a1, 1, 0.0);
  sub_1000F920(a1, (unsigned __int64)v1);
  return 0;
}

//----- (10013F80) --------------------------------------------------------
int __cdecl sub_10013F80(_DWORD *a1)
{
  int v1; // eax
  char *v2; // eax

  sub_10015600(a1, 1);
  v1 = sub_1000ED80(a1, 1);
  v2 = (char *)sub_1000EDB0((int)a1, v1);
  sub_1000F250(a1, v2);
  return 1;
}

//----- (10013FB0) --------------------------------------------------------
int __cdecl sub_10013FB0(_DWORD *a1)
{
  sub_100155B0(a1, 1, 5);
  sub_1000EBD0((int)a1, 2);
  if ( sub_1000F970(a1, 1) )
    return 2;
  sub_1000F1C0((int)a1);
  return 1;
}

//----- (10013FF0) --------------------------------------------------------
int __cdecl sub_10013FF0(_DWORD *a1)
{
  sub_100155B0(a1, 1, 5);
  sub_1000F200(a1, "next", 4u);
  sub_1000F430(a1, -10001);
  sub_1000ED40(a1, 1);
  sub_1000F1C0((int)a1);
  return 3;
}

//----- (10014030) --------------------------------------------------------
int __cdecl sub_10014030(_DWORD *a1)
{
  double v2; // [esp+Ch] [ebp-8h]
  double v3; // [esp+Ch] [ebp-8h]

  v2 = sub_1000EF80(a1, 2);
  sub_100155B0(a1, 1, 5);
  if ( v2 == 0.0 && sub_1000ED80(a1, 2) == -1 )
  {
    sub_1000F200(a1, "ipairs", 6u);
    sub_1000F430(a1, -10001);
    sub_1000ED40(a1, 1);
    sub_1000F1E0((int)a1, 0.0);
    return 3;
  }
  else
  {
    v3 = v2 + 1.0;
    sub_1000F1E0((int)a1, v3);
    sub_1000F480(a1, 1, (unsigned __int64)v3);
    return sub_1000ED80(a1, -1) != 0 ? 2 : 0;
  }
}

//----- (10014100) --------------------------------------------------------
int __cdecl sub_10014100(_DWORD *a1)
{
  const char *v1; // edi
  void *v2; // eax
  int v4; // [esp+8h] [ebp-4h] BYREF

  v1 = (const char *)sub_10015630(a1, 1, &v4);
  v2 = (void *)sub_100156A0(a1, 2, v1, 0);
  if ( !sub_100154E0(a1, (int)v1, v4, v2) )
    return 1;
  sub_1000F1C0((int)a1);
  sub_1000EC90(a1, -2);
  return 2;
}

//----- (10014160) --------------------------------------------------------
int __cdecl sub_10014160(_DWORD *a1)
{
  char *v1; // eax

  v1 = (char *)sub_100156A0(a1, 1, 0, 0);
  if ( !sub_10015310(a1, v1) )
    return 1;
  sub_1000F1C0((int)a1);
  sub_1000EC90(a1, -2);
  return 2;
}

//----- (100141A0) --------------------------------------------------------
int __cdecl sub_100141A0(_DWORD *a1)
{
  char *v1; // eax

  v1 = (char *)sub_100156A0(a1, 1, 0, 0);
  if ( sub_10015310(a1, v1) )
    sub_1000F960(a1);
  sub_1000F7B0((int)a1, 0, -1);
  return sub_1000EBC0((int)a1) - 1;
}

//----- (100141E0) --------------------------------------------------------
int __cdecl sub_100141E0(_DWORD *a1)
{
  const char *v1; // eax

  sub_10015600(a1, 1);
  if ( !sub_1000EFD0(a1, 1) )
  {
    v1 = (const char *)sub_100156A0(a1, 2, "assertion failed!", 0);
    sub_10014BC0(a1, "%s", v1);
  }
  sub_1000EBD0((int)a1, 1);
  return 1;
}

//----- (10014230) --------------------------------------------------------
int __cdecl sub_10014230(_DWORD *a1)
{
  int v1; // edi
  int i; // esi

  sub_100155B0(a1, 1, 5);
  v1 = sub_10014F40(a1, 1);
  sub_10014D00(a1, v1, "table too big to unpack");
  for ( i = 1; i <= v1; ++i )
    sub_1000F480(a1, 1, i);
  return v1;
}

//----- (10014280) --------------------------------------------------------
int __cdecl sub_10014280(_DWORD *a1)
{
  int v1; // eax
  int v2; // eax

  sub_10015600(a1, 1);
  v1 = sub_1000EBC0((int)a1);
  v2 = sub_1000F7F0(a1, v1 - 1, -1, 0);
  sub_1000F3B0((int)a1, v2 == 0);
  sub_1000EC90(a1, 1);
  return sub_1000EBC0((int)a1);
}

//----- (100142D0) --------------------------------------------------------
int __cdecl sub_100142D0(_DWORD *a1)
{
  int v1; // eax

  sub_10015600(a1, 2);
  sub_1000EBD0((int)a1, 2);
  sub_1000EC90(a1, 1);
  v1 = sub_1000F7F0(a1, 0, -1, 1);
  sub_1000F3B0((int)a1, v1 == 0);
  sub_1000ECF0(a1, 1);
  return sub_1000EBC0((int)a1);
}

//----- (10014320) --------------------------------------------------------
int __cdecl sub_10014320(_DWORD *a1)
{
  char *v1; // eax
  bool v3; // zf
  char *v4; // eax
  const char *v5; // [esp-10h] [ebp-54h]
  int v6; // [esp-Ch] [ebp-50h]
  int v7; // [esp-Ch] [ebp-50h]
  int v8; // [esp-Ch] [ebp-50h]
  char Buffer[64]; // [esp+4h] [ebp-40h] BYREF

  sub_10015600(a1, 1);
  if ( !sub_10014D90(a1, 1, "__tostring") )
  {
    switch ( sub_1000ED80(a1, 1) )
    {
      case 0:
        sub_1000F200(a1, "nil", 3u);
        return 1;
      case 1:
        v3 = !sub_1000EFD0(a1, 1);
        v4 = "true";
        if ( v3 )
          v4 = "false";
        sub_1000F250(a1, v4);
        return 1;
      case 2:
      case 7:
        v8 = sub_1000F0E0(a1, 1);
        sprintf(Buffer, "userdata: %p", v8);
        break;
      case 3:
        v1 = (char *)sub_1000F010(a1, 1);
        sub_1000F250(a1, v1);
        return 1;
      case 4:
        sub_1000ED40(a1, 1);
        return 1;
      case 5:
        v6 = sub_1000F150(a1, 1);
        v5 = "table: %p";
        goto LABEL_9;
      case 6:
        v7 = sub_1000F150(a1, 1);
        sprintf(Buffer, "function: %p", v7);
        break;
      case 8:
        v6 = sub_1000F120(a1, 1);
        v5 = "thread: %p";
LABEL_9:
        sprintf(Buffer, v5, v6);
        break;
      default:
        break;
    }
    sub_1000F250(a1, Buffer);
  }
  return 1;
}

//----- (10014470) --------------------------------------------------------
char *__usercall sub_10014470@<eax>(_DWORD *a1@<esi>)
{
  int v1; // edi
  char *result; // eax

  sub_1000F250(a1, "LUA_PATH");
  sub_1000F3E0(a1, -10001);
  v1 = sub_1000F010(a1, -1);
  sub_1000EBD0((int)a1, -2);
  if ( v1 )
    return (char *)v1;
  result = sub_10029363("LUA_PATH");
  if ( !result )
    return "?;?.lua";
  return result;
}

//----- (100144C0) --------------------------------------------------------
char __usercall sub_100144C0@<al>(_DWORD *a1@<ebx>)
{
  char *v1; // esi
  int v2; // ebp
  char *i; // edi

  v1 = (char *)sub_1000F010(a1, -1);
  v2 = 1;
  for ( i = strchr(v1, 63); i; i = strchr(i + 1, 63) )
  {
    sub_10014D00(a1, 3, "too many marks in a path component");
    sub_1000F200(a1, v1, i - v1);
    sub_1000ED40(a1, 1);
    v1 = i + 1;
    v2 += 2;
  }
  sub_1000F250(a1, v1);
  return sub_1000F9C0(a1, v2);
}

//----- (10014530) --------------------------------------------------------
int __cdecl sub_10014530(_DWORD *a1)
{
  int v1; // ebp
  char *v2; // edi
  char *v3; // ebx
  char *v4; // eax
  const char *v5; // eax
  const char *v6; // eax
  const char *v8; // [esp-8h] [ebp-10h]
  char *v9; // [esp-8h] [ebp-10h]

  v1 = 2;
  sub_10015630(a1, 1, 0);
  sub_1000EBD0((int)a1, 1);
  sub_1000F250(a1, "_LOADED");
  sub_1000F3E0(a1, -10001);
  if ( sub_1000ED80(a1, 2) != 5 )
    sub_10014BC0(a1, "`_LOADED' is not a table");
  v2 = sub_10014470(a1);
  sub_1000ED40(a1, 1);
  sub_1000F430(a1, 2);
  if ( !sub_1000EFD0(a1, -1) )
  {
    do
    {
      sub_1000EBD0((int)a1, 3);
      v3 = v2;
      if ( !*v2 )
        break;
      if ( *v2 == 59 )
        v3 = v2 + 1;
      v2 = strchr(v3, 59);
      if ( !v2 )
        v2 = &v3[strlen(v3)];
      sub_1000F200(a1, v3, v2 - v3);
      if ( !v2 )
        break;
      sub_100144C0(a1);
      v4 = (char *)sub_1000F010(a1, -1);
      v1 = sub_10015310(a1, v4);
    }
    while ( v1 == 2 );
    if ( v1 )
    {
      if ( v1 != 2 )
      {
        v8 = (const char *)sub_1000F010(a1, -1);
        v5 = (const char *)sub_1000F010(a1, 1);
        sub_10014BC0(a1, "error loading package `%s' (%s)", v5, v8);
      }
      v9 = sub_10014470(a1);
      v6 = (const char *)sub_1000F010(a1, 1);
      sub_10014BC0(a1, "could not load package `%s' from path `%s'", v6, v9);
    }
    sub_1000F250(a1, "_REQUIREDNAME");
    sub_1000F3E0(a1, -10001);
    sub_1000EC90(a1, -2);
    sub_1000ED40(a1, 1);
    sub_1000F250(a1, "_REQUIREDNAME");
    sub_1000EC90(a1, -2);
    sub_1000F5D0(a1, -10001);
    sub_1000F7B0((int)a1, 0, 1);
    sub_1000EC90(a1, -2);
    sub_1000F250(a1, "_REQUIREDNAME");
    sub_1000EC90(a1, -2);
    sub_1000F5D0(a1, -10001);
    if ( !sub_1000ED80(a1, -1) )
    {
      sub_1000F3B0((int)a1, 1);
      sub_1000ECF0(a1, -2);
    }
    sub_1000ED40(a1, 1);
    sub_1000ED40(a1, -2);
    sub_1000F610(a1, 2);
  }
  return 1;
}

//----- (10014740) --------------------------------------------------------
int __usercall sub_10014740@<eax>(int a1@<eax>, _DWORD *a2@<edi>, _DWORD *a3@<esi>)
{
  int v4; // ebx

  if ( !sub_1000EAC0(a3, a1) )
    sub_10014BC0(a2, "too many arguments to resume");
  sub_1000EB20((int)a2, (int)a3, a1);
  if ( sub_10016330((int)a3, a1) )
  {
    sub_1000EB20((int)a3, (int)a2, 1);
    return -1;
  }
  else
  {
    v4 = sub_1000EBC0((int)a3);
    if ( !sub_1000EAC0(a2, v4) )
      sub_10014BC0(a2, "too many results to resume");
    sub_1000EB20((int)a3, (int)a2, v4);
    return v4;
  }
}

//----- (100147C0) --------------------------------------------------------
int __cdecl sub_100147C0(_DWORD *a1)
{
  _DWORD *v1; // esi
  int v2; // eax
  int v3; // esi

  v1 = (_DWORD *)sub_1000F120(a1, 1);
  if ( !v1 )
    sub_10015510(a1, 1, "coroutine expected");
  v2 = sub_1000EBC0((int)a1);
  v3 = sub_10014740(v2 - 1, a1, v1);
  if ( v3 >= 0 )
  {
    sub_1000F3B0((int)a1, 1);
    sub_1000EC90(a1, -1 - v3);
    return v3 + 1;
  }
  else
  {
    sub_1000F3B0((int)a1, 0);
    sub_1000EC90(a1, -2);
    return 2;
  }
}

//----- (10014840) --------------------------------------------------------
int __cdecl sub_10014840(_DWORD *a1)
{
  _DWORD *v1; // esi
  int v2; // eax
  int result; // eax

  v1 = (_DWORD *)sub_1000F120(a1, -10002);
  v2 = sub_1000EBC0((int)a1);
  result = sub_10014740(v2, a1, v1);
  if ( result < 0 )
  {
    if ( sub_1000EE60(a1, -1) )
    {
      sub_10014B50(a1, 1);
      sub_1000EC90(a1, -2);
      sub_1000F9C0(a1, 2);
    }
    sub_1000F960(a1);
  }
  return result;
}

//----- (100148A0) --------------------------------------------------------
int __cdecl sub_100148A0(_DWORD *a1)
{
  _DWORD *v1; // edi

  v1 = sub_1000EB80(a1);
  if ( sub_1000ED80(a1, 1) != 6 || sub_1000EDD0(a1, 1) )
    sub_10015510(a1, 1, "Lua function expected");
  sub_1000ED40(a1, 1);
  sub_1000EB20((int)a1, (int)v1, 1);
  return 1;
}

//----- (10014900) --------------------------------------------------------
int __cdecl sub_10014900(_DWORD *a1)
{
  sub_100148A0(a1);
  sub_1000F320(a1, (int)sub_10014840, 1);
  return 1;
}

//----- (10014930) --------------------------------------------------------
int __cdecl sub_10014930(int a1)
{
  int v1; // eax

  v1 = sub_1000EBC0(a1);
  return sub_10016100(a1, v1);
}

//----- (10014950) --------------------------------------------------------
int __cdecl sub_10014950(_DWORD *a1)
{
  int v1; // eax
  int v2; // edi
  char v4[96]; // [esp+8h] [ebp-60h] BYREF

  v1 = sub_1000F120(a1, 1);
  v2 = v1;
  if ( !v1 )
    sub_10015510(a1, 1, "coroutine expected");
  if ( a1 == (_DWORD *)v1 )
  {
    sub_1000F200(a1, "running", 7u);
    return 1;
  }
  else if ( sub_1001ABE0(v1, 0, (int)v4) || sub_1000EBC0(v2) )
  {
    sub_1000F200(a1, "suspended", 9u);
    return 1;
  }
  else
  {
    sub_1000F200(a1, "dead", 4u);
    return 1;
  }
}
// 10014950: using guessed type char var_60[96];

//----- (100149F0) --------------------------------------------------------
_DWORD *__usercall sub_100149F0@<eax>(_DWORD *a1@<eax>, int a2@<esi>)
{
  char *v3; // eax
  _DWORD *v4; // eax
  int *v5; // ecx
  int v6; // edi
  _DWORD *result; // eax
  int v8; // ecx
  int v9; // edx

  v3 = (char *)sub_1001B810(a1, 0, 0, 0x2D0u);
  *(_DWORD *)(a2 + 28) = v3;
  *(_DWORD *)(a2 + 8) = v3;
  *(_DWORD *)(a2 + 32) = 45;
  *(_DWORD *)(a2 + 24) = v3 + 624;
  v4 = sub_1001B810(a1, 0, 0, 0xC0u);
  *(_DWORD *)(a2 + 40) = v4;
  *(_DWORD *)(a2 + 20) = v4;
  v4[2] = 1;
  **(_DWORD **)(a2 + 8) = 0;
  v5 = *(int **)(a2 + 20);
  v6 = *(_DWORD *)(a2 + 8) + 16;
  *(_DWORD *)(a2 + 8) = v6;
  *v5 = v6;
  result = *(_DWORD **)(a2 + 20);
  v8 = *(_DWORD *)(a2 + 8);
  *(_DWORD *)(a2 + 12) = *result;
  result[1] = v8 + 320;
  v9 = *(_DWORD *)(a2 + 40) + 192;
  *(_WORD *)(a2 + 44) = 8;
  *(_DWORD *)(a2 + 36) = v9;
  return result;
}

//----- (10014A80) --------------------------------------------------------
_DWORD *__cdecl sub_10014A80(_DWORD *a1)
{
  _DWORD *v1; // esi

  v1 = sub_1001B810(a1, 0, 0, 0x60u);
  sub_10016E80((int)a1, (int)v1, 8);
  v1[7] = 0;
  v1[8] = 0;
  v1[22] = 0;
  v1[15] = 0;
  *((_BYTE *)v1 + 50) = 0;
  *((_BYTE *)v1 + 48) = 0;
  v1[13] = 0;
  *((_BYTE *)v1 + 49) = 1;
  v1[14] = 0;
  v1[20] = 0;
  *((_WORD *)v1 + 22) = 0;
  *((_WORD *)v1 + 23) = 0;
  v1[5] = 0;
  v1[10] = 0;
  v1[23] = 0;
  v1[16] = 0;
  v1[4] = a1[4];
  sub_100149F0(a1, (int)v1);
  v1[16] = a1[16];
  v1[18] = a1[18];
  v1[19] = a1[19];
  return v1;
}

//----- (10014B00) --------------------------------------------------------
void *__cdecl sub_10014B00(_DWORD *a1, int a2)
{
  sub_10019670(a2, *(_DWORD *)(a2 + 28));
  sub_1001B810(a1, *(void **)(a2 + 40), 24 * *(unsigned __int16 *)(a2 + 44), 0);
  sub_1001B810(a1, *(void **)(a2 + 28), 16 * *(_DWORD *)(a2 + 32), 0);
  return sub_1001B810(a1, (void *)a2, 96, 0);
}

//----- (10014B50) --------------------------------------------------------
int __cdecl sub_10014B50(_DWORD *a1, int a2)
{
  _DWORD v3[8]; // [esp+4h] [ebp-60h] BYREF
  char v4[64]; // [esp+24h] [ebp-40h] BYREF

  if ( sub_1001ABE0((int)a1, a2, (int)v3) && (sub_1001B610(a1, "Snl", v3), v3[5] > 0) )
    return sub_1000F2F0(a1, "%s:%d: ", (int)v4);
  else
    return sub_1000F200(a1, byte_1003D986, 0);
}
// 10014B50: using guessed type char var_40[64];

//----- (10014BC0) --------------------------------------------------------
void __noreturn sub_10014BC0(_DWORD *a1, char *a2, ...)
{
  va_list va; // [esp+10h] [ebp+Ch] BYREF

  va_start(va, a2);
  sub_10014B50(a1, 1);
  sub_1000F2C0(a1, a2, (int)va);
  sub_1000F9C0(a1, 2);
  sub_1000F960(a1);
}

//----- (10014BF0) --------------------------------------------------------
int __cdecl sub_10014BF0(const char *a1, const char **a2)
{
  const char *v2; // ecx
  int v3; // edi

  v2 = *a2;
  v3 = 0;
  if ( !*a2 )
    return -1;
  while ( strcmp(v2, a1) )
  {
    v2 = a2[++v3];
    if ( !v2 )
      return -1;
  }
  return v3;
}

//----- (10014C50) --------------------------------------------------------
int __cdecl sub_10014C50(_DWORD *a1, char *a2)
{
  sub_1000F250(a1, a2);
  return sub_1000F430(a1, -10000);
}

//----- (10014C70) --------------------------------------------------------
int __cdecl sub_10014C70(_DWORD *a1, int a2, const char *a3)
{
  const char *v3; // eax

  if ( sub_1000F510(a1, a2) )
  {
    sub_1000F430(a1, -10000);
    v3 = (const char *)sub_1000F010(a1, -1);
    if ( v3 && !strcmp(v3, a3) )
    {
      sub_1000EBD0((int)a1, -2);
      return sub_1000F0E0(a1, a2);
    }
    sub_1000EBD0((int)a1, -2);
  }
  return 0;
}

//----- (10014D00) --------------------------------------------------------
int __cdecl sub_10014D00(_DWORD *a1, int a2, const char *a3)
{
  int result; // eax

  result = sub_1000EAC0(a1, a2);
  if ( !result )
    sub_10014BC0(a1, "stack overflow (%s)", a3);
  return result;
}

//----- (10014D30) --------------------------------------------------------
int __cdecl sub_10014D30(_DWORD *a1, int a2, char *a3)
{
  if ( !sub_1000F510(a1, a2) )
    return 0;
  sub_1000F250(a1, a3);
  sub_1000F430(a1, -2);
  if ( !sub_1000ED80(a1, -1) )
  {
    sub_1000EBD0((int)a1, -3);
    return 0;
  }
  sub_1000EC30(a1, -2);
  return 1;
}

//----- (10014D90) --------------------------------------------------------
int __cdecl sub_10014D90(_DWORD *a1, int a2, char *a3)
{
  int v3; // esi
  int result; // eax

  v3 = a2;
  if ( a2 <= 0 && a2 > -10000 )
    v3 = a2 + sub_1000EBC0((int)a1) + 1;
  result = sub_10014D30(a1, v3, a3);
  if ( result )
  {
    sub_1000ED40(a1, v3);
    sub_1000F7B0((int)a1, 1, 1);
    return 1;
  }
  return result;
}

//----- (10014DF0) --------------------------------------------------------
int __usercall sub_10014DF0@<eax>(_DWORD *a1@<esi>)
{
  int result; // eax

  sub_1000F480(a1, -10000, 2);
  result = sub_1000ED80(a1, -1);
  if ( !result )
  {
    sub_1000EBD0((int)a1, -2);
    sub_1000F4D0(a1);
    sub_1000ED40(a1, -1);
    sub_1000F6D0(a1, -2);
    sub_1000F200(a1, "__mode", 6u);
    sub_1000F200(a1, "k", 1u);
    sub_1000F610(a1, -3);
    sub_1000ED40(a1, -1);
    return sub_1000F670(a1, -10000, 2);
  }
  return result;
}

//----- (10014E70) --------------------------------------------------------
int __cdecl sub_10014E70(_DWORD *a1, int a2, int a3)
{
  int v3; // ebx
  int v4; // edi

  v3 = a2;
  if ( a2 <= 0 && a2 > -10000 )
    v3 = a2 + sub_1000EBC0((int)a1) + 1;
  sub_1000F200(a1, "n", 1u);
  sub_1000F430(a1, v3);
  v4 = (unsigned __int64)sub_1000EF80(a1, -1);
  if ( !v4 && !sub_1000EE10(a1, -1) )
    v4 = -1;
  sub_1000EBD0((int)a1, -2);
  if ( v4 < 0 )
  {
    sub_10014DF0(a1);
    sub_1000ED40(a1, v3);
    sub_1000F1E0((int)a1, (double)a3);
    sub_1000F610(a1, -3);
    return sub_1000EBD0((int)a1, -2);
  }
  else
  {
    sub_1000F200(a1, "n", 1u);
    sub_1000F1E0((int)a1, (double)a3);
    return sub_1000F610(a1, v3);
  }
}

//----- (10014F40) --------------------------------------------------------
int __cdecl sub_10014F40(_DWORD *a1, int a2)
{
  int v2; // ebx
  int v3; // edi
  int v5; // edi

  v2 = a2;
  if ( a2 <= 0 && a2 > -10000 )
    v2 = a2 + sub_1000EBC0((int)a1) + 1;
  sub_1000F200(a1, "n", 1u);
  sub_1000F430(a1, v2);
  v3 = (unsigned __int64)sub_1000EF80(a1, -1);
  if ( !v3 && !sub_1000EE10(a1, -1) )
    v3 = -1;
  sub_1000EBD0((int)a1, -2);
  if ( v3 >= 0 )
    return v3;
  sub_10014DF0(a1);
  sub_1000ED40(a1, v2);
  sub_1000F430(a1, -2);
  v3 = (unsigned __int64)sub_1000EF80(a1, -1);
  if ( !v3 && !sub_1000EE10(a1, -1) )
    v3 = -1;
  sub_1000EBD0((int)a1, -3);
  if ( v3 >= 0 )
    return v3;
  v5 = 1;
  sub_1000F480(a1, v2, 1);
  while ( sub_1000ED80(a1, -1) )
  {
    sub_1000EBD0((int)a1, -2);
    sub_1000F480(a1, v2, ++v5);
  }
  sub_1000EBD0((int)a1, -2);
  return v5 - 1;
}

//----- (10015060) --------------------------------------------------------
int __cdecl sub_10015060(int a1)
{
  int result; // eax
  int v3; // esi
  _DWORD *v4; // ebx
  int v5; // edi
  unsigned int v6; // eax
  unsigned int v7; // [esp+Ch] [ebp+4h]

  result = *(_DWORD *)(a1 + 4);
  v3 = 1;
  if ( result > 1 )
  {
    v4 = *(_DWORD **)(a1 + 8);
    v7 = sub_1000F080(v4, -1);
    v5 = -2;
    do
    {
      v6 = sub_1000F080(v4, v5);
      if ( *(_DWORD *)(a1 + 4) - v3 + 1 < 10 && v7 <= v6 )
        break;
      ++v3;
      --v5;
      v7 += v6;
    }
    while ( v3 < *(_DWORD *)(a1 + 4) );
    sub_1000F9C0(v4, v3);
    result = 1 - v3;
    *(_DWORD *)(a1 + 4) += 1 - v3;
  }
  return result;
}

//----- (100150E0) --------------------------------------------------------
int __cdecl sub_100150E0(int a1)
{
  int v1; // edx

  if ( *(_DWORD *)a1 - a1 != 12 )
  {
    sub_1000F200(*(_DWORD **)(a1 + 8), (char *)(a1 + 12), *(_DWORD *)a1 - a1 - 12);
    v1 = *(_DWORD *)(a1 + 4) + 1;
    *(_DWORD *)a1 = a1 + 12;
    *(_DWORD *)(a1 + 4) = v1;
    sub_10015060(a1);
  }
  return a1 + 12;
}

//----- (10015120) --------------------------------------------------------
_BYTE *__cdecl sub_10015120(int a1, _BYTE *a2, _BYTE *a3)
{
  _BYTE *result; // eax
  _BYTE *v5; // ebp
  int v6; // edx

  result = a3;
  if ( a3 )
  {
    v5 = a3;
    do
    {
      result = *(_BYTE **)a1;
      if ( *(_DWORD *)a1 >= (unsigned int)(a1 + 524) )
      {
        result = &result[-a1 - 12];
        if ( result )
        {
          sub_1000F200(*(_DWORD **)(a1 + 8), (char *)(a1 + 12), (unsigned int)result);
          v6 = *(_DWORD *)(a1 + 4) + 1;
          *(_DWORD *)a1 = a1 + 12;
          *(_DWORD *)(a1 + 4) = v6;
          result = (_BYTE *)sub_10015060(a1);
        }
      }
      **(_BYTE **)a1 = *a2++;
      --v5;
      ++*(_DWORD *)a1;
    }
    while ( v5 );
  }
  return result;
}

//----- (10015180) --------------------------------------------------------
char __cdecl sub_10015180(int a1)
{
  int v1; // eax
  char result; // al

  if ( *(_DWORD *)a1 - a1 != 12 )
  {
    sub_1000F200(*(_DWORD **)(a1 + 8), (char *)(a1 + 12), *(_DWORD *)a1 - a1 - 12);
    v1 = *(_DWORD *)(a1 + 4) + 1;
    *(_DWORD *)a1 = a1 + 12;
    *(_DWORD *)(a1 + 4) = v1;
  }
  result = sub_1000F9C0(*(_DWORD **)(a1 + 8), *(_DWORD *)(a1 + 4));
  *(_DWORD *)(a1 + 4) = 1;
  return result;
}

//----- (100151D0) --------------------------------------------------------
int __cdecl sub_100151D0(int a1)
{
  _DWORD *v2; // ebp
  unsigned int v3; // ecx
  void *v4; // eax
  unsigned int v6; // eax
  unsigned int v7; // [esp+10h] [ebp+4h]

  v2 = *(_DWORD **)(a1 + 8);
  v3 = sub_1000F080(v2, -1);
  v4 = *(void **)a1;
  v7 = v3;
  if ( v3 > a1 - *(_DWORD *)a1 + 524 )
  {
    v6 = (unsigned int)v4 - a1 - 12;
    if ( v6 )
    {
      sub_1000F200(*(_DWORD **)(a1 + 8), (char *)(a1 + 12), v6);
      *(_DWORD *)a1 = a1 + 12;
      ++*(_DWORD *)(a1 + 4);
      sub_1000EC90(v2, -2);
    }
    ++*(_DWORD *)(a1 + 4);
    return sub_10015060(a1);
  }
  else
  {
    qmemcpy(*(void **)a1, (const void *)sub_1000F010(v2, -1), v3);
    *(_DWORD *)a1 += v7;
    return sub_1000EBD0((int)v2, -2);
  }
}

//----- (10015270) --------------------------------------------------------
_DWORD *__cdecl sub_10015270(int a1, _DWORD *a2)
{
  _DWORD *result; // eax

  result = a2;
  a2[2] = a1;
  *a2 = a2 + 3;
  a2[1] = 0;
  return result;
}

//----- (10015290) --------------------------------------------------------
int __cdecl sub_10015290(int a1, FILE **a2, size_t *a3)
{
  size_t v4; // eax

  if ( ((*a2)->_flag & 0x10) != 0 )
    return 0;
  v4 = sub_10028C0F(a2 + 1, 1u, 0x200u, *a2);
  *a3 = v4;
  return v4 != 0 ? (unsigned int)(a2 + 1) : 0;
}

//----- (100152D0) --------------------------------------------------------
int __usercall sub_100152D0@<eax>(int a1@<ebx>, _DWORD *a2@<edi>)
{
  int v2; // esi
  int *v3; // eax
  _DWORD *v5; // [esp+0h] [ebp-Ch]
  int v6; // [esp+4h] [ebp-8h]

  v2 = sub_1000F010(v5, v6) + 1;
  v3 = _errno();
  strerror(*v3);
  sub_1000F2F0(a2, "cannot read %s: %s", v2);
  sub_1000EC30(a2, a1);
  return 2;
}
// 100152D3: variable 'v5' is possibly undefined
// 100152D3: variable 'v6' is possibly undefined

//----- (10015310) --------------------------------------------------------
int __cdecl sub_10015310(_DWORD *a1, char *FileName)
{
  int v2; // ebx
  FILE *v3; // eax
  int v4; // eax
  int v5; // ebp
  int v7; // esi
  int *v8; // eax
  void *v9; // eax
  int v10; // ebp
  int v11; // esi
  int v12; // esi
  int *v13; // eax
  FILE *v14; // [esp-8h] [ebp-218h]
  FILE *Stream; // [esp+Ch] [ebp-204h] BYREF

  v2 = sub_1000EBC0((int)a1) + 1;
  if ( FileName )
  {
    sub_1000F2F0(a1, "@%s", (int)FileName);
    v3 = (FILE *)sub_10027490(FileName, (int)"r");
    Stream = v3;
    if ( !v3 )
    {
      v7 = sub_1000F010(a1, v2) + 1;
      v8 = _errno();
      strerror(*v8);
      sub_1000F2F0(a1, "cannot read %s: %s", v7);
      sub_1000EC30(a1, v2);
      return 2;
    }
  }
  else
  {
    sub_1000F200(a1, "=stdin", 6u);
    v3 = &stru_1004B120;
    Stream = &stru_1004B120;
  }
  v14 = v3;
  v4 = fgetc(v3);
  v5 = ungetc_0(v4, v14);
  if ( !isspace(v5) && !isprint(v5) && Stream != &stru_1004B120 )
  {
    fclose(Stream);
    Stream = (FILE *)sub_10027490(FileName, (int)"rb");
    if ( !Stream )
      return sub_100152D0(v2, a1);
  }
  v9 = (void *)sub_1000F010(a1, -1);
  v10 = sub_1000F860(a1, (int)sub_10015290, (int)&Stream, v9);
  v11 = Stream->_flag & 0x20;
  if ( Stream != &stru_1004B120 )
    fclose(Stream);
  if ( v11 )
  {
    sub_1000EBD0((int)a1, v2);
    v12 = sub_1000F010(a1, v2) + 1;
    v13 = _errno();
    strerror(*v13);
    sub_1000F2F0(a1, "cannot read %s: %s", v12);
    sub_1000EC30(a1, v2);
    return 2;
  }
  else
  {
    sub_1000EC30(a1, v2);
    return v10;
  }
}

//----- (100154E0) --------------------------------------------------------
int __cdecl sub_100154E0(_DWORD *a1, int a2, int a3, void *a4)
{
  int v5[2]; // [esp+0h] [ebp-8h] BYREF

  v5[0] = a2;
  v5[1] = a3;
  return sub_1000F860(a1, (int)sub_100154C0, (int)v5, a4);
}
// 100154C0: using guessed type int sub_100154C0();

//----- (10015510) --------------------------------------------------------
void __cdecl __noreturn sub_10015510(_DWORD *a1, int a2, const char *a3)
{
  const char *v3; // eax
  int v4; // [esp+Ch] [ebp-60h] BYREF
  const char *v5; // [esp+10h] [ebp-5Ch]
  const char *v6; // [esp+14h] [ebp-58h]

  sub_1001ABE0((int)a1, 0, (int)&v4);
  sub_1001B610(a1, "n", &v4);
  if ( !strcmp(v6, "method") && !--a2 )
    sub_10014BC0(a1, "calling `%s' on bad self (%s)", v5, a3);
  v3 = v5;
  if ( !v5 )
  {
    v3 = (const char *)&unk_1003E150;
    v5 = (const char *)&unk_1003E150;
  }
  sub_10014BC0(a1, "bad argument #%d to `%s' (%s)", a2, v3, a3);
}

//----- (100155B0) --------------------------------------------------------
int __cdecl sub_100155B0(_DWORD *a1, int a2, int a3)
{
  int result; // eax
  const char *v4; // ebx
  int v5; // eax
  const char *v6; // eax

  result = sub_1000ED80(a1, a2);
  if ( result != a3 )
  {
    v4 = sub_1000EDB0((int)a1, a3);
    v5 = sub_1000ED80(a1, a2);
    sub_1000EDB0((int)a1, v5);
    v6 = (const char *)sub_1000F2F0(a1, "%s expected, got %s", (int)v4);
    sub_10015510(a1, a2, v6);
  }
  return result;
}

//----- (10015600) --------------------------------------------------------
int __cdecl sub_10015600(_DWORD *a1, int a2)
{
  int result; // eax

  result = sub_1000ED80(a1, a2);
  if ( result == -1 )
    sub_10015510(a1, a2, "value expected");
  return result;
}

//----- (10015630) --------------------------------------------------------
int __cdecl sub_10015630(_DWORD *a1, int a2, int *a3)
{
  int v3; // ebx
  const char *v4; // ebp
  int v5; // eax
  const char *v6; // eax

  v3 = sub_1000F010(a1, a2);
  if ( !v3 )
  {
    v4 = sub_1000EDB0((int)a1, 4);
    v5 = sub_1000ED80(a1, a2);
    sub_1000EDB0((int)a1, v5);
    v6 = (const char *)sub_1000F2F0(a1, "%s expected, got %s", (int)v4);
    sub_10015510(a1, a2, v6);
  }
  if ( a3 )
    *a3 = sub_1000F080(a1, a2);
  return v3;
}

//----- (100156A0) --------------------------------------------------------
int __cdecl sub_100156A0(_DWORD *a1, int a2, const char *a3, int *a4)
{
  int result; // eax

  if ( sub_1000ED80(a1, a2) > 0 )
    return sub_10015630(a1, a2, a4);
  result = (int)a3;
  if ( a4 )
  {
    if ( a3 )
      *a4 = strlen(a3);
    else
      *a4 = 0;
  }
  return result;
}

//----- (10015700) --------------------------------------------------------
double __cdecl sub_10015700(_DWORD *a1, int a2)
{
  double result; // st7
  const char *v3; // ebx
  int v4; // eax
  const char *v5; // eax

  result = sub_1000EF80(a1, a2);
  if ( result == 0.0 && !sub_1000EE10(a1, a2) )
  {
    v3 = sub_1000EDB0((int)a1, 3);
    v4 = sub_1000ED80(a1, a2);
    sub_1000EDB0((int)a1, v4);
    v5 = (const char *)sub_1000F2F0(a1, "%s expected, got %s", (int)v3);
    sub_10015510(a1, a2, v5);
  }
  return result;
}

//----- (10015780) --------------------------------------------------------
double __cdecl sub_10015780(_DWORD *a1, int a2, double a3)
{
  if ( sub_1000ED80(a1, a2) > 0 )
    return sub_10015700(a1, a2);
  else
    return a3;
}

//----- (100157B0) --------------------------------------------------------
_DWORD *__usercall sub_100157B0@<eax>(int a1@<eax>, _DWORD *a2@<ecx>, int a3@<edi>)
{
  _DWORD *result; // eax
  int v5; // eax
  int v6; // ecx

  result = (_DWORD *)(a1 - 1);
  switch ( (unsigned int)result )
  {
    case 0u:
    case 2u:
      v5 = *(_DWORD *)(a3 + 8);
      v6 = *(_DWORD *)(v5 - 16);
      v5 -= 16;
      *a2 = v6;
      a2[2] = *(_DWORD *)(v5 + 8);
      result = *(_DWORD **)(v5 + 12);
      a2[3] = result;
      goto LABEL_5;
    case 3u:
      *a2 = 4;
      result = sub_100194B0(a3, "not enough memory", 0x11u);
      a2[2] = result;
      *(_DWORD *)(a3 + 8) = a2 + 4;
      break;
    case 4u:
      *a2 = 4;
      result = sub_100194B0(a3, "error in error handling", 0x17u);
      a2[2] = result;
      *(_DWORD *)(a3 + 8) = a2 + 4;
      break;
    default:
LABEL_5:
      *(_DWORD *)(a3 + 8) = a2 + 4;
      break;
  }
  return result;
}

//----- (10015840) --------------------------------------------------------
void __cdecl __noreturn sub_10015840(int a1, int a2)
{
  int v2; // ecx

  v2 = *(_DWORD *)(a1 + 88);
  if ( v2 )
  {
    *(_DWORD *)(v2 + 68) = a2;
    longjmp((int *)(*(_DWORD *)(a1 + 88) + 4), 1);
  }
  (*(void (__cdecl **)(int))(*(_DWORD *)(a1 + 16) + 40))(a1);
  exit(1);
}

//----- (10015880) --------------------------------------------------------
int __cdecl sub_10015880(int a1, void (__cdecl *a2)(int, int), int a3)
{
  int v3; // ecx
  int result; // eax
  int v5; // [esp+4h] [ebp-48h] BYREF
  char v6[64]; // [esp+8h] [ebp-44h] BYREF
  int v7; // [esp+48h] [ebp-4h]

  v3 = *(_DWORD *)(a1 + 88);
  *(_DWORD *)(a1 + 88) = &v5;
  v7 = 0;
  v5 = v3;
  if ( _setjmp3(v6, 0) )
  {
    *(_DWORD *)(a1 + 88) = v5;
    return v7;
  }
  else
  {
    a2(a1, a3);
    result = v7;
    *(_DWORD *)(a1 + 88) = v5;
  }
  return result;
}
// 10015880: using guessed type char var_44[64];

//----- (10015960) --------------------------------------------------------
_DWORD *__cdecl sub_10015960(_DWORD *a1, int a2)
{
  _DWORD *i; // ecx
  _DWORD *j; // ecx
  void *v4; // edi
  char *v5; // eax
  _DWORD *result; // eax

  v4 = (void *)a1[7];
  v5 = (char *)sub_1001B810(a1, v4, 16 * a1[8], 16 * a2);
  a1[8] = a2;
  a1[7] = v5;
  a1[6] = &v5[16 * a2 - 96];
  result = a1;
  a1[2] = a1[7] + 16 * ((a1[2] - (int)v4) >> 4);
  for ( i = (_DWORD *)a1[20]; i; i = (_DWORD *)*i )
    i[2] = a1[7] + 16 * ((i[2] - (int)v4) >> 4);
  for ( j = (_DWORD *)a1[10]; (unsigned int)j <= a1[5]; j += 6 )
  {
    j[1] = a1[7] + 16 * ((j[1] - (int)v4) >> 4);
    *j = a1[7] + 16 * ((*j - (int)v4) >> 4);
  }
  a1[3] = *(_DWORD *)a1[5];
  return result;
}

//----- (100159B0) --------------------------------------------------------
char *__cdecl sub_100159B0(int a1, int a2)
{
  void *v2; // ebx
  char *v3; // ecx
  char *result; // eax

  v2 = *(void **)(a1 + 40);
  v3 = (char *)sub_1001B810((_DWORD *)a1, v2, 24 * *(unsigned __int16 *)(a1 + 44), 24 * a2);
  *(_DWORD *)(a1 + 20) = &v3[24 * ((*(_DWORD *)(a1 + 20) - (int)v2) / 24)];
  *(_WORD *)(a1 + 44) = a2;
  result = &v3[24 * (unsigned __int16)a2];
  *(_DWORD *)(a1 + 40) = v3;
  *(_DWORD *)(a1 + 36) = result;
  return result;
}

//----- (10015A20) --------------------------------------------------------
_DWORD *__cdecl sub_10015A20(_DWORD *a1, int a2)
{
  _DWORD *i; // ecx
  _DWORD *j; // ecx
  int v4; // eax
  void *v5; // ebx
  int v6; // edi
  char *v7; // eax
  _DWORD *result; // eax

  v4 = a1[8];
  v5 = (void *)a1[7];
  if ( a2 > v4 )
  {
    v6 = v4 + a2 + 5;
    v7 = (char *)sub_1001B810(a1, v5, 16 * v4, 16 * v6);
  }
  else
  {
    v6 = 2 * v4;
    v7 = (char *)sub_1001B810(a1, v5, 16 * v4, 32 * v4);
  }
  a1[8] = v6;
  a1[6] = &v7[16 * v6 - 96];
  a1[7] = v7;
  result = a1;
  a1[2] = a1[7] + 16 * ((a1[2] - (int)v5) >> 4);
  for ( i = (_DWORD *)a1[20]; i; i = (_DWORD *)*i )
    i[2] = a1[7] + 16 * ((i[2] - (int)v5) >> 4);
  for ( j = (_DWORD *)a1[10]; (unsigned int)j <= a1[5]; j += 6 )
  {
    j[1] = a1[7] + 16 * ((j[1] - (int)v5) >> 4);
    *j = a1[7] + 16 * ((*j - (int)v5) >> 4);
  }
  a1[3] = *(_DWORD *)a1[5];
  return result;
}

//----- (10015AA0) --------------------------------------------------------
char __cdecl sub_10015AA0(int a1, int a2, int a3)
{
  int v4; // eax
  int v5; // ecx
  int v6; // eax
  int v7; // ebx
  int v8; // edi
  int v9; // ebp
  int v10; // edx
  int v12[23]; // [esp+4h] [ebp-60h] BYREF
  int v13; // [esp+60h] [ebp-4h]
  void (__cdecl *v14)(int, int *); // [esp+68h] [ebp+4h]

  v14 = *(void (__cdecl **)(int, int *))(a1 + 60);
  LOBYTE(v4) = (_BYTE)v14;
  if ( v14 )
  {
    LOBYTE(v4) = *(_BYTE *)(a1 + 49);
    if ( (_BYTE)v4 )
    {
      v5 = *(_DWORD *)(a1 + 28);
      v6 = *(_DWORD *)(a1 + 20);
      v7 = *(_DWORD *)(a1 + 8);
      v8 = v7 - v5;
      v9 = *(_DWORD *)(v6 + 4) - v5;
      v12[0] = a2;
      v12[5] = a3;
      if ( a2 == 4 )
        v13 = 0;
      else
        v13 = (v6 - *(_DWORD *)(a1 + 40)) / 24;
      if ( *(_DWORD *)(a1 + 24) - v7 <= 320 )
        sub_10015A20((_DWORD *)a1, 20);
      *(_DWORD *)(*(_DWORD *)(a1 + 20) + 4) = *(_DWORD *)(a1 + 8) + 320;
      *(_BYTE *)(a1 + 49) = 0;
      v14(a1, v12);
      v4 = *(_DWORD *)(a1 + 20);
      v10 = v9 + *(_DWORD *)(a1 + 28);
      *(_BYTE *)(a1 + 49) = 1;
      *(_DWORD *)(v4 + 4) = v10;
      *(_DWORD *)(a1 + 8) = v8 + *(_DWORD *)(a1 + 28);
    }
  }
  return v4;
}

//----- (10015B70) --------------------------------------------------------
int __usercall sub_10015B70@<eax>(int a1@<edx>, _DWORD *a2@<esi>, int a3)
{
  int v3; // ebx
  int v4; // edi
  int v5; // ebx
  _DWORD *v6; // edi
  int v7; // eax
  int v8; // ecx
  int v9; // ebp
  _DWORD *v10; // edi
  _DWORD *v11; // eax
  double *v12; // eax
  _DWORD *v13; // ebp
  int result; // eax
  int v15; // [esp+Ch] [ebp-18h]
  double v16; // [esp+14h] [ebp-10h] BYREF
  _DWORD *v17; // [esp+1Ch] [ebp-8h]
  int i; // [esp+28h] [ebp+4h]

  v3 = (a2[2] - a1) >> 4;
  if ( v3 < a3 )
  {
    v4 = a3 - v3;
    if ( a2[6] - a2[2] <= 16 * (a3 - v3) )
      sub_10015A20(a2, a3 - v3);
    v3 = a3;
    do
    {
      *(_DWORD *)a2[2] = 0;
      --v4;
      a2[2] += 16;
    }
    while ( v4 );
  }
  v5 = v3 - a3;
  v6 = sub_10019C10(a2, v5, 1);
  v7 = 0;
  v15 = (int)v6;
  if ( v5 > 0 )
  {
    v8 = -16 * v5;
    for ( i = -16 * v5; ; v8 = i )
    {
      v9 = v7 + 1;
      v10 = (_DWORD *)(v8 + a2[2]);
      v11 = sub_1001A3D0(a2, v15, v7 + 1);
      *v11 = *v10;
      v11[2] = v10[2];
      v11[3] = v10[3];
      v7 = v9;
      i += 16;
      if ( v9 >= v5 )
        break;
    }
    v6 = (_DWORD *)v15;
  }
  LODWORD(v16) = 4;
  v17 = sub_100194B0((int)a2, "n", 1u);
  v12 = (double *)sub_10019E50(a2, (int)v6, &v16);
  *(_DWORD *)v12 = 3;
  v12[1] = (double)v5;
  v13 = (_DWORD *)(-16 * v5 + a2[2]);
  a2[2] = v13;
  v13[2] = v6;
  *v13 = 5;
  if ( a2[6] - a2[2] <= 16 )
    sub_10015A20(a2, 1);
  result = a2[2] + 16;
  a2[2] = result;
  return result;
}
// 10015B70: using guessed type double var_10;

//----- (10015CB0) --------------------------------------------------------
char *__usercall sub_10015CB0@<eax>(_DWORD *a1@<edi>, _DWORD *a2@<esi>)
{
  _DWORD *v2; // ebx
  char *v3; // ebp
  _DWORD *i; // eax
  int v5; // eax
  char *result; // eax

  v2 = sub_10016EE0((int)a2, a1, 14);
  v3 = (char *)a1 - a2[7];
  if ( *v2 != 6 )
    sub_1001B6D0(a2, (int)a1, (int)"call");
  for ( i = (_DWORD *)a2[2]; i > a1; i -= 4 )
  {
    *i = *(i - 4);
    i[2] = *(i - 2);
    i[3] = *(i - 1);
  }
  if ( a2[6] - a2[2] <= 16 )
    sub_10015A20(a2, 1);
  v5 = a2[7];
  a2[2] += 16;
  result = &v3[v5];
  *(_DWORD *)result = *v2;
  *((_DWORD *)result + 2) = v2[2];
  *((_DWORD *)result + 3) = v2[3];
  return result;
}

//----- (10015D40) --------------------------------------------------------
int __cdecl sub_10015D40(int a1, char *a2)
{
  char *v2; // edi
  char *v3; // ebp
  unsigned __int16 v4; // ax
  int v5; // eax
  int v6; // ebx
  int v7; // ecx
  _DWORD *v8; // eax
  int v9; // ecx
  unsigned int v10; // ecx
  unsigned int v11; // ebx
  _DWORD *v13; // edx
  _DWORD *v14; // eax
  int v15; // edx
  int v16; // [esp+0h] [ebp-Ch]

  v2 = a2;
  v3 = &a2[-*(_DWORD *)(a1 + 28)];
  if ( *(_DWORD *)a2 != 6 )
    v2 = sub_10015CB0(a2, (_DWORD *)a1);
  if ( *(_DWORD *)(a1 + 20) + 24 == *(_DWORD *)(a1 + 36) )
  {
    v4 = *(_WORD *)(a1 + 44);
    if ( v4 > 0x1000u )
      sub_10015840(a1, 5);
    sub_100159B0(a1, 2 * v4);
    if ( *(_WORD *)(a1 + 44) > 0x1000u )
      sub_1001B4B0((_DWORD *)a1, "stack overflow", v16);
  }
  v5 = *((_DWORD *)v2 + 2);
  if ( *(_BYTE *)(v5 + 6) )
  {
    if ( *(_DWORD *)(a1 + 24) - *(_DWORD *)(a1 + 8) <= 320 )
      sub_10015A20((_DWORD *)a1, 20);
    v13 = (_DWORD *)(*(_DWORD *)(a1 + 20) + 24);
    *(_DWORD *)(a1 + 20) = v13;
    v14 = v13;
    *v13 = &v3[*(_DWORD *)(a1 + 28) + 16];
    v15 = *(_DWORD *)(a1 + 8);
    *(_DWORD *)(a1 + 12) = **(_DWORD **)(a1 + 20);
    v14[1] = v15 + 320;
    v14[2] = 1;
    if ( (*(_BYTE *)(a1 + 48) & 1) != 0 )
      sub_10015AA0(a1, 0, -1);
    return *(_DWORD *)(a1 + 8) - 16 * (*(int (__cdecl **)(int))(*(_DWORD *)(*(_DWORD *)(a1 + 12) - 8) + 12))(a1);
  }
  else
  {
    v6 = *(_DWORD *)(v5 + 12);
    if ( *(_BYTE *)(v6 + 70) )
      sub_10015B70((int)(v2 + 16), (_DWORD *)a1, *(unsigned __int8 *)(v6 + 69));
    if ( *(_DWORD *)(a1 + 24) - *(_DWORD *)(a1 + 8) <= 16 * *(unsigned __int8 *)(v6 + 71) )
      sub_10015A20((_DWORD *)a1, *(unsigned __int8 *)(v6 + 71));
    v7 = *(_DWORD *)(a1 + 28);
    v8 = (_DWORD *)(*(_DWORD *)(a1 + 20) + 24);
    *(_DWORD *)(a1 + 20) = v8;
    *v8 = &v3[v7 + 16];
    v9 = **(_DWORD **)(a1 + 20);
    *(_DWORD *)(a1 + 12) = v9;
    v8[1] = v9 + 16 * *(unsigned __int8 *)(v6 + 71);
    v8[3] = *(_DWORD *)(v6 + 12);
    v10 = v8[1];
    v8[5] = 0;
    v8[2] = 8;
    if ( *(_DWORD *)(a1 + 8) < v10 )
    {
      do
      {
        **(_DWORD **)(a1 + 8) = 0;
        v11 = *(_DWORD *)(a1 + 8) + 16;
        *(_DWORD *)(a1 + 8) = v11;
      }
      while ( v11 < v8[1] );
    }
    *(_DWORD *)(a1 + 8) = v8[1];
    return 0;
  }
}
// 10015D9C: variable 'v16' is possibly undefined

//----- (10015EE0) --------------------------------------------------------
int __usercall sub_10015EE0@<eax>(int a1@<eax>, int a2@<esi>)
{
  int v2; // edi
  int v3; // eax

  v2 = a1 - *(_DWORD *)(a2 + 28);
  sub_10015AA0(a2, 1, -1);
  v3 = *(_DWORD *)(a2 + 20);
  if ( (*(_BYTE *)(v3 + 8) & 1) == 0 )
  {
    if ( *(_DWORD *)(v3 + 20) )
    {
      do
      {
        --*(_DWORD *)(*(_DWORD *)(a2 + 20) + 20);
        sub_10015AA0(a2, 4, -1);
      }
      while ( *(_DWORD *)(*(_DWORD *)(a2 + 20) + 20) );
    }
    --*(_DWORD *)(*(_DWORD *)(a2 + 20) + 20);
  }
  return v2 + *(_DWORD *)(a2 + 28);
}

//----- (10015F40) --------------------------------------------------------
_DWORD *__cdecl sub_10015F40(int a1, int a2, int a3)
{
  _DWORD *result; // eax
  int v4; // ecx
  int v5; // ebx
  _DWORD *v6; // edi
  _DWORD *v7; // ecx
  _DWORD *v8; // edi
  int v9; // edx

  result = (_DWORD *)a3;
  if ( (*(_BYTE *)(a1 + 48) & 2) != 0 )
    result = (_DWORD *)sub_10015EE0(a3, a1);
  v4 = *(_DWORD *)(a1 + 12);
  v5 = a2;
  v6 = (_DWORD *)(*(_DWORD *)(a1 + 20) - 24);
  *(_DWORD *)(a1 + 20) = v6;
  v7 = (_DWORD *)(v4 - 16);
  *(_DWORD *)(a1 + 12) = *v6;
  if ( a2 )
  {
    do
    {
      if ( (unsigned int)result >= *(_DWORD *)(a1 + 8) )
        break;
      v8 = v7;
      *v7 = *result;
      v7[2] = result[2];
      v9 = result[3];
      result += 4;
      v7 += 4;
      --v5;
      v8[3] = v9;
    }
    while ( v5 );
    if ( v5 > 0 )
    {
      do
      {
        *v7 = 0;
        v7 += 4;
        --v5;
      }
      while ( v5 );
    }
  }
  *(_DWORD *)(a1 + 8) = v7;
  return result;
}

//----- (10015FC0) --------------------------------------------------------
char __cdecl sub_10015FC0(int a1, char *a2, int a3)
{
  unsigned __int16 v3; // ax
  double *v4; // eax
  int v5; // eax
  int v7; // [esp+0h] [ebp-4h]

  v3 = ++*(_WORD *)(a1 + 46);
  if ( v3 >= 0xC8u )
  {
    if ( v3 == 200 )
      sub_1001B4B0((_DWORD *)a1, "C stack overflow", v7);
    if ( v3 >= 0xE1u )
      sub_10015840(a1, 5);
  }
  v4 = (double *)sub_10015D40(a1, a2);
  if ( !v4 )
    v4 = sub_10017C10(a1);
  sub_10015F40(a1, a3, (int)v4);
  v5 = *(_DWORD *)(a1 + 16);
  --*(_WORD *)(a1 + 46);
  if ( *(_DWORD *)(v5 + 36) >= *(_DWORD *)(v5 + 32) )
    LOBYTE(v5) = sub_10016E30((_DWORD *)a1);
  return v5;
}
// 10015FDB: variable 'v7' is possibly undefined

//----- (10016040) --------------------------------------------------------
double *__cdecl sub_10016040(_DWORD *a1, int *a2)
{
  int v2; // ebx
  int v3; // eax
  int v4; // ecx
  int v5; // esi
  double *result; // eax
  int v7; // [esp+0h] [ebp-Ch]

  v2 = *a2;
  v3 = a1[5];
  if ( v3 == a1[10] )
  {
    if ( v2 >= (a1[2] - a1[3]) >> 4 )
      sub_1001B4B0(a1, "cannot resume dead coroutine", v7);
    sub_10015D40((int)a1, (char *)(a1[2] - 16 * (v2 + 1)));
  }
  else
  {
    v4 = *(_DWORD *)(v3 + 8);
    if ( (v4 & 0x10) == 0 )
      sub_1001B4B0(a1, "cannot resume non-suspended coroutine", v7);
    if ( (v4 & 1) != 0 )
    {
      v5 = ((*(_DWORD *)(*(_DWORD *)(v3 - 12) - 4) >> 6) & 0x1FF) - 1;
      sub_10015F40((int)a1, v5, a1[2] - 16 * v2);
      if ( v5 >= 0 )
        a1[2] = *(_DWORD *)(a1[5] + 4);
    }
    else
    {
      *(_DWORD *)(v3 + 8) = v4 & 0xFFFFFFEF;
    }
  }
  result = sub_10017C10((int)a1);
  if ( result )
    return (double *)sub_10015F40((int)a1, -1, (int)result);
  return result;
}
// 10016068: variable 'v7' is possibly undefined

//----- (10016100) --------------------------------------------------------
int __cdecl sub_10016100(int a1, int a2)
{
  int v2; // edi
  int v3; // ebx
  int v4; // eax
  int v5; // edi
  int v6; // edx
  int v7; // eax
  int v8; // ebp
  int v9; // eax
  _DWORD *v10; // ecx
  int v12; // [esp+0h] [ebp-Ch]
  int v13; // [esp+8h] [ebp-4h]

  v2 = *(_DWORD *)(a1 + 20);
  v13 = v2;
  if ( *(_WORD *)(a1 + 46) )
    sub_1001B4B0((_DWORD *)a1, "attempt to yield across metamethod/C-call boundary", v12);
  if ( (*(_BYTE *)(v2 + 8) & 1) != 0 )
  {
    if ( (*(_BYTE *)(v2 - 16) & 1) != 0 )
      sub_1001B4B0((_DWORD *)a1, "cannot yield a C function", v12);
    v3 = a2;
    v4 = 16 * a2;
    if ( (unsigned int)(*(_DWORD *)(a1 + 8) - 16 * a2) > *(_DWORD *)(a1 + 12) )
    {
      if ( a2 > 0 )
      {
        v5 = 0;
        v6 = -16 * a2;
        do
        {
          v7 = *(_DWORD *)(a1 + 8);
          v8 = *(_DWORD *)(v7 + v6);
          v9 = v6 + v7;
          v10 = (_DWORD *)(v5 + *(_DWORD *)(a1 + 12));
          *v10 = v8;
          v10[2] = *(_DWORD *)(v9 + 8);
          v5 += 16;
          v6 += 16;
          --v3;
          v10[3] = *(_DWORD *)(v9 + 12);
        }
        while ( v3 );
        v4 = 16 * a2;
        v2 = v13;
      }
      *(_DWORD *)(a1 + 8) = v4 + *(_DWORD *)(a1 + 12);
    }
    *(_DWORD *)(v2 + 8) |= 0x10u;
    return -1;
  }
  else
  {
    *(_DWORD *)(v2 + 8) |= 0x10u;
    return -1;
  }
}
// 1001611B: variable 'v12' is possibly undefined

//----- (100161D0) --------------------------------------------------------
int __cdecl sub_100161D0(_DWORD *a1, int a2)
{
  _DWORD *v2; // eax
  _DWORD *v3; // edi
  _BYTE *v4; // eax
  _DWORD *v5; // ecx
  int result; // eax

  if ( *(_DWORD *)(a1[4] + 36) >= *(_DWORD *)(a1[4] + 32) )
    sub_10016E30(a1);
  if ( *(_DWORD *)(a2 + 12) )
    v2 = sub_10020740(a1, *(_DWORD **)a2, (_DWORD *)(a2 + 4));
  else
    v2 = (_DWORD *)sub_1001FC00((int)a1, *(_DWORD **)a2, a2 + 4);
  v3 = v2;
  v4 = sub_100195C0(a1, 0, a1 + 16);
  *((_DWORD *)v4 + 3) = v3;
  v5 = (_DWORD *)a1[2];
  *v5 = 6;
  v5[2] = v4;
  if ( a1[6] - a1[2] <= 16 )
    sub_10015A20(a1, 1);
  result = a1[2] + 16;
  a1[2] = result;
  return result;
}

//----- (10016260) --------------------------------------------------------
int __cdecl sub_10016260(_DWORD *a1, int a2, int a3)
{
  int v3; // esi
  int v4; // ebx
  int result; // eax
  int v6; // [esp+Ch] [ebp-10h] BYREF
  void *v7; // [esp+10h] [ebp-Ch]
  int v8; // [esp+14h] [ebp-8h]
  int v9; // [esp+18h] [ebp-4h]

  v3 = a1[2] - a1[7];
  v6 = a2;
  v9 = a3;
  v7 = 0;
  v8 = 0;
  v4 = sub_10015880((int)a1, (void (__cdecl *)(int, int))sub_100161D0, (int)&v6);
  v7 = sub_1001B810(a1, v7, v8, 0);
  v8 = 0;
  result = v4;
  if ( v4 )
  {
    sub_100157B0(v4, (_DWORD *)(v3 + a1[7]), (int)a1);
    return v4;
  }
  return result;
}

//----- (100162E0) --------------------------------------------------------
char *__thiscall sub_100162E0(int this)
{
  bool v1; // cc
  char *result; // eax

  v1 = *(_WORD *)(this + 44) <= 0x1000u;
  result = (char *)(16 * *(_DWORD *)(this + 32) + *(_DWORD *)(this + 28) - 16);
  *(_DWORD *)(this + 24) = result;
  if ( !v1 )
  {
    result = (char *)((unsigned int)((unsigned __int64)(715827883i64 * (*(_DWORD *)(this + 20) - *(_DWORD *)(this + 40))) >> 32) >> 31);
    if ( (*(_DWORD *)(this + 20) - *(_DWORD *)(this + 40)) / 24 + 1 < 4096 )
      return sub_100159B0(this, 4096);
  }
  return result;
}

//----- (10016330) --------------------------------------------------------
int sub_10016330(int a1, ...)
{
  char v1; // bl
  int v2; // esi
  unsigned int *v3; // eax
  unsigned int v5; // [esp-4h] [ebp-10h]
  va_list va; // [esp+14h] [ebp+8h] BYREF

  va_start(va, a1);
  v1 = *(_BYTE *)(a1 + 49);
  v2 = sub_10015880(a1, (void (__cdecl *)(int, int))sub_10016040, (int)va);
  if ( v2 )
  {
    v3 = *(unsigned int **)(a1 + 40);
    *(_DWORD *)(a1 + 20) = v3;
    v5 = *v3;
    *(_DWORD *)(a1 + 12) = *v3;
    *(_WORD *)(a1 + 46) = 0;
    sub_10019670(a1, v5);
    sub_100157B0(v2, *(_DWORD **)(a1 + 12), a1);
    *(_BYTE *)(a1 + 49) = v1;
    sub_100162E0(a1);
  }
  return v2;
}

//----- (10016390) --------------------------------------------------------
int __cdecl sub_10016390(int a1, void (__cdecl *a2)(int, int), int a3, int a4, int a5)
{
  int v6; // edx
  int v7; // ebx
  int v8; // esi
  int v9; // ebx
  int v10; // ebp
  _DWORD *v11; // esi
  _DWORD *v12; // eax
  __int16 v14; // [esp+10h] [ebp-8h]
  int v15; // [esp+14h] [ebp-4h]
  char v16; // [esp+1Ch] [ebp+4h]

  v6 = *(_DWORD *)(a1 + 40);
  v7 = *(_DWORD *)(a1 + 20);
  v8 = *(_DWORD *)(a1 + 92);
  v14 = *(_WORD *)(a1 + 46);
  v16 = *(_BYTE *)(a1 + 49);
  v9 = v7 - v6;
  v15 = v8;
  *(_DWORD *)(a1 + 92) = a5;
  v10 = sub_10015880(a1, a2, a3);
  if ( v10 )
  {
    v11 = (_DWORD *)(a4 + *(_DWORD *)(a1 + 28));
    sub_10019670(a1, (unsigned int)v11);
    sub_100157B0(v10, v11, a1);
    v12 = (_DWORD *)(v9 + *(_DWORD *)(a1 + 40));
    *(_WORD *)(a1 + 46) = v14;
    *(_DWORD *)(a1 + 20) = v12;
    *(_DWORD *)(a1 + 12) = *v12;
    *(_BYTE *)(a1 + 49) = v16;
    sub_100162E0(a1);
    *(_DWORD *)(a1 + 92) = v15;
    return v10;
  }
  else
  {
    *(_DWORD *)(a1 + 92) = v8;
    return 0;
  }
}

//----- (10016440) --------------------------------------------------------
int __usercall sub_10016440@<eax>(int result@<eax>, _DWORD *a2@<edx>)
{
  unsigned int v2; // ecx

  *(_BYTE *)(result + 5) |= 1u;
  v2 = *(unsigned __int8 *)(result + 4) - 5;
  while ( 2 )
  {
    switch ( v2 )
    {
      case 0u:
        *(_DWORD *)(result + 24) = *a2;
        *a2 = result;
        break;
      case 1u:
        *(_DWORD *)(result + 8) = *a2;
        *a2 = result;
        break;
      case 2u:
        result = *(_DWORD *)(result + 8);
        if ( (*(_BYTE *)(result + 5) & 0x11) == 0 )
        {
          *(_BYTE *)(result + 5) |= 1u;
          v2 = *(unsigned __int8 *)(result + 4) - 5;
          if ( v2 <= 4 )
            continue;
        }
        break;
      case 3u:
        *(_DWORD *)(result + 84) = *a2;
        *a2 = result;
        break;
      case 4u:
        *(_DWORD *)(result + 64) = *a2;
        *a2 = result;
        break;
      default:
        return result;
    }
    break;
  }
  return result;
}

//----- (100164B0) --------------------------------------------------------
int __cdecl sub_100164B0(int a1)
{
  int v1; // edi
  int v2; // esi
  int *v3; // edi
  char v4; // al
  int v5; // eax
  int result; // eax

  v1 = *(_DWORD *)(a1 + 16);
  v2 = *(_DWORD *)(v1 + 16);
  v3 = (int *)(v1 + 16);
  if ( v2 )
  {
    do
    {
      v4 = *(_BYTE *)(v2 + 5);
      if ( (v4 & 0x11) == 0 && (v4 & 2) != 0 )
      {
        v5 = *(_DWORD *)(v2 + 8);
        if ( (*(_BYTE *)(v5 + 6) & 4) == 0 && sub_10016EB0(v5, 2, *(_DWORD *)(*(_DWORD *)(a1 + 16) + 136)) )
        {
          *v3 = *(_DWORD *)v2;
          *(_DWORD *)v2 = 0;
          goto LABEL_8;
        }
        *(_BYTE *)(v2 + 5) &= ~2u;
      }
      v3 = (int *)v2;
LABEL_8:
      v2 = *v3;
    }
    while ( *v3 );
  }
  result = *(_DWORD *)(a1 + 16);
  *(_DWORD *)(result + 20) = *(_DWORD *)(result + 20);
  return result;
}

//----- (10016540) --------------------------------------------------------
int __usercall sub_10016540@<eax>(int a1@<edi>, _DWORD *a2)
{
  int v2; // eax
  BOOL v3; // ebx
  int v4; // eax
  _DWORD *v5; // eax
  _DWORD *v6; // esi
  _DWORD *v7; // eax
  int v8; // eax
  int v9; // esi
  int v10; // ebp
  int v11; // eax
  int v12; // ecx
  int v13; // eax
  int v14; // eax
  char v15; // cl
  int result; // eax
  int v17; // ebp
  int v18; // esi
  int *v19; // esi
  BOOL v20; // [esp+Ch] [ebp-8h]
  int v21; // [esp+10h] [ebp-4h]

  v2 = *(_DWORD *)(a1 + 8);
  v3 = 0;
  v20 = 0;
  if ( (*(_BYTE *)(v2 + 5) & 0x11) == 0 )
    sub_10016440(v2, a2);
  v4 = *(_DWORD *)(a1 + 8);
  if ( (*(_BYTE *)(v4 + 6) & 8) != 0 )
    goto LABEL_34;
  v5 = sub_10016EB0(v4, 3, *(_DWORD *)(a2[4] + 140));
  v6 = v5;
  if ( !v5 )
    goto LABEL_34;
  if ( *v5 != 4 )
    goto LABEL_34;
  v20 = strchr((const char *)(v5[2] + 16), 107) != 0;
  v3 = strchr((const char *)(v6[2] + 16), 118) != 0;
  if ( !v20 && !v3 )
    goto LABEL_34;
  *(_BYTE *)(a1 + 5) = *(_BYTE *)(a1 + 5) & 0xF9 | (2 * (v20 | (2 * v3)));
  if ( v20 )
    v7 = v3 ? a2 + 3 : a2 + 1;
  else
    v7 = a2 + 2;
  *(_DWORD *)(a1 + 24) = *v7;
  *v7 = a1;
  if ( !v3 )
  {
LABEL_34:
    v8 = *(_DWORD *)(a1 + 28);
    if ( v8 )
    {
      v9 = 16 * v8;
      v10 = *(_DWORD *)(a1 + 28);
      do
      {
        v11 = *(_DWORD *)(a1 + 12);
        v9 -= 16;
        v12 = *(_DWORD *)(v11 + v9);
        v13 = v9 + v11;
        if ( v12 >= 4 )
        {
          v14 = *(_DWORD *)(v13 + 8);
          if ( (*(_BYTE *)(v14 + 5) & 0x11) == 0 )
            sub_10016440(v14, a2);
        }
        --v10;
      }
      while ( v10 );
    }
  }
  v15 = *(_BYTE *)(a1 + 7);
  result = 1 << v15;
  if ( 1 << v15 )
  {
    v17 = 40 * result;
    v21 = 1 << v15;
    do
    {
      v18 = *(_DWORD *)(a1 + 16);
      v17 -= 40;
      result = *(_DWORD *)(v18 + v17 + 16);
      v19 = (int *)(v17 + v18);
      if ( result )
      {
        if ( *v19 >= 4 )
        {
          result = v19[2];
          if ( (*(_BYTE *)(result + 5) & 0x11) == 0 && !v20 )
            result = sub_10016440(result, a2);
        }
        if ( v19[4] >= 4 )
        {
          result = v19[6];
          if ( (*(_BYTE *)(result + 5) & 0x11) == 0 && !v3 )
            result = sub_10016440(result, a2);
        }
      }
      --v21;
    }
    while ( v21 );
  }
  return result;
}

//----- (100166B0) --------------------------------------------------------
int __usercall sub_100166B0@<eax>(_DWORD *a1@<edx>, _DWORD *a2@<esi>)
{
  int v2; // edi
  int v3; // ecx
  int v4; // eax
  int i; // eax
  int v6; // ecx
  int j; // edi
  int v8; // eax
  int result; // eax
  int v10; // ecx
  int v11; // edx

  *(_BYTE *)(a2[8] + 5) |= 1u;
  v2 = 0;
  if ( (int)a2[10] > 0 )
  {
    v3 = 0;
    do
    {
      v4 = a2[2];
      if ( *(_DWORD *)(v3 + v4) == 4 )
        *(_BYTE *)(*(_DWORD *)(v3 + v4 + 8) + 5) |= 1u;
      ++v2;
      v3 += 16;
    }
    while ( v2 < a2[10] );
  }
  for ( i = 0; i < a2[9]; ++i )
  {
    v6 = *(_DWORD *)(a2[7] + 4 * i);
    *(_BYTE *)(v6 + 5) |= 1u;
  }
  for ( j = 0; j < a2[13]; ++j )
  {
    v8 = *(_DWORD *)(a2[4] + 4 * j);
    if ( (*(_BYTE *)(v8 + 5) & 0x11) == 0 )
      sub_10016440(v8, a1);
  }
  result = a2[14];
  v10 = 0;
  if ( result > 0 )
  {
    v11 = 0;
    do
    {
      *(_BYTE *)(*(_DWORD *)(v11 + a2[6]) + 5) |= 1u;
      result = a2[14];
      ++v10;
      v11 += 12;
    }
    while ( v10 < result );
  }
  return result;
}
// 1001671C: variable 'a1' is possibly undefined

//----- (10016750) --------------------------------------------------------
char __usercall sub_10016750@<al>(_DWORD *a1@<edx>, int a2@<edi>)
{
  int v2; // eax
  int v3; // ebp
  int *v4; // esi
  int v5; // eax
  int v6; // eax
  int v7; // ebx
  int *v8; // ebp
  int v9; // esi

  if ( *(_BYTE *)(a2 + 6) )
  {
    LOBYTE(v2) = *(_BYTE *)(a2 + 7);
    v3 = 0;
    if ( (_BYTE)v2 )
    {
      v4 = (int *)(a2 + 24);
      do
      {
        if ( *(v4 - 2) >= 4 && (*(_BYTE *)(*v4 + 5) & 0x11) == 0 )
          sub_10016440(*v4, a1);
        v2 = *(unsigned __int8 *)(a2 + 7);
        ++v3;
        v4 += 4;
      }
      while ( v3 < v2 );
    }
  }
  else
  {
    v5 = *(_DWORD *)(a2 + 24);
    if ( (*(_BYTE *)(v5 + 5) & 0x11) == 0 )
      sub_10016440(v5, a1);
    v6 = *(_DWORD *)(a2 + 12);
    if ( (*(_BYTE *)(v6 + 5) & 0x11) == 0 )
      sub_10016440(v6, a1);
    LOBYTE(v2) = *(_BYTE *)(a2 + 7);
    v7 = 0;
    if ( (_BYTE)v2 )
    {
      v8 = (int *)(a2 + 32);
      do
      {
        v9 = *v8;
        LOBYTE(v2) = *(_BYTE *)(*v8 + 5);
        if ( !(_BYTE)v2 )
        {
          if ( *(int *)(v9 + 16) >= 4 )
          {
            v2 = *(_DWORD *)(v9 + 24);
            if ( (*(_BYTE *)(v2 + 5) & 0x11) == 0 )
              LOBYTE(v2) = sub_10016440(v2, a1);
          }
          *(_BYTE *)(v9 + 5) = 1;
        }
        ++v7;
        ++v8;
      }
      while ( v7 < *(unsigned __int8 *)(a2 + 7) );
    }
  }
  return v2;
}
// 10016773: variable 'a1' is possibly undefined

//----- (100167F0) --------------------------------------------------------
int __usercall sub_100167F0@<eax>(int a1@<edi>, _DWORD *a2)
{
  int v2; // eax
  unsigned int v3; // eax
  unsigned int v4; // esi
  unsigned int i; // ebp
  int *v6; // esi
  _DWORD *v7; // edx
  int v8; // eax
  unsigned __int16 v9; // bx
  int result; // eax

  if ( *(int *)(a1 + 64) >= 4 )
  {
    v2 = *(_DWORD *)(a1 + 72);
    if ( (*(_BYTE *)(v2 + 5) & 0x11) == 0 )
      sub_10016440(v2, a2);
  }
  v3 = *(_DWORD *)(a1 + 40);
  v4 = *(_DWORD *)(a1 + 20);
  for ( i = *(_DWORD *)(a1 + 8); v3 <= v4; v3 += 24 )
  {
    if ( (*(_BYTE *)(v3 + 8) & 1) == 0 && i < *(_DWORD *)(v3 + 4) )
      i = *(_DWORD *)(v3 + 4);
  }
  v6 = *(int **)(a1 + 28);
  if ( (unsigned int)v6 < *(_DWORD *)(a1 + 8) )
  {
    v7 = a2;
    do
    {
      if ( *v6 >= 4 )
      {
        v8 = v6[2];
        if ( (*(_BYTE *)(v8 + 5) & 0x11) == 0 )
          sub_10016440(v8, v7);
      }
      v6 += 4;
    }
    while ( (unsigned int)v6 < *(_DWORD *)(a1 + 8) );
  }
  for ( ; (unsigned int)v6 <= i; v6 += 4 )
    *v6 = 0;
  v9 = *(_WORD *)(a1 + 44);
  if ( 4 * ((*(_DWORD *)(a1 + 20) - *(_DWORD *)(a1 + 40)) / 24) < v9 && v9 > 0x10u )
    sub_100159B0(a1, v9 >> 1);
  result = *(_DWORD *)(a1 + 32);
  if ( 4 * ((int)(i - *(_DWORD *)(a1 + 28)) >> 4) < result && result > 90 )
    return (int)sub_10015960((_DWORD *)a1, result / 2);
  return result;
}
// 1001684E: variable 'v7' is possibly undefined

//----- (100168E0) --------------------------------------------------------
char __usercall sub_100168E0@<al>(_DWORD *a1@<ebx>)
{
  _DWORD *v1; // edi
  char result; // al
  _DWORD *v3; // esi

  while ( *a1 )
  {
    v1 = (_DWORD *)*a1;
    result = *(_BYTE *)(*a1 + 4) - 5;
    switch ( *(_BYTE *)(*a1 + 4) )
    {
      case 5:
        *a1 = v1[6];
        result = sub_10016540((int)v1, a1);
        break;
      case 6:
        *a1 = v1[2];
        result = sub_10016750(a1, (int)v1);
        break;
      case 8:
        *a1 = v1[21];
        result = sub_100167F0((int)v1, a1);
        break;
      case 9:
        v3 = (_DWORD *)*a1;
        *a1 = v1[16];
        result = sub_100166B0(a1, v3);
        break;
      default:
        break;
    }
  }
  return result;
}

//----- (10016960) --------------------------------------------------------
int __usercall sub_10016960@<eax>(int result@<eax>)
{
  int i; // esi
  char v2; // cl
  int v3; // edx
  int v4; // edi
  int v5; // eax
  int v6; // ecx
  bool v7; // cc

  for ( i = result; i; i = *(_DWORD *)(i + 24) )
  {
    v2 = *(_BYTE *)(i + 7);
    result = 1 << v2;
    if ( 1 << v2 )
    {
      v3 = 40 * result;
      v4 = 1 << v2;
      do
      {
        v5 = *(_DWORD *)(i + 16);
        v3 -= 40;
        v6 = *(_DWORD *)(v5 + v3);
        result = v3 + v5;
        v7 = v6 < 4;
        if ( v6 == 4 )
        {
          *(_BYTE *)(*(_DWORD *)(result + 8) + 5) |= 1u;
          v7 = *(_DWORD *)result < 4;
        }
        if ( !v7 && (*(_BYTE *)(*(_DWORD *)(result + 8) + 5) & 1) == 0 )
        {
          *(_DWORD *)(result + 16) = 0;
          *(_DWORD *)result = -1;
        }
        --v4;
      }
      while ( v4 );
    }
  }
  return result;
}

//----- (100169C0) --------------------------------------------------------
int __usercall sub_100169C0@<eax>(int result@<eax>)
{
  int i; // esi
  int v2; // eax
  int v3; // ecx
  int v4; // edi
  int v5; // eax
  int v6; // edx
  _DWORD *v7; // eax
  bool v8; // cc
  char v9; // cl
  int v10; // edx
  int v11; // edi
  int v12; // eax
  int v13; // ecx
  bool v14; // cc

  for ( i = result; i; i = *(_DWORD *)(i + 24) )
  {
    v2 = *(_DWORD *)(i + 28);
    if ( v2 )
    {
      v3 = 16 * v2;
      v4 = *(_DWORD *)(i + 28);
      do
      {
        v5 = *(_DWORD *)(i + 12);
        v3 -= 16;
        v6 = *(_DWORD *)(v5 + v3);
        v7 = (_DWORD *)(v3 + v5);
        v8 = v6 < 4;
        if ( v6 == 4 )
        {
          *(_BYTE *)(v7[2] + 5) |= 1u;
          v8 = *v7 < 4;
        }
        if ( !v8 && (*(_BYTE *)(v7[2] + 5) & 1) == 0 )
          *v7 = 0;
        --v4;
      }
      while ( v4 );
    }
    v9 = *(_BYTE *)(i + 7);
    result = 1 << v9;
    if ( 1 << v9 )
    {
      v10 = 40 * result;
      v11 = 1 << v9;
      do
      {
        v12 = *(_DWORD *)(i + 16);
        v10 -= 40;
        v13 = *(_DWORD *)(v12 + v10 + 16);
        result = v10 + v12;
        v14 = v13 < 4;
        if ( v13 == 4 )
        {
          *(_BYTE *)(*(_DWORD *)(result + 24) + 5) |= 1u;
          v14 = *(_DWORD *)(result + 16) < 4;
        }
        if ( !v14 && (*(_BYTE *)(*(_DWORD *)(result + 24) + 5) & 1) == 0 )
        {
          v8 = *(_DWORD *)result < 4;
          *(_DWORD *)(result + 16) = 0;
          if ( !v8 )
            *(_DWORD *)result = -1;
        }
        --v11;
      }
      while ( v11 );
    }
  }
  return result;
}

//----- (10016A70) --------------------------------------------------------
_BYTE *__usercall sub_10016A70@<eax>(_BYTE *result@<eax>, _DWORD *a2@<ecx>)
{
  switch ( result[4] )
  {
    case 4:
      result = sub_1001B810(a2, result, *((_DWORD *)result + 3) + 17, 0);
      break;
    case 5:
      result = sub_10019C70(a2, (int)result);
      break;
    case 6:
      result = sub_100197C0(a2, result);
      break;
    case 7:
      result = sub_1001B810(a2, result, *((_DWORD *)result + 3) + 16, 0);
      break;
    case 8:
      result = sub_10014B00(a2, (int)result);
      break;
    case 9:
      result = sub_10019720(a2, (int)result);
      break;
    case 0xA:
      result = sub_1001B810(a2, result, 32, 0);
      break;
    default:
      return result;
  }
  return result;
}

//----- (10016B10) --------------------------------------------------------
int __usercall sub_10016B10@<eax>(_BYTE **a1@<eax>, _DWORD *a2@<ebx>, int a3)
{
  _DWORD *v3; // esi
  _BYTE *v4; // eax
  int v5; // edi
  unsigned __int8 v6; // cl

  v3 = a1;
  v4 = *a1;
  v5 = 0;
  if ( v4 )
  {
    do
    {
      v6 = v4[5];
      if ( v6 <= a3 )
      {
        *v3 = *(_DWORD *)v4;
        ++v5;
        sub_10016A70(v4, a2);
      }
      else
      {
        v4[5] = v6 & 0xFE;
        v3 = v4;
      }
      v4 = (_BYTE *)*v3;
    }
    while ( *v3 );
  }
  return v5;
}

//----- (10016B50) --------------------------------------------------------
int __usercall sub_10016B50@<eax>(_DWORD *a1@<eax>, int a2@<edi>)
{
  int result; // eax
  int v4; // esi

  result = a1[4];
  v4 = 0;
  if ( *(int *)(result + 8) > 0 )
  {
    do
    {
      *(_DWORD *)(a1[4] + 4) -= sub_10016B10((_BYTE **)(*(_DWORD *)a1[4] + 4 * v4), a1, a2);
      result = *(_DWORD *)(a1[4] + 8);
      ++v4;
    }
    while ( v4 < result );
  }
  return result;
}

//----- (10016B90) --------------------------------------------------------
int __usercall sub_10016B90@<eax>(_DWORD *a1@<eax>)
{
  int v2; // ecx
  int v3; // eax
  int v4; // ecx
  unsigned int v5; // ecx
  unsigned int v6; // edi
  int v7; // esi
  int result; // eax

  v2 = a1[4];
  if ( *(_DWORD *)(v2 + 4) < *(_DWORD *)(v2 + 8) / 4 )
  {
    v3 = *(_DWORD *)(v2 + 8);
    if ( v3 > 64 )
      sub_10019370(a1, v3 / 2);
  }
  v4 = a1[4];
  if ( *(_DWORD *)(v4 + 28) > 0x40u )
  {
    v5 = *(_DWORD *)(v4 + 28);
    v6 = v5 >> 1;
    *(_DWORD *)(a1[4] + 24) = sub_1001B810(a1, *(void **)(a1[4] + 24), v5, v5 >> 1);
    *(_DWORD *)(a1[4] + 28) = v6;
  }
  v7 = a1[4];
  result = 2 * *(_DWORD *)(v7 + 36);
  *(_DWORD *)(v7 + 32) = result;
  return result;
}

//----- (10016C00) --------------------------------------------------------
char __cdecl sub_10016C00(int a1)
{
  int v2; // eax
  int v3; // ecx
  int v4; // edi
  int v5; // eax
  int v6; // edi
  _DWORD *v7; // eax
  int v8; // eax
  _DWORD *v9; // eax
  _DWORD *v10; // ecx
  _DWORD *v11; // eax
  int v12; // eax
  char v14; // [esp+Ch] [ebp+4h]

  LOBYTE(v2) = *(_BYTE *)(a1 + 49);
  v3 = *(_DWORD *)(a1 + 16);
  v4 = *(_DWORD *)(a1 + 8) + 16;
  *(_BYTE *)(a1 + 49) = 0;
  *(_DWORD *)(a1 + 8) = v4;
  v14 = v2;
  if ( *(_DWORD *)(v3 + 20) )
  {
    do
    {
      v5 = *(_DWORD *)(a1 + 16);
      v6 = *(_DWORD *)(v5 + 20);
      *(_DWORD *)(v5 + 20) = *(_DWORD *)v6;
      *(_DWORD *)v6 = *(_DWORD *)(*(_DWORD *)(a1 + 16) + 16);
      *(_DWORD *)(*(_DWORD *)(a1 + 16) + 16) = v6;
      v7 = (_DWORD *)(*(_DWORD *)(a1 + 8) - 16);
      *v7 = 7;
      v7[2] = v6;
      v8 = *(_DWORD *)(v6 + 8);
      *(_BYTE *)(v6 + 5) &= 0xFCu;
      if ( (*(_BYTE *)(v8 + 6) & 4) == 0 )
      {
        v9 = sub_10016EB0(v8, 2, *(_DWORD *)(*(_DWORD *)(a1 + 16) + 136));
        if ( v9 )
        {
          v10 = *(_DWORD **)(a1 + 8);
          *v10 = *v9;
          v10[2] = v9[2];
          v10[3] = v9[3];
          v11 = (_DWORD *)(*(_DWORD *)(a1 + 8) + 16);
          *v11 = 7;
          v11[2] = v6;
          v12 = *(_DWORD *)(a1 + 8) + 32;
          *(_DWORD *)(a1 + 8) = v12;
          sub_10015FC0(a1, (char *)(v12 - 32), 0);
        }
      }
    }
    while ( *(_DWORD *)(*(_DWORD *)(a1 + 16) + 20) );
    v2 = *(_DWORD *)(a1 + 8) - 16;
    *(_DWORD *)(a1 + 8) = v2;
    *(_BYTE *)(a1 + 49) = v14;
  }
  else
  {
    *(_DWORD *)(a1 + 8) -= 16;
    *(_BYTE *)(a1 + 49) = v2;
  }
  return v2;
}

//----- (10016CF0) --------------------------------------------------------
int __usercall sub_10016CF0@<eax>(int a1@<esi>, _DWORD *a2)
{
  int v2; // eax
  int v3; // ebx
  int v4; // eax
  int v5; // eax
  int v6; // eax
  int result; // eax

  v2 = *(_DWORD *)(a1 + 16);
  v3 = a2[4];
  if ( *(int *)(v2 + 64) >= 4 )
  {
    v4 = *(_DWORD *)(v2 + 72);
    if ( (*(_BYTE *)(v4 + 5) & 0x11) == 0 )
      sub_10016440(v4, a2);
  }
  v5 = *(_DWORD *)(a1 + 16);
  if ( *(int *)(v5 + 48) >= 4 )
  {
    v6 = *(_DWORD *)(v5 + 56);
    if ( (*(_BYTE *)(v6 + 5) & 0x11) == 0 )
      sub_10016440(v6, a2);
  }
  sub_100167F0(*(_DWORD *)(v3 + 80), a2);
  result = *(_DWORD *)(v3 + 80);
  if ( a1 != result && (*(_BYTE *)(a1 + 5) & 0x11) == 0 )
    return sub_10016440(a1, a2);
  return result;
}

//----- (10016D60) --------------------------------------------------------
int __usercall sub_10016D60@<eax>(int a1@<eax>)
{
  int v2; // ebp
  int i; // esi
  int v5; // [esp+10h] [ebp-14h] BYREF
  int v6; // [esp+14h] [ebp-10h]
  int v7; // [esp+18h] [ebp-Ch]
  int v8; // [esp+1Ch] [ebp-8h]
  int v9; // [esp+20h] [ebp-4h]

  v9 = *(_DWORD *)(a1 + 16);
  v5 = 0;
  v7 = 0;
  v6 = 0;
  v8 = 0;
  sub_10016CF0(a1, &v5);
  sub_100168E0(&v5);
  sub_100169C0(v8);
  sub_100169C0(v7);
  v2 = v8;
  v8 = 0;
  v7 = 0;
  sub_100164B0(a1);
  for ( i = *(_DWORD *)(v9 + 20); i; i = *(_DWORD *)i )
  {
    *(_BYTE *)(i + 5) &= ~1u;
    sub_10016440(i, &v5);
  }
  sub_100168E0(&v5);
  sub_10016960(v2);
  sub_10016960(v6);
  sub_100169C0(v7);
  sub_10016960(v8);
  return sub_100169C0(v8);
}

//----- (10016E30) --------------------------------------------------------
char __cdecl sub_10016E30(_DWORD *a1)
{
  sub_10016D60((int)a1);
  sub_10016B10((_BYTE **)(a1[4] + 16), a1, 0);
  sub_10016B50(a1, 0);
  sub_10016B10((_BYTE **)(a1[4] + 12), a1, 0);
  sub_10016B90(a1);
  return sub_10016C00((int)a1);
}

//----- (10016E80) --------------------------------------------------------
int __cdecl sub_10016E80(int a1, int a2, char a3)
{
  int result; // eax

  result = a2;
  *(_DWORD *)a2 = *(_DWORD *)(*(_DWORD *)(a1 + 16) + 12);
  *(_DWORD *)(*(_DWORD *)(a1 + 16) + 12) = a2;
  *(_BYTE *)(a2 + 5) = 0;
  *(_BYTE *)(a2 + 4) = a3;
  return result;
}

//----- (10016EB0) --------------------------------------------------------
_DWORD *__cdecl sub_10016EB0(int a1, char a2, int a3)
{
  _DWORD *result; // eax

  result = sub_10019DB0(a1, a3);
  if ( !*result )
  {
    *(_BYTE *)(a1 + 6) |= 1 << a2;
    return 0;
  }
  return result;
}

//----- (10016EE0) --------------------------------------------------------
_DWORD *__cdecl sub_10016EE0(int a1, _DWORD *a2, int a3)
{
  if ( *a2 == 5 || *a2 == 7 )
    return sub_10019DB0(*(_DWORD *)(a2[2] + 8), *(_DWORD *)(*(_DWORD *)(a1 + 16) + 4 * a3 + 128));
  else
    return &unk_1003F368;
}

//----- (10016F30) --------------------------------------------------------
_DWORD *__cdecl sub_10016F30(_DWORD *a1, int a2)
{
  _DWORD *result; // eax
  int v3[2]; // [esp+0h] [ebp-8h] BYREF

  result = a1;
  if ( *a1 != 3 )
  {
    if ( *a1 == 4 && sub_10018E70((char *)(a1[2] + 16), (double *)v3) )
    {
      result = (_DWORD *)a2;
      *(double *)(a2 + 8) = *(double *)v3;
      *(_DWORD *)a2 = 3;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

//----- (10016F80) --------------------------------------------------------
int __cdecl sub_10016F80(int a1, int a2)
{
  char Buffer[32]; // [esp+Ch] [ebp-20h] BYREF

  if ( *(_DWORD *)a2 != 3 )
    return 0;
  sprintf(Buffer, "%.14g", *(double *)(a2 + 8));
  *(_DWORD *)a2 = 4;
  *(_DWORD *)(a2 + 8) = sub_100194B0(a1, Buffer, strlen(Buffer));
  return 1;
}

//----- (10016FF0) --------------------------------------------------------
char __usercall sub_10016FF0@<al>(int a1@<edi>)
{
  int v1; // eax
  int v2; // edx
  int v3; // ecx
  int v4; // ebx
  unsigned int *v5; // esi
  unsigned int v6; // ecx
  int v7; // esi
  int v8; // ecx

  LOBYTE(v1) = *(_BYTE *)(a1 + 48);
  if ( (unsigned __int8)v1 <= 4u || *(_DWORD *)(a1 + 56) )
  {
    if ( (v1 & 4) != 0 )
    {
      v1 = *(_DWORD *)(a1 + 20);
      v2 = *(_DWORD *)(*(_DWORD *)(*(_DWORD *)v1 - 8) + 12);
      v3 = *(_DWORD *)(v2 + 20);
      if ( v3 )
        v4 = *(_DWORD *)(v3 + 4 * ((**(_DWORD **)(v1 + 16) - *(_DWORD *)(v2 + 12)) >> 2) - 4);
      else
        v4 = 0;
      if ( *(_BYTE *)(a1 + 50) )
      {
        v5 = *(unsigned int **)(v1 + 16);
        if ( (int)(*v5 - *(_DWORD *)(v2 + 12)) >> 2 == 1 )
          *(_DWORD *)(v1 + 12) = *v5;
        v6 = *(_DWORD *)(v1 + 12);
        if ( *v5 <= v6
          || ((v7 = *(_DWORD *)(v2 + 20)) == 0
            ? (v8 = 0)
            : (v8 = *(_DWORD *)(v7 + 4 * ((int)(v6 - *(_DWORD *)(v2 + 12)) >> 2) - 4)),
              v4 != v8) )
        {
          sub_10015AA0(a1, 2, v4);
          v1 = *(_DWORD *)(a1 + 20);
        }
        *(_DWORD *)(v1 + 12) = **(_DWORD **)(v1 + 16);
      }
      else
      {
        LOBYTE(v1) = sub_1001ABA0(a1);
      }
    }
  }
  else
  {
    *(_DWORD *)(a1 + 56) = *(_DWORD *)(a1 + 52);
    LOBYTE(v1) = sub_10015AA0(a1, 3, -1);
  }
  return v1;
}

//----- (100170B0) --------------------------------------------------------
int __usercall sub_100170B0@<eax>(int *a1@<eax>, _DWORD *a2@<edx>, _DWORD *a3@<ecx>, _DWORD *a4@<esi>)
{
  int v5; // ebx
  _DWORD *v6; // eax
  _DWORD *v7; // eax
  _DWORD *v8; // eax
  int v9; // eax
  int result; // eax

  v5 = *a1;
  v6 = (_DWORD *)a4[2];
  *v6 = v5;
  v6[2] = a1[2];
  v6[3] = a1[3];
  v7 = (_DWORD *)a4[2];
  v7[4] = *a2;
  v7[6] = a2[2];
  v7[7] = a2[3];
  v8 = (_DWORD *)(a4[2] + 32);
  *v8 = *a3;
  v8[2] = a3[2];
  v8[3] = a3[3];
  if ( a4[6] - a4[2] <= 48 )
    sub_10015A20(a4, 3);
  v9 = a4[2] + 48;
  a4[2] = v9;
  sub_10015FC0((int)a4, (char *)(v9 - 48), 1);
  result = a4[2] - 16;
  a4[2] = result;
  return result;
}

//----- (10017130) --------------------------------------------------------
char __usercall sub_10017130@<al>(_DWORD *a1@<eax>, _DWORD *a2@<edx>, _DWORD *a3@<ecx>, _DWORD *a4@<esi>, _DWORD *a5)
{
  _DWORD *v6; // eax
  _DWORD *v7; // eax
  _DWORD *v8; // eax
  _DWORD *v9; // eax
  char *v11; // [esp-8h] [ebp-14h]

  v6 = (_DWORD *)a4[2];
  *v6 = *a5;
  v6[2] = a5[2];
  v6[3] = a5[3];
  v7 = (_DWORD *)a4[2];
  v7[4] = *a1;
  v7[6] = a1[2];
  v7[7] = a1[3];
  v8 = (_DWORD *)a4[2];
  v8[8] = *a2;
  v8 += 8;
  v8[2] = a2[2];
  v8[3] = a2[3];
  v9 = (_DWORD *)(a4[2] + 48);
  *v9 = *a3;
  v9[2] = a3[2];
  v9[3] = a3[3];
  if ( a4[6] - a4[2] <= 64 )
    sub_10015A20(a4, 4);
  v11 = (char *)a4[2];
  a4[2] = v11 + 64;
  return sub_10015FC0((int)a4, v11, 0);
}

//----- (100171D0) --------------------------------------------------------
_DWORD *__usercall sub_100171D0@<eax>(_DWORD *a1@<eax>, _DWORD *a2@<ebx>, double *a3, int a4)
{
  int *v5; // edi

  v5 = sub_10016EE0((int)a1, a2, 0);
  if ( !*v5 )
    sub_1001B6D0(a1, (int)a2, (int)"index");
  if ( *v5 != 6 )
    return sub_10017230(a1, v5, a3, a4);
  sub_100170B0(v5, a2, a3, a1);
  return (_DWORD *)a1[2];
}

//----- (10017230) --------------------------------------------------------
_DWORD *__cdecl sub_10017230(_DWORD *a1, _DWORD *a2, double *a3, int a4)
{
  _DWORD *result; // eax
  int v5; // [esp+0h] [ebp-Ch]

  if ( a4 > 100 )
    sub_1001B4B0(a1, "loop in gettable", v5);
  if ( *a2 != 5 )
    return sub_100171D0(a1, a2, a3, a4 + 1);
  result = sub_10019DF0(a2[2], a3);
  if ( !*result )
    return sub_10017BA0(a1, a2, a3, a4 + 1);
  return result;
}
// 10017246: variable 'v5' is possibly undefined

//----- (100172A0) --------------------------------------------------------
char __cdecl sub_100172A0(_DWORD *a1, _DWORD *a2, double *a3, _DWORD *a4)
{
  int v5; // edi
  _DWORD *v6; // ebx
  int v7; // edi
  _DWORD *v8; // edi
  int v9; // eax
  bool v10; // cc
  int v12; // [esp+0h] [ebp-14h]
  int i; // [esp+10h] [ebp-4h]

  for ( i = 0; ; ++i )
  {
    if ( *a2 == 5 )
    {
      v5 = a2[2];
      v6 = sub_10019E50(a1, v5, a3);
      if ( *v6
        || (v7 = *(_DWORD *)(v5 + 8), (*(_BYTE *)(v7 + 6) & 2) != 0)
        || (v8 = sub_10016EB0(v7, 1, *(_DWORD *)(a1[4] + 132))) == 0 )
      {
        *v6 = *a4;
        v6[2] = a4[2];
        v9 = a4[3];
        v6[3] = v9;
        return v9;
      }
    }
    else
    {
      v8 = sub_10016EE0((int)a1, a2, 1);
      if ( !*v8 )
        sub_1001B6D0(a1, (int)a2, (int)"index");
    }
    if ( *v8 == 6 )
      break;
    v10 = i + 1 <= 100;
    a2 = v8;
    if ( !v10 )
      sub_1001B4B0(a1, "loop in settable", v12);
  }
  LOBYTE(v9) = sub_10017130(a2, a3, a4, a1, v8);
  return v9;
}
// 10017355: variable 'v12' is possibly undefined

//----- (10017380) --------------------------------------------------------
int __usercall sub_10017380@<eax>(int a1@<eax>, _DWORD *a2@<ecx>, _DWORD *a3@<edi>, _DWORD *a4, int a5)
{
  int v6; // ebx
  int *v7; // eax
  _DWORD *v9; // ecx
  _DWORD *v10; // eax
  _DWORD *v11; // [esp-4h] [ebp-14h]

  v6 = a1 - a2[7];
  v7 = sub_10016EE0((int)a2, v11, a5);
  if ( !*v7 )
    v7 = sub_10016EE0((int)a2, a4, a5);
  if ( *v7 != 6 )
    return 0;
  sub_100170B0(v7, a3, a4, a2);
  v9 = (_DWORD *)a2[2];
  v10 = (_DWORD *)(v6 + a2[7]);
  *v10 = *v9;
  v10[2] = v9[2];
  v10[3] = v9[3];
  return 1;
}
// 10017393: variable 'v11' is possibly undefined

//----- (100173F0) --------------------------------------------------------
_DWORD *__usercall sub_100173F0@<eax>(int a1@<edi>, int a2@<esi>, int a3, int a4)
{
  _DWORD *v4; // ebp
  _DWORD *v6; // eax

  if ( (*(_BYTE *)(a1 + 6) & (unsigned __int8)(1 << a2)) != 0 )
    return 0;
  v4 = sub_10016EB0(a1, a2, *(_DWORD *)(*(_DWORD *)(a3 + 16) + 4 * a2 + 128));
  if ( !v4 )
    return 0;
  if ( a1 == a4 )
    return v4;
  if ( ((unsigned __int8)(1 << a2) & *(_BYTE *)(a4 + 6)) != 0 )
    return 0;
  v6 = sub_10016EB0(a4, a2, *(_DWORD *)(*(_DWORD *)(a3 + 16) + 4 * a2 + 128));
  if ( !v6 )
    return 0;
  return sub_10018E20((int)v4, (int)v6) ? v4 : 0;
}

//----- (10017470) --------------------------------------------------------
int __usercall sub_10017470@<eax>(_DWORD *a1@<eax>, _DWORD *a2@<ebx>, _DWORD *a3, int a4)
{
  int *v5; // edi
  _DWORD *v6; // eax
  _DWORD *v8; // esi

  v5 = sub_10016EE0((int)a1, a3, a4);
  if ( !*v5 )
    return -1;
  v6 = sub_10016EE0((int)a1, a2, a4);
  if ( !sub_10018E20((int)v5, (int)v6) )
    return -1;
  sub_100170B0(v5, a3, a2, a1);
  v8 = (_DWORD *)a1[2];
  return *v8 && (*v8 != 1 || v8[2]);
}

//----- (100174E0) --------------------------------------------------------
int __usercall sub_100174E0@<eax>(int a1@<eax>, int a2@<ecx>)
{
  int v2; // ebx
  int v3; // ebp
  const char *v4; // edi
  const char *v5; // esi
  int result; // eax
  unsigned int v7; // eax
  unsigned int v8; // eax

  v2 = *(_DWORD *)(a1 + 12);
  v3 = *(_DWORD *)(a2 + 12);
  v4 = (const char *)(a1 + 16);
  v5 = (const char *)(a2 + 16);
  result = strcoll((const char *)(a2 + 16), (const char *)(a1 + 16));
  if ( !result )
  {
    while ( 1 )
    {
      v7 = strlen(v5);
      if ( v7 == v2 )
        return v7 != v3;
      if ( v7 == v3 )
        break;
      v8 = v7 + 1;
      v4 += v8;
      v5 += v8;
      v3 -= v8;
      v2 -= v8;
      result = strcoll(v5, v4);
      if ( result )
        return result;
    }
    return -1;
  }
  return result;
}

//----- (10017550) --------------------------------------------------------
int __cdecl sub_10017550(_DWORD *a1, double *a2, double *a3)
{
  int v3; // eax
  int result; // eax

  v3 = *(_DWORD *)a2;
  if ( *(_DWORD *)a2 != *(_DWORD *)a3 )
    sub_1001B7C0(a1, a2, a3);
  if ( v3 == 3 )
    return a2[1] < a3[1];
  if ( v3 == 4 )
    return sub_100174E0(*((_DWORD *)a3 + 2), *((_DWORD *)a2 + 2)) < 0;
  result = sub_10017470(a1, a3, a2, 11);
  if ( result == -1 )
    sub_1001B7C0(a1, a2, a3);
  return result;
}

//----- (100175E0) --------------------------------------------------------
int __usercall sub_100175E0@<eax>(double *a1@<edi>, double *a2@<esi>, _DWORD *a3)
{
  int v3; // eax
  int result; // eax
  int v5; // eax

  v3 = *(_DWORD *)a1;
  if ( *(_DWORD *)a1 != *(_DWORD *)a2 )
    sub_1001B7C0(a3, a1, a2);
  if ( v3 == 3 )
    return a1[1] <= a2[1];
  if ( v3 == 4 )
    return sub_100174E0(*((_DWORD *)a2 + 2), *((_DWORD *)a1 + 2)) <= 0;
  result = sub_10017470(a3, a2, a1, 12);
  if ( result == -1 )
  {
    v5 = sub_10017470(a3, a1, a2, 11);
    if ( v5 == -1 )
      sub_1001B7C0(a3, a1, a2);
    return v5 == 0;
  }
  return result;
}

//----- (10017680) --------------------------------------------------------
BOOL __cdecl sub_10017680(_DWORD *a1, double *a2, double *a3)
{
  BOOL result; // eax
  int v4; // eax
  int v5; // ecx
  int *v6; // eax
  _DWORD *v7; // ebx

  switch ( *(_DWORD *)a2 )
  {
    case 0:
      goto LABEL_3;
    case 2:
      return *((_DWORD *)a3 + 2) == *((_DWORD *)a2 + 2);
    case 3:
      if ( a2[1] == a3[1] )
        goto LABEL_3;
      goto LABEL_10;
    case 5:
    case 7:
      v4 = *((_DWORD *)a2 + 2);
      v5 = *((_DWORD *)a3 + 2);
      if ( v4 == v5
        || (v6 = sub_100173F0(*(_DWORD *)(v4 + 8), 4, (int)a1, *(_DWORD *)(v5 + 8))) != 0
        && (sub_100170B0(v6, a2, a3, a1), v7 = (_DWORD *)a1[2], *v7)
        && (*v7 != 1 || v7[2]) )
      {
LABEL_3:
        result = 1;
      }
      else
      {
LABEL_10:
        result = 0;
      }
      break;
    default:
      result = *((_DWORD *)a3 + 2) == *((_DWORD *)a2 + 2);
      break;
  }
  return result;
}

//----- (10017760) --------------------------------------------------------
int __cdecl sub_10017760(_DWORD *a1, int a2, int a3)
{
  _DWORD *v3; // esi
  int v4; // ebx
  int v5; // eax
  int v6; // edi
  int *v7; // eax
  _DWORD *v8; // ebx
  _DWORD *v9; // eax
  _DWORD *v10; // esi
  int v11; // ecx
  unsigned int v12; // eax
  int v13; // edi
  bool v14; // cc
  int v15; // eax
  unsigned int v16; // edi
  int v17; // edx
  unsigned int v18; // eax
  bool v19; // zf
  _DWORD *v20; // ebx
  int result; // eax
  bool v22; // sf
  int v23; // [esp+8h] [ebp-60h]
  _DWORD *v24; // [esp+14h] [ebp-54h]
  unsigned int v25; // [esp+14h] [ebp-54h]
  int v26; // [esp+14h] [ebp-54h]
  int v27; // [esp+18h] [ebp-50h]
  int v28; // [esp+1Ch] [ebp-4Ch]
  int v29; // [esp+20h] [ebp-48h]
  char *v30; // [esp+20h] [ebp-48h]
  char Buffer[32]; // [esp+28h] [ebp-40h] BYREF
  char v32[32]; // [esp+48h] [ebp-20h] BYREF

  do
  {
    v3 = a1;
    v4 = a1[3] + 16 * (a3 + 1);
    v5 = *(_DWORD *)(v4 - 32);
    v6 = v4 - 32;
    v27 = 2;
    if ( v5 != 4 )
    {
      if ( v5 != 3 )
        goto LABEL_6;
      sprintf(Buffer, "%.14g", *(double *)(v6 + 8));
      *(_DWORD *)v6 = 4;
      *(_DWORD *)(v6 + 8) = sub_100194B0((int)a1, Buffer, strlen(Buffer));
    }
    if ( *(_DWORD *)(v4 - 16) != 4 && !sub_10016F80((int)a1, v4 - 16) )
    {
LABEL_6:
      v24 = (_DWORD *)(v4 - 16);
      v29 = v4 - a1[7] - 32;
      v7 = sub_10016EE0((int)a1, (_DWORD *)v6, 13);
      v8 = (_DWORD *)(v4 - 16);
      if ( !*v7 )
        v7 = sub_10016EE0((int)a1, v24, 13);
      if ( *v7 != 6 )
        sub_1001B760(a1, (_DWORD *)v6, v8);
      sub_100170B0(v7, (_DWORD *)v6, v8, a1);
      v9 = (_DWORD *)a1[2];
      v10 = (_DWORD *)(v29 + a1[7]);
      *v10 = *v9;
      v10[2] = v9[2];
      v10[3] = v9[3];
      goto LABEL_25;
    }
    v11 = *(_DWORD *)(*(_DWORD *)(v4 - 8) + 12);
    if ( v11 )
    {
      v12 = v11 + *(_DWORD *)(*(_DWORD *)(v4 - 24) + 12);
      v25 = v12;
      if ( a2 > 2 )
      {
        v13 = v4 - 48;
        do
        {
          if ( *(_DWORD *)v13 != 4 )
          {
            if ( *(_DWORD *)v13 != 3 )
              break;
            sprintf(v32, "%.14g", *(double *)(v13 + 8));
            *(_DWORD *)v13 = 4;
            *(_DWORD *)(v13 + 8) = sub_100194B0((int)a1, v32, strlen(v32));
            v12 = v25;
          }
          v12 += *(_DWORD *)(*(_DWORD *)(v13 + 8) + 12);
          v13 -= 16;
          v14 = v27 + 1 < a2;
          v25 = v12;
          ++v27;
        }
        while ( v14 );
      }
      if ( v12 > 0xFFFFFFFD )
        sub_1001B4B0(a1, "string size overflow", v23);
      v30 = (char *)sub_1001A580(a1, (void **)(a1[4] + 24), v12);
      v15 = v27;
      v16 = 0;
      v26 = 0;
      if ( v27 > 0 )
      {
        v17 = v4 - 16 * v27 + 8;
        v28 = v27;
        do
        {
          v18 = *(_DWORD *)(*(_DWORD *)v17 + 12);
          qmemcpy(&v30[v16], (const void *)(*(_DWORD *)v17 + 16), v18);
          v16 = v18 + v26;
          v17 += 16;
          v19 = v28 == 1;
          v26 += v18;
          --v28;
        }
        while ( !v19 );
        v3 = a1;
        v15 = v27;
      }
      v20 = (_DWORD *)(v4 - 16 * v15);
      *v20 = 4;
      v20[2] = sub_100194B0((int)v3, v30, v16);
    }
LABEL_25:
    v22 = a2 - v27 < 0;
    a2 += 1 - v27;
    result = a2;
    a3 += 1 - v27;
  }
  while ( !(v22 ^ __OFSUB__(result, 1) | (result == 1)) );
  return result;
}
// 10017909: variable 'v23' is possibly undefined

//----- (100179E0) --------------------------------------------------------
int *__usercall sub_100179E0@<eax>(int *a1@<eax>, _DWORD *a2@<edx>, int a3@<ecx>, _DWORD *a4, int a5)
{
  int v6; // eax
  int *result; // eax
  _DWORD *v10; // ecx
  int *v11; // edi
  int *v12; // eax
  int v13; // ebx
  bool v14; // zf
  int *v15; // ecx
  int v16; // [esp+0h] [ebp-38h]
  int *v17; // [esp+Ch] [ebp-2Ch]
  int v18[2]; // [esp+10h] [ebp-28h] BYREF
  int v19[2]; // [esp+18h] [ebp-20h] BYREF
  double v20; // [esp+20h] [ebp-18h]
  int v21; // [esp+28h] [ebp-10h] BYREF
  double v22; // [esp+30h] [ebp-8h]

  v6 = *a1;
  if ( v6 == 3 )
  {
    result = a1;
    v17 = a1;
  }
  else
  {
    if ( v6 != 4 || !sub_10018E70((char *)(a1[2] + 16), (double *)v18) )
    {
LABEL_19:
      v10 = a4;
      goto LABEL_20;
    }
    v20 = *(double *)v18;
    v19[0] = 3;
    v17 = v19;
    result = v19;
  }
  v10 = a4;
  if ( *a4 == 3 )
  {
    v11 = a4;
    goto LABEL_11;
  }
  if ( *a4 == 4 )
  {
    if ( sub_10018E70((char *)(a4[2] + 16), (double *)v18) )
    {
      result = v17;
      v22 = *(double *)v18;
      v21 = 3;
      v11 = &v21;
LABEL_11:
      switch ( a5 )
      {
        case 5:
          *(_DWORD *)a3 = 3;
          *(double *)(a3 + 8) = *((double *)v11 + 1) + *((double *)result + 1);
          break;
        case 6:
          *(_DWORD *)a3 = 3;
          *(double *)(a3 + 8) = *((double *)result + 1) - *((double *)v11 + 1);
          break;
        case 7:
          *(_DWORD *)a3 = 3;
          *(double *)(a3 + 8) = *((double *)v11 + 1) * *((double *)result + 1);
          break;
        case 8:
          *(_DWORD *)a3 = 3;
          *(double *)(a3 + 8) = *((double *)result + 1) / *((double *)v11 + 1);
          break;
        case 9:
          v12 = sub_10019DB0(a2[18], *(_DWORD *)(a2[4] + 164));
          v13 = a3 - a2[7];
          v14 = *v12 == 6;
          v18[0] = (int)v12;
          if ( !v14 )
            sub_1001B4B0(a2, "`__pow' (`^' operator) is not a function", v16);
          sub_100170B0(v12, v17, v11, a2);
          v15 = (int *)a2[2];
          result = (int *)(v13 + a2[7]);
          *result = *v15;
          result[2] = v15[2];
          result[3] = v15[3];
          break;
        default:
          return result;
      }
      return result;
    }
    goto LABEL_19;
  }
LABEL_20:
  result = (int *)sub_10017380(a3, a2, a1, v10, a5);
  if ( !result )
    sub_1001B780(a2, a1, (int)a4);
  return result;
}
// 10017B25: variable 'v16' is possibly undefined

//----- (10017BA0) --------------------------------------------------------
_DWORD *__cdecl sub_10017BA0(_DWORD *a1, _DWORD *a2, double *a3, int a4)
{
  int v4; // eax
  int *v5; // eax

  v4 = *(_DWORD *)(a2[2] + 8);
  if ( (*(_BYTE *)(v4 + 6) & 1) != 0 )
    return &unk_1003F368;
  v5 = sub_10016EB0(v4, 0, *(_DWORD *)(a1[4] + 128));
  if ( !v5 )
    return &unk_1003F368;
  if ( *v5 != 6 )
    return sub_10017230(a1, v5, a3, a4);
  sub_100170B0(v5, a2, a3, a1);
  return (_DWORD *)a1[2];
}

//----- (10017C10) --------------------------------------------------------
double *__cdecl sub_10017C10(int a1)
{
  int v1; // ebx
  int v2; // edx
  unsigned int v3; // esi
  char v4; // al
  bool v5; // zf
  double *v6; // eax
  double *v7; // edi
  int v8; // eax
  double *v9; // eax
  int v10; // esi
  double *v11; // esi
  double *v12; // esi
  _DWORD *v13; // eax
  double *v14; // esi
  _DWORD *v15; // eax
  int v16; // eax
  int *v17; // eax
  int *v18; // edi
  _DWORD *v19; // ecx
  int v20; // eax
  _DWORD *v21; // eax
  char *v22; // eax
  double *v23; // ecx
  double *v24; // eax
  int v25; // esi
  _DWORD *v26; // eax
  int v27; // eax
  int v28; // eax
  _DWORD *v29; // eax
  unsigned int v30; // eax
  double *v31; // ecx
  int v32; // esi
  double *v33; // eax
  double *v34; // ecx
  double *v35; // ecx
  double *v36; // eax
  int v37; // esi
  _DWORD *v38; // eax
  _DWORD *v39; // eax
  _DWORD *v40; // ecx
  unsigned int v41; // eax
  double *v42; // ecx
  int v43; // esi
  double *v44; // eax
  double *v45; // ecx
  unsigned int v46; // eax
  double *v47; // ecx
  int v48; // esi
  double *v49; // eax
  double *v50; // ecx
  unsigned int v51; // eax
  double *v52; // ecx
  int v53; // esi
  double *v54; // eax
  double *v55; // ecx
  unsigned int v56; // eax
  double *v57; // ecx
  int v58; // esi
  double *v59; // eax
  double *v60; // ecx
  unsigned int v61; // eax
  double *v62; // ecx
  int v63; // esi
  double *v64; // eax
  double *v65; // ecx
  int v66; // esi
  int v67; // eax
  int *v68; // esi
  int v69; // eax
  char *v70; // edi
  int *v71; // eax
  double *v72; // esi
  int v73; // edi
  int v74; // eax
  _DWORD *v75; // ecx
  int v76; // edx
  int v77; // edi
  int v78; // eax
  double *v79; // ecx
  int v80; // edx
  int v81; // esi
  double *v82; // edx
  double *v83; // edi
  int v84; // ecx
  double *v85; // ecx
  double *v86; // esi
  double *v87; // ecx
  int v88; // eax
  unsigned int v89; // eax
  double *v90; // ecx
  int v91; // esi
  double *v92; // eax
  double *v93; // ecx
  int v94; // eax
  unsigned int v95; // eax
  double *v96; // ecx
  int v97; // esi
  double *v98; // eax
  double *v99; // edi
  int v100; // eax
  double *v101; // eax
  int v102; // ecx
  int v103; // edx
  unsigned int v104; // eax
  int v105; // esi
  double *v106; // eax
  _DWORD *v107; // eax
  unsigned __int8 v109; // c0
  unsigned __int8 v110; // c3
  int v111; // esi
  int v112; // eax
  char *v113; // eax
  int v114; // edi
  _DWORD *v115; // ecx
  _DWORD *v116; // edx
  _DWORD *v117; // edi
  _DWORD *v118; // eax
  int v119; // edx
  _DWORD *v120; // eax
  _DWORD *v121; // eax
  int v122; // esi
  int v123; // ecx
  int v124; // esi
  _DWORD *v125; // ecx
  double *v126; // eax
  int v127; // edi
  _DWORD *v128; // eax
  int v129; // ecx
  int v130; // esi
  _BYTE *v131; // eax
  double *v132; // esi
  int v133; // eax
  _DWORD *v134; // eax
  int v135; // edx
  int v136; // eax
  int v137; // esi
  int v138; // esi
  int v139; // ecx
  double *v140; // edi
  int v141; // eax
  _DWORD *v142; // ecx
  int v143; // esi
  _DWORD *v144; // edx
  double *v145; // eax
  int v146; // edx
  double *v147; // esi
  _DWORD *v148; // eax
  int v150; // [esp+0h] [ebp-58h]
  unsigned int *v151; // [esp+Ch] [ebp-4Ch] BYREF
  double *v152; // [esp+10h] [ebp-48h]
  double *v153; // [esp+14h] [ebp-44h]
  _DWORD *v154; // [esp+18h] [ebp-40h]
  _DWORD *v155; // [esp+1Ch] [ebp-3Ch]
  double v156; // [esp+20h] [ebp-38h]
  double v157; // [esp+28h] [ebp-30h]
  int v158[2]; // [esp+30h] [ebp-28h] BYREF
  int v159[2]; // [esp+38h] [ebp-20h] BYREF
  int v160[2]; // [esp+40h] [ebp-18h] BYREF
  int v161[2]; // [esp+48h] [ebp-10h] BYREF
  double v162; // [esp+50h] [ebp-8h]

LABEL_1:
  v1 = a1;
  *(_DWORD *)(*(_DWORD *)(a1 + 20) + 16) = &v151;
  if ( (*(_BYTE *)(a1 + 48) & 1) != 0 )
    sub_10015AA0(a1, 0, -1);
  while ( 1 )
  {
    *(_DWORD *)(*(_DWORD *)(v1 + 20) + 8) = 2;
    v2 = *(_DWORD *)(v1 + 12);
    v151 = *(unsigned int **)(*(_DWORD *)(v1 + 20) + 12);
    v154 = *(_DWORD **)(v2 - 8);
    v153 = *(double **)(v154[3] + 8);
LABEL_4:
    v3 = *v151++;
    v4 = *(_BYTE *)(v1 + 48);
    if ( (v4 & 0xC) != 0 )
    {
      v5 = (*(_DWORD *)(v1 + 56))-- == 1;
      if ( v5 || (v4 & 4) != 0 )
      {
        sub_10016FF0(v1);
        if ( (*(_BYTE *)(*(_DWORD *)(v1 + 20) + 8) & 0x10) != 0 )
          break;
      }
    }
    v6 = *(double **)(v1 + 12);
    LODWORD(v156) = HIBYTE(v3);
    v152 = v6;
    v155 = (_DWORD *)(16 * HIBYTE(v3));
    v7 = (double *)((char *)v155 + (_DWORD)v6);
    v8 = v3 & 0x3F;
    switch ( v3 & 0x3F )
    {
      case 0u:
        v9 = v152;
        v10 = (v3 >> 15) & 0x1FF;
        goto LABEL_10;
      case 1u:
        v9 = v153;
        v10 = (v3 >> 6) & 0x3FFFF;
LABEL_10:
        v11 = &v9[2 * v10];
        *(_DWORD *)v7 = *(_DWORD *)v11;
        *((_DWORD *)v7 + 2) = *((_DWORD *)v11 + 2);
        *((_DWORD *)v7 + 3) = *((_DWORD *)v11 + 3);
        goto LABEL_4;
      case 2u:
        *(_DWORD *)v7 = 1;
        *((_DWORD *)v7 + 2) = (v3 >> 15) & 0x1FF;
        if ( (v3 & 0x7FC0) != 0 )
          ++v151;
        goto LABEL_4;
      case 3u:
        v12 = &v152[2 * ((v3 >> 15) & 0x1FF)];
        do
        {
          *(_DWORD *)v12 = 0;
          v12 -= 2;
        }
        while ( v12 >= v7 );
        goto LABEL_4;
      case 4u:
        v13 = *(_DWORD **)(v154[((v3 >> 15) & 0x1FF) + 8] + 8);
        *(_DWORD *)v7 = *v13;
        *((_DWORD *)v7 + 2) = v13[2];
        *((_DWORD *)v7 + 3) = v13[3];
        goto LABEL_4;
      case 5u:
        v14 = &v153[2 * ((v3 >> 6) & 0x3FFFF)];
        v15 = sub_10019DB0(v154[6], *((_DWORD *)v14 + 2));
        if ( *v15 )
        {
          *(_DWORD *)v7 = *v15;
          *((_DWORD *)v7 + 2) = v15[2];
          *((_DWORD *)v7 + 3) = v15[3];
          goto LABEL_4;
        }
        LODWORD(v157) = v154 + 4;
        v16 = *(_DWORD *)(v154[6] + 8);
        if ( (*(_BYTE *)(v16 + 6) & 1) != 0
          || (v17 = sub_10016EB0(v16, 0, *(_DWORD *)(*(_DWORD *)(v1 + 16) + 128)), (v18 = v17) == 0) )
        {
          v19 = &unk_1003F368;
          goto LABEL_30;
        }
        v20 = *v17;
        if ( *v18 == 6 )
        {
          sub_100170B0(v18, (_DWORD *)LODWORD(v157), v14, (_DWORD *)v1);
          v19 = *(_DWORD **)(v1 + 8);
          goto LABEL_30;
        }
        if ( v20 != 5 )
          goto LABEL_28;
        v21 = sub_10019DF0(v18[2], v14);
        if ( !*v21 )
          goto LABEL_27;
        goto LABEL_29;
      case 6u:
        v23 = v152;
        v24 = &v152[2 * ((v3 >> 15) & 0x1FF)];
        v25 = (v3 >> 6) & 0x1FF;
        v152 = v24;
        if ( v25 >= 250 )
        {
          v23 = v153;
          v25 -= 250;
        }
        v14 = &v23[2 * v25];
        if ( *(_DWORD *)v24 == 5 )
        {
          v26 = sub_10019DF0(*((_DWORD *)v152 + 2), v14);
          if ( *v26 )
          {
            *(_DWORD *)v7 = *v26;
            *((_DWORD *)v7 + 2) = v26[2];
            *((_DWORD *)v7 + 3) = v26[3];
            goto LABEL_4;
          }
          v27 = *(_DWORD *)(*((_DWORD *)v152 + 2) + 8);
          if ( (*(_BYTE *)(v27 + 6) & 1) != 0
            || (v18 = sub_10016EB0(v27, 0, *(_DWORD *)(*(_DWORD *)(v1 + 16) + 128))) == 0 )
          {
            v19 = &unk_1003F368;
            goto LABEL_30;
          }
          goto LABEL_68;
        }
        v18 = sub_10016EE0(v1, v152, 0);
        if ( !*v18 )
          sub_1001B6D0((_DWORD *)v1, (int)v152, (int)"index");
        v28 = *v18;
        if ( *v18 != 6 )
          goto LABEL_40;
        goto LABEL_46;
      case 7u:
        sub_100172A0((_DWORD *)v1, v154 + 4, &v153[2 * ((v3 >> 6) & 0x3FFFF)], v7);
        goto LABEL_4;
      case 8u:
        v29 = *(_DWORD **)(v154[((v3 >> 15) & 0x1FF) + 8] + 8);
        *v29 = *(_DWORD *)v7;
        v29[2] = *((_DWORD *)v7 + 2);
        v29[3] = *((_DWORD *)v7 + 3);
        goto LABEL_4;
      case 9u:
        v30 = (v3 >> 6) & 0x1FF;
        if ( v30 >= 0xFA )
        {
          v31 = v153;
          v30 -= 250;
        }
        else
        {
          v31 = v152;
        }
        v32 = (v3 >> 15) & 0x1FF;
        v33 = &v31[2 * v30];
        if ( v32 >= 250 )
        {
          v34 = v153;
          v32 -= 250;
        }
        else
        {
          v34 = v152;
        }
        sub_100172A0((_DWORD *)v1, v7, &v34[2 * v32], v33);
        goto LABEL_4;
      case 0xAu:
        *(_DWORD *)v7 = 5;
        *((_DWORD *)v7 + 2) = sub_10019C10(
                                (_DWORD *)v1,
                                ((v3 >> 15) & 7) << ((int)((v3 >> 15) & 0x1FF) >> 3),
                                (v3 >> 6) & 0x1FF);
        goto LABEL_57;
      case 0xBu:
        v35 = v152;
        v36 = &v152[2 * ((v3 >> 15) & 0x1FF)];
        v37 = (v3 >> 6) & 0x1FF;
        v152 = v36;
        if ( v37 >= 250 )
        {
          v35 = v153;
          v37 -= 250;
        }
        v14 = &v35[2 * v37];
        if ( *(_DWORD *)v14 != 4 )
          return 0;
        *((_DWORD *)v7 + 4) = *(_DWORD *)v36;
        *((_DWORD *)v7 + 6) = *((_DWORD *)v36 + 2);
        *((_DWORD *)v7 + 7) = *((_DWORD *)v36 + 3);
        if ( *(_DWORD *)v36 == 5 )
        {
          v38 = sub_10019DB0(*((_DWORD *)v152 + 2), *((_DWORD *)v14 + 2));
          if ( *v38 )
          {
            *(_DWORD *)v7 = *v38;
            *((_DWORD *)v7 + 2) = v38[2];
            *((_DWORD *)v7 + 3) = v38[3];
          }
          else
          {
            v39 = sub_10017BA0((_DWORD *)v1, v152, v14, 0);
            v40 = (_DWORD *)((char *)v155 + *(_DWORD *)(v1 + 12));
            *v40 = *v39;
            v40[2] = v39[2];
            v40[3] = v39[3];
          }
          goto LABEL_4;
        }
        v18 = sub_10016EE0(v1, v152, 0);
        if ( !*v18 )
          sub_1001B6D0((_DWORD *)v1, (int)v152, (int)"index");
LABEL_68:
        v28 = *v18;
        if ( *v18 == 6 )
        {
LABEL_46:
          sub_100170B0(v18, v152, v14, (_DWORD *)v1);
          v19 = *(_DWORD **)(v1 + 8);
        }
        else
        {
LABEL_40:
          if ( v28 == 5 )
          {
            v21 = sub_10019DF0(v18[2], v14);
            if ( !*v21 )
LABEL_27:
              v21 = sub_10017BA0((_DWORD *)v1, v18, v14, 1);
          }
          else
          {
LABEL_28:
            v21 = sub_100171D0((_DWORD *)a1, v18, v14, 1);
            v1 = a1;
          }
LABEL_29:
          v19 = v21;
        }
LABEL_30:
        v22 = (char *)v155 + *(_DWORD *)(v1 + 12);
        goto LABEL_31;
      case 0xCu:
        v41 = (v3 >> 15) & 0x1FF;
        if ( v41 >= 0xFA )
        {
          v42 = v153;
          v41 -= 250;
        }
        else
        {
          v42 = v152;
        }
        v43 = (v3 >> 6) & 0x1FF;
        v44 = &v42[2 * v41];
        if ( v43 >= 250 )
          v45 = &v153[2 * v43 - 500];
        else
          v45 = &v152[2 * v43];
        if ( *(_DWORD *)v44 == 3 && *(_DWORD *)v45 == 3 )
        {
          *(_DWORD *)v7 = 3;
          v7[1] = v45[1] + v44[1];
        }
        else
        {
          sub_100179E0((int *)v44, (_DWORD *)v1, (int)v7, v45, 5);
        }
        goto LABEL_4;
      case 0xDu:
        v46 = (v3 >> 15) & 0x1FF;
        if ( v46 >= 0xFA )
        {
          v47 = v153;
          v46 -= 250;
        }
        else
        {
          v47 = v152;
        }
        v48 = (v3 >> 6) & 0x1FF;
        v49 = &v47[2 * v46];
        if ( v48 >= 250 )
          v50 = &v153[2 * v48 - 500];
        else
          v50 = &v152[2 * v48];
        if ( *(_DWORD *)v49 == 3 && *(_DWORD *)v50 == 3 )
        {
          *(_DWORD *)v7 = 3;
          v7[1] = v49[1] - v50[1];
        }
        else
        {
          sub_100179E0((int *)v49, (_DWORD *)v1, (int)v7, v50, 6);
        }
        goto LABEL_4;
      case 0xEu:
        v51 = (v3 >> 15) & 0x1FF;
        if ( v51 >= 0xFA )
        {
          v52 = v153;
          v51 -= 250;
        }
        else
        {
          v52 = v152;
        }
        v53 = (v3 >> 6) & 0x1FF;
        v54 = &v52[2 * v51];
        if ( v53 >= 250 )
          v55 = &v153[2 * v53 - 500];
        else
          v55 = &v152[2 * v53];
        if ( *(_DWORD *)v54 == 3 && *(_DWORD *)v55 == 3 )
        {
          *(_DWORD *)v7 = 3;
          v7[1] = v55[1] * v54[1];
        }
        else
        {
          sub_100179E0((int *)v54, (_DWORD *)v1, (int)v7, v55, 7);
        }
        goto LABEL_4;
      case 0xFu:
        v56 = (v3 >> 15) & 0x1FF;
        if ( v56 >= 0xFA )
        {
          v57 = v153;
          v56 -= 250;
        }
        else
        {
          v57 = v152;
        }
        v58 = (v3 >> 6) & 0x1FF;
        v59 = &v57[2 * v56];
        if ( v58 >= 250 )
          v60 = &v153[2 * v58 - 500];
        else
          v60 = &v152[2 * v58];
        if ( *(_DWORD *)v59 == 3 && *(_DWORD *)v60 == 3 )
        {
          *(_DWORD *)v7 = 3;
          v7[1] = v59[1] / v60[1];
        }
        else
        {
          sub_100179E0((int *)v59, (_DWORD *)v1, (int)v7, v60, 8);
        }
        goto LABEL_4;
      case 0x10u:
        v61 = (v3 >> 6) & 0x1FF;
        if ( v61 >= 0xFA )
        {
          v62 = v153;
          v61 -= 250;
        }
        else
        {
          v62 = v152;
        }
        v63 = (v3 >> 15) & 0x1FF;
        v64 = &v62[2 * v61];
        if ( v63 >= 250 )
        {
          v65 = v153;
          v63 -= 250;
        }
        else
        {
          v65 = v152;
        }
        sub_100179E0((int *)&v65[2 * v63], (_DWORD *)v1, (int)v7, v64, 9);
        goto LABEL_4;
      case 0x11u:
        v66 = 2 * ((v3 >> 15) & 0x1FF);
        v67 = LODWORD(v152[v66]);
        v68 = (int *)&v152[v66];
        if ( v67 == 3 )
          goto LABEL_121;
        if ( v67 == 4 && sub_10018E70((char *)(v68[2] + 16), (double *)v158) )
        {
          v161[0] = 3;
          v162 = *(double *)v158;
          v68 = v161;
LABEL_121:
          *(_DWORD *)v7 = 3;
          v7[1] = -*((double *)v68 + 1);
        }
        else
        {
          v69 = *(_DWORD *)(v1 + 28);
          v161[0] = 0;
          v70 = (char *)v7 - v69;
          v71 = sub_10016EE0(v1, v68, 10);
          if ( !*v71 )
            v71 = sub_10016EE0(v1, v161, 10);
          if ( *v71 != 6 )
            sub_1001B780((_DWORD *)v1, v68, (int)v161);
          sub_100170B0(v71, v68, v161, (_DWORD *)v1);
          v19 = *(_DWORD **)(v1 + 8);
          v22 = &v70[*(_DWORD *)(v1 + 28)];
LABEL_31:
          *(_DWORD *)v22 = *v19;
          *((_DWORD *)v22 + 2) = v19[2];
          *((_DWORD *)v22 + 3) = v19[3];
        }
        goto LABEL_4;
      case 0x12u:
        v72 = &v152[2 * ((v3 >> 15) & 0x1FF)];
        if ( *(_DWORD *)v72 && (*(_DWORD *)v72 != 1 || *((_DWORD *)v72 + 2)) )
        {
          *(_DWORD *)v7 = 1;
          *((_DWORD *)v7 + 2) = 0;
        }
        else
        {
          *(_DWORD *)v7 = 1;
          *((_DWORD *)v7 + 2) = 1;
        }
        goto LABEL_4;
      case 0x13u:
        v73 = (v3 >> 15) & 0x1FF;
        sub_10017760((_DWORD *)v1, ((v3 >> 6) & 0x1FF) - v73 + 1, (v3 >> 6) & 0x1FF);
        v74 = *(_DWORD *)(v1 + 12);
        v75 = v155;
        v73 *= 16;
        v76 = *(_DWORD *)(v73 + v74);
        v77 = v74 + v73;
        *(_DWORD *)((char *)v155 + v74) = v76;
        *(_DWORD *)((char *)v75 + v74 + 8) = *(_DWORD *)(v77 + 8);
        *(_DWORD *)((char *)v75 + v74 + 12) = *(_DWORD *)(v77 + 12);
        goto LABEL_57;
      case 0x14u:
        v151 = &v151[((v3 >> 6) & 0x3FFFF) - 0x1FFFF];
        goto LABEL_4;
      case 0x15u:
        v78 = (v3 >> 15) & 0x1FF;
        if ( (unsigned int)v78 >= 0xFA )
        {
          v79 = v153;
          v80 = v78 - 250;
        }
        else
        {
          v79 = v152;
          v80 = (v3 >> 15) & 0x1FF;
        }
        v81 = (v3 >> 6) & 0x1FF;
        v82 = &v79[2 * v80];
        if ( v81 >= 250 )
        {
          v83 = v153;
          v84 = v81 - 250;
        }
        else
        {
          v83 = v152;
          v84 = v81;
        }
        v88 = 0;
        if ( *(_DWORD *)v82 == LODWORD(v83[2 * v84]) )
        {
          if ( v81 >= 250 )
          {
            v85 = v153;
            v81 -= 250;
          }
          else
          {
            v85 = v152;
          }
          v86 = &v85[2 * v81];
          if ( v78 >= 250 )
          {
            v87 = v153;
            v78 -= 250;
          }
          else
          {
            v87 = v152;
          }
          if ( sub_10017680((_DWORD *)v1, &v87[2 * v78], v86) )
            v88 = 1;
        }
        if ( v88 == LODWORD(v156) )
          goto LABEL_176;
        ++v151;
        goto LABEL_4;
      case 0x16u:
        v89 = (v3 >> 6) & 0x1FF;
        if ( v89 >= 0xFA )
        {
          v90 = v153;
          v89 -= 250;
        }
        else
        {
          v90 = v152;
        }
        v91 = (v3 >> 15) & 0x1FF;
        v92 = &v90[2 * v89];
        if ( v91 >= 250 )
        {
          v93 = v153;
          v91 -= 250;
        }
        else
        {
          v93 = v152;
        }
        v94 = sub_10017550((_DWORD *)v1, &v93[2 * v91], v92);
        if ( v94 == LODWORD(v156) )
          goto LABEL_176;
        ++v151;
        goto LABEL_4;
      case 0x17u:
        v95 = (v3 >> 6) & 0x1FF;
        if ( v95 >= 0xFA )
        {
          v96 = v153;
          v95 -= 250;
        }
        else
        {
          v96 = v152;
        }
        v97 = (v3 >> 15) & 0x1FF;
        v98 = &v96[2 * v95];
        if ( v97 >= 250 )
          v99 = &v153[2 * v97 - 500];
        else
          v99 = &v152[2 * v97];
        v100 = sub_100175E0(v99, v98, (_DWORD *)v1);
        if ( v100 == LODWORD(v156) )
          goto LABEL_176;
        ++v151;
        goto LABEL_4;
      case 0x18u:
        v101 = &v152[2 * ((v3 >> 15) & 0x1FF)];
        v102 = *(_DWORD *)v101;
        v103 = !*(_DWORD *)v101 || v102 == 1 && !*((_DWORD *)v101 + 2);
        if ( v103 == ((v3 >> 6) & 0x1FF) )
        {
          ++v151;
        }
        else
        {
          *(_DWORD *)v7 = v102;
          *((_DWORD *)v7 + 2) = *((_DWORD *)v101 + 2);
          *((_DWORD *)v7 + 3) = *((_DWORD *)v101 + 3);
LABEL_176:
          v151 = &v151[((*v151 >> 6) & 0x3FFFF) - 131070];
        }
        goto LABEL_4;
      case 0x19u:
      case 0x1Au:
        if ( ((v3 >> 15) & 0x1FF) != 0 )
          *(_DWORD *)(v1 + 8) = &v7[2 * ((v3 >> 15) & 0x1FF)];
        LODWORD(v157) = ((v3 >> 6) & 0x1FF) - 1;
        v104 = sub_10015D40(v1, (char *)v7);
        if ( !v104 )
        {
          v139 = *(_DWORD *)(v1 + 20);
          if ( (v3 & 0x3F) == 25 )
          {
            *(_DWORD *)(v139 - 12) = v151;
            *(_DWORD *)(*(_DWORD *)(v1 + 20) - 16) = 12;
          }
          else
          {
            v141 = *(_DWORD *)(v1 + 80);
            v152 = *(double **)(v139 - 24);
            v140 = v152;
            LODWORD(v157) = &v152[2 * HIBYTE(v3)];
            if ( v141 )
              sub_10019670(v1, (unsigned int)v152);
            v142 = (_DWORD *)LODWORD(v157);
            v143 = 0;
            if ( LODWORD(v157) < *(_DWORD *)(v1 + 8) )
            {
              v144 = (_DWORD *)LODWORD(v157);
              v145 = v140 - 2;
              do
              {
                *(_DWORD *)v145 = *v142;
                *((_DWORD *)v145 + 2) = v142[2];
                *((_DWORD *)v145 + 3) = v142[3];
                v144 += 4;
                ++v143;
                v145 += 2;
                v142 = v144;
              }
              while ( (unsigned int)v144 < *(_DWORD *)(v1 + 8) );
              v140 = v152;
            }
            v146 = *(_DWORD *)(v1 + 20);
            v147 = &v140[2 * v143];
            *(_DWORD *)(v1 + 8) = v147;
            *(_DWORD *)(v146 - 20) = v147;
            *(_DWORD *)(*(_DWORD *)(v1 + 20) - 12) = *(_DWORD *)(*(_DWORD *)(v1 + 20) + 12);
            ++*(_DWORD *)(*(_DWORD *)(v1 + 20) - 4);
            *(_DWORD *)(*(_DWORD *)(v1 + 20) - 16) = 8;
            v148 = (_DWORD *)(*(_DWORD *)(v1 + 20) - 24);
            *(_DWORD *)(v1 + 20) = v148;
            *(_DWORD *)(v1 + 12) = *v148;
          }
          goto LABEL_1;
        }
        if ( v104 > *(_DWORD *)(v1 + 8) )
        {
          *(_DWORD *)(*(_DWORD *)(v1 + 20) - 12) = v151;
          *(_DWORD *)(*(_DWORD *)(v1 + 20) - 16) = 8;
          return 0;
        }
        v105 = LODWORD(v157);
        sub_10015F40(v1, SLODWORD(v157), v104);
        if ( v105 >= 0 )
          *(_DWORD *)(v1 + 8) = *(_DWORD *)(*(_DWORD *)(v1 + 20) + 4);
        goto LABEL_4;
      case 0x1Bu:
        v136 = *(_DWORD *)(v1 + 20) - 24;
        v137 = (v3 >> 15) & 0x1FF;
        LODWORD(v157) = v136;
        if ( v137 )
          *(_DWORD *)(v1 + 8) = &v7[2 * v137 - 2];
        if ( *(_DWORD *)(v1 + 80) )
        {
          sub_10019670(v1, (unsigned int)v152);
          v136 = LODWORD(v157);
        }
        *(_DWORD *)(*(_DWORD *)(v1 + 20) + 8) = 8;
        *(_DWORD *)(*(_DWORD *)(v1 + 20) + 12) = v151;
        if ( (*(_BYTE *)(v136 + 8) & 4) == 0 )
          return v7;
        v138 = ((*(_DWORD *)(*(_DWORD *)(LODWORD(v157) + 12) - 4) >> 6) & 0x1FF) - 1;
        sub_10015F40(v1, v138, (int)v7);
        if ( v138 >= 0 )
          *(_DWORD *)(v1 + 8) = *(_DWORD *)(*(_DWORD *)(v1 + 20) + 4);
        break;
      case 0x1Cu:
        v155 = v7 + 4;
        v5 = *(_DWORD *)v7 == 3;
        v152 = v7 + 2;
        if ( !v5 )
          sub_1001B4B0((_DWORD *)v1, "`for' initial value must be a number", v150);
        if ( *(_DWORD *)v152 != 3 )
        {
          if ( *(_DWORD *)v152 != 4 || !sub_10018E70((char *)(*((_DWORD *)v152 + 2) + 16), (double *)v159) )
          {
            v152 = 0;
            sub_1001B4B0((_DWORD *)v1, "`for' limit must be a number", v150);
          }
          v106 = v152;
          v152[1] = *(double *)v159;
          *(_DWORD *)v106 = 3;
          v152 = v106;
        }
        if ( *v155 != 3 )
        {
          if ( *v155 != 4 || !sub_10018E70((char *)(v155[2] + 16), (double *)v160) )
          {
            v155 = 0;
            sub_1001B4B0((_DWORD *)v1, "`for' step must be a number", v150);
          }
          v107 = v155;
          *((double *)v155 + 1) = *(double *)v160;
          *v107 = 3;
          v155 = v107;
        }
        v157 = *((double *)v155 + 1) + v7[1];
        v156 = v152[1];
        if ( v109 | v110 )
        {
          if ( v157 < v156 )
            goto LABEL_4;
        }
        else if ( v157 > v156 )
        {
          goto LABEL_4;
        }
        v151 = &v151[((v3 >> 6) & 0x3FFFF) - 0x1FFFF];
        v7[1] = v157;
        goto LABEL_4;
      case 0x1Du:
        v111 = ((v3 >> 6) & 0x1FF) + 1;
        v112 = 2 * (v111 + 2);
        LODWORD(v7[v112]) = *(_DWORD *)v7;
        v113 = (char *)&v7[v112];
        *((_DWORD *)v113 + 2) = *((_DWORD *)v7 + 2);
        *((_DWORD *)v113 + 3) = *((_DWORD *)v7 + 3);
        *((_DWORD *)v113 + 4) = *((_DWORD *)v7 + 4);
        *((_DWORD *)v113 + 6) = *((_DWORD *)v7 + 6);
        *((_DWORD *)v113 + 7) = *((_DWORD *)v7 + 7);
        *((_DWORD *)v113 + 8) = *((_DWORD *)v7 + 8);
        *((_DWORD *)v113 + 10) = *((_DWORD *)v7 + 10);
        *((_DWORD *)v113 + 11) = *((_DWORD *)v7 + 11);
        *(_DWORD *)(v1 + 8) = v113 + 48;
        sub_10015FC0(v1, v113, v111);
        v114 = *(_DWORD *)(v1 + 12);
        *(_DWORD *)(v1 + 8) = *(_DWORD *)(*(_DWORD *)(v1 + 20) + 4);
        v115 = (_DWORD *)(v114 + 16 * (LODWORD(v156) + 2));
        v116 = &v115[4 * v111];
        v117 = &v116[4 * v111];
        v118 = v116 + 2;
        v119 = 4 * v111;
        while ( 1 )
        {
          v118 -= 4;
          LODWORD(v157) = v117 - 4;
          *(v118 - 2) = *(v117 - 4);
          --v111;
          *v118 = v118[v119];
          v118[1] = v118[v119 + 1];
          if ( v111 <= 0 )
            break;
          v117 = (_DWORD *)LODWORD(v157);
        }
        if ( *v115 )
          v151 = &v151[((*v151 >> 6) & 0x3FFFF) - 131070];
        else
          ++v151;
        goto LABEL_4;
      case 0x1Eu:
        if ( *(_DWORD *)v7 == 5 )
        {
          *((_DWORD *)v7 + 4) = 5;
          *((_DWORD *)v7 + 6) = *((_DWORD *)v7 + 2);
          *((_DWORD *)v7 + 7) = *((_DWORD *)v7 + 3);
          v120 = sub_100194B0(v1, "next", 4u);
          v121 = sub_10019DB0(*(_DWORD *)(v1 + 72), (int)v120);
          *(_DWORD *)v7 = *v121;
          *((_DWORD *)v7 + 2) = v121[2];
          *((_DWORD *)v7 + 3) = v121[3];
        }
        v151 = &v151[((v3 >> 6) & 0x3FFFF) - 0x1FFFF];
        goto LABEL_4;
      case 0x1Fu:
      case 0x20u:
        if ( *(_DWORD *)v7 != 5 )
          return 0;
        v122 = (v3 >> 6) & 0x3FFFF;
        LODWORD(v157) = *((_DWORD *)v7 + 2);
        v123 = v122;
        if ( v8 == 31 )
        {
          v124 = (v122 & 0x1F) + 1;
        }
        else
        {
          v124 = ((*(_DWORD *)(v1 + 8) - (int)v7) >> 4) - 1;
          *(_DWORD *)(v1 + 8) = *(_DWORD *)(*(_DWORD *)(v1 + 20) + 4);
        }
        v125 = (_DWORD *)(v123 & 0x3FFE0);
        v155 = v125;
        if ( v124 > 0 )
        {
          v126 = &v7[2 * v124];
          v127 = LODWORD(v157);
          LODWORD(v156) = v126;
          while ( 1 )
          {
            v128 = sub_1001A3D0((_DWORD *)v1, v127, (int)v125 + v124);
            v129 = LODWORD(v156);
            *v128 = *(_DWORD *)LODWORD(v156);
            v128[2] = *(_DWORD *)(v129 + 8);
            --v124;
            v128[3] = *(_DWORD *)(v129 + 12);
            LODWORD(v156) = v129 - 16;
            if ( v124 <= 0 )
              break;
            v125 = v155;
          }
        }
        goto LABEL_4;
      case 0x21u:
        sub_10019670(v1, (unsigned int)v7);
        goto LABEL_4;
      case 0x22u:
        LODWORD(v156) = *(_DWORD *)(*(_DWORD *)(v154[3] + 16) + 4 * ((v3 >> 6) & 0x3FFFF));
        v130 = *(unsigned __int8 *)(LODWORD(v156) + 68);
        v131 = sub_100195C0((_DWORD *)v1, v130, v154 + 4);
        LODWORD(v157) = v131;
        *((_DWORD *)v131 + 3) = LODWORD(v156);
        if ( v130 > 0 )
        {
          v155 = (_DWORD *)v130;
          v132 = v152;
          LODWORD(v156) = v131 + 32;
          do
          {
            v133 = (*v151 >> 15) & 0x1FF;
            if ( (*v151 & 0x3F) == 4 )
            {
              *(_DWORD *)LODWORD(v156) = v154[v133 + 8];
            }
            else
            {
              v134 = sub_10019620((_DWORD *)v1, (unsigned int)&v132[2 * v133]);
              *(_DWORD *)LODWORD(v156) = v134;
            }
            LODWORD(v156) += 4;
            v5 = v155 == (_DWORD *)1;
            ++v151;
            v155 = (_DWORD *)((char *)v155 - 1);
          }
          while ( !v5 );
        }
        v135 = LODWORD(v157);
        *(_DWORD *)v7 = 6;
        *((_DWORD *)v7 + 2) = v135;
LABEL_57:
        if ( *(_DWORD *)(*(_DWORD *)(v1 + 16) + 36) >= *(_DWORD *)(*(_DWORD *)(v1 + 16) + 32) )
          sub_10016E30((_DWORD *)v1);
        goto LABEL_4;
      default:
        goto LABEL_4;
    }
  }
  *(_DWORD *)(*(_DWORD *)(v1 + 20) + 12) = v151 - 1;
  *(_DWORD *)(*(_DWORD *)(v1 + 20) + 8) = 24;
  return 0;
}
// 10018A54: mask 0xFFFFFFE0 is shortened because ecx.4 <= 0x3FFFF
// 100187C7: variable 'v150' is possibly undefined
// 100188A8: variable 'v109' is possibly undefined
// 100188A8: variable 'v110' is possibly undefined

//----- (10018DA0) --------------------------------------------------------
int __cdecl sub_10018DA0(unsigned int a1)
{
  unsigned int v1; // ecx
  int i; // eax

  v1 = a1;
  for ( i = 0; v1 >= 8; ++i )
    v1 = (v1 + 1) >> 1;
  return v1 | (8 * i);
}

//----- (10018DC0) --------------------------------------------------------
int __cdecl sub_10018DC0(unsigned int a1)
{
  if ( a1 < 0x10000 )
  {
    if ( a1 < 0x100 )
    {
      if ( a1 )
        return (unsigned __int8)byte_1003F377[(unsigned __int8)a1];
      else
        return -1;
    }
    else
    {
      return (unsigned __int8)byte_1003F377[BYTE1(a1)] + 8;
    }
  }
  else if ( a1 < 0x1000000 )
  {
    return (unsigned __int8)byte_1003F377[BYTE2(a1)] + 16;
  }
  else
  {
    return (unsigned __int8)byte_1003F377[HIBYTE(a1)] + 24;
  }
}

//----- (10018E20) --------------------------------------------------------
BOOL __cdecl sub_10018E20(int a1, int a2)
{
  BOOL result; // eax

  if ( *(_DWORD *)a1 != *(_DWORD *)a2 )
    return 0;
  switch ( *(_DWORD *)a1 )
  {
    case 0:
      goto LABEL_3;
    case 3:
      if ( *(double *)(a1 + 8) != *(double *)(a2 + 8) )
        return 0;
LABEL_3:
      result = 1;
      break;
    default:
      result = *(_DWORD *)(a2 + 8) == *(_DWORD *)(a1 + 8);
      break;
  }
  return result;
}

//----- (10018E70) --------------------------------------------------------
int __cdecl sub_10018E70(char *String, double *a2)
{
  char *v2; // esi
  double v4; // [esp+4h] [ebp-8h]

  v2 = String;
  v4 = strtod(String, &String);
  if ( String == v2 )
    return 0;
  for ( ; isspace((unsigned __int8)*String); ++String )
    ;
  if ( *String )
    return 0;
  *a2 = v4;
  return 1;
}

//----- (10018EE0) --------------------------------------------------------
int __usercall sub_10018EE0@<eax>(char *a1@<edx>, _DWORD *a2@<esi>)
{
  _DWORD *v2; // edi
  int result; // eax

  v2 = (_DWORD *)a2[2];
  *v2 = 4;
  v2[2] = sub_100194B0((int)a2, a1, strlen(a1));
  if ( a2[6] - a2[2] <= 16 )
    sub_10015A20(a2, 1);
  result = a2[2] + 16;
  a2[2] = result;
  return result;
}

//----- (10018F30) --------------------------------------------------------
int __cdecl sub_10018F30(_DWORD *a1, char *Str, int a3)
{
  _DWORD *v3; // esi
  _DWORD *v4; // edi
  int v5; // ebx
  char *v6; // edi
  char *v7; // eax
  int v8; // ebx
  _DWORD *v9; // ebp
  int v10; // edx
  _DWORD *v11; // edi
  char *v12; // edx
  unsigned __int8 v13; // dl
  _DWORD *v14; // eax
  double v15; // st7
  bool v16; // cc
  _DWORD *v17; // ebp
  int v18; // edx
  int v20; // [esp-Ch] [ebp-24h]
  const char *v21; // [esp-Ch] [ebp-24h]
  int v22; // [esp-4h] [ebp-1Ch]
  int v23; // [esp+Ch] [ebp-Ch]
  char *v24; // [esp+10h] [ebp-8h]
  int v25; // [esp+14h] [ebp-4h]

  v3 = a1;
  v4 = (_DWORD *)a1[2];
  v5 = 1;
  v20 = (int)a1;
  v25 = 1;
  *v4 = 4;
  v4[2] = sub_100194B0(v20, byte_1003D986, 0);
  if ( v3[6] - v3[2] <= 16 )
    sub_10015A20(v3, 1);
  v6 = Str;
  v21 = Str;
  v3[2] += 16;
  v7 = strchr(v21, 37);
  v24 = v7;
  if ( v7 )
  {
    v23 = a3 - 8;
    v8 = a3 - 4;
    while ( 1 )
    {
      v9 = (_DWORD *)v3[2];
      *v9 = 4;
      v9[2] = sub_100194B0((int)v3, v6, v7 - v6);
      if ( v3[6] - v3[2] <= 16 )
        sub_10015A20(v3, 1);
      v10 = v3[2] + 16;
      v3[2] = v10;
      v11 = (_DWORD *)v10;
      switch ( v24[1] )
      {
        case '%':
          *(_DWORD *)v10 = 4;
          v14 = sub_100194B0((int)v3, "%", 1u);
          goto LABEL_14;
        case 'c':
          v13 = *(_BYTE *)(v8 + 4);
          v8 += 4;
          v23 += 4;
          LOWORD(a1) = v13;
          *v11 = 4;
          v14 = sub_100194B0((int)v3, (char *)&a1, strlen((const char *)&a1));
LABEL_14:
          v11[2] = v14;
          v16 = v3[6] - v3[2] <= 16;
          goto LABEL_15;
        case 'd':
          *(_DWORD *)v10 = 3;
          v15 = (double)*(int *)(v8 + 4);
          v8 += 4;
          v23 += 4;
          *(double *)(v10 + 8) = v15;
          v16 = v3[6] - v3[2] <= 16;
          goto LABEL_15;
        case 'f':
          *(_DWORD *)v10 = 3;
          *(double *)(v10 + 8) = *(double *)(v23 + 8);
          v23 += 8;
          v8 += 8;
          v16 = v3[6] - v3[2] <= 16;
LABEL_15:
          if ( v16 )
            sub_10015A20(v3, 1);
          v3[2] += 16;
          break;
        case 's':
          v12 = *(char **)(v8 + 4);
          v8 += 4;
          v23 += 4;
          sub_10018EE0(v12, v3);
          break;
        default:
          break;
      }
      v6 = v24 + 2;
      v25 += 2;
      v24 = strchr(v24 + 2, 37);
      if ( !v24 )
        break;
      v7 = v24;
    }
    v5 = v25;
  }
  v17 = (_DWORD *)v3[2];
  *v17 = 4;
  v17[2] = sub_100194B0((int)v3, v6, strlen(v6));
  if ( v3[6] - v3[2] <= 16 )
    sub_10015A20(v3, 1);
  v22 = ((v3[2] + 16 - v3[3]) >> 4) - 1;
  v3[2] += 16;
  sub_10017760(v3, v5 + 1, v22);
  v18 = -16 * v5 + v3[2];
  v3[2] = v18;
  return *(_DWORD *)(v18 - 8) + 16;
}

//----- (10019200) --------------------------------------------------------
int __cdecl sub_10019200(_DWORD *a1, char *Str, int a3)
{
  return sub_10018F30(a1, Str, (int)&a3);
}

//----- (10019220) --------------------------------------------------------
char __cdecl sub_10019220(char *Destination, char *Source, size_t Count)
{
  signed int v3; // eax
  const char *v4; // esi
  signed int v5; // eax

  if ( *Source == 61 )
  {
    LOBYTE(v3) = (unsigned __int8)strncpy(Destination, Source + 1, Count);
    Destination[Count - 1] = 0;
  }
  else if ( *Source == 64 )
  {
    v4 = Source + 1;
    v5 = strlen(Source + 1);
    *Destination = 0;
    if ( v5 > (int)(Count - 8) )
    {
      v4 += v5 - (Count - 8);
      *(_DWORD *)&Destination[strlen(Destination)] = 3026478;
    }
    v3 = strlen(v4) + 1;
    qmemcpy(&Destination[strlen(Destination)], v4, v3);
  }
  else
  {
    v3 = strcspn(Source, "\n");
    if ( v3 > (int)(Count - 17) )
      v3 = Count - 17;
    strcpy(Destination, "[string \"");
    if ( Source[v3] )
    {
      strncat(Destination, Source, v3);
      *(_DWORD *)&Destination[strlen(Destination)] = 3026478;
    }
    else
    {
      strcat(Destination, Source);
    }
    strcat(Destination, "\"]");
  }
  return v3;
}
// 10019245: variable 'v3' is possibly undefined

//----- (10019370) --------------------------------------------------------
void *__cdecl sub_10019370(_DWORD *a1, int a2)
{
  int v2; // ebp
  _DWORD *v3; // eax
  int v4; // ebx
  _DWORD *v5; // esi
  int v6; // ecx
  _DWORD *v7; // eax
  _DWORD *v8; // edx
  int v9; // ecx
  bool v10; // zf
  void *result; // eax
  int i; // [esp+10h] [ebp-4h]

  v2 = a2;
  v3 = sub_1001B810(a1, 0, 0, 4 * a2);
  v4 = a1[4];
  v5 = v3;
  if ( a2 > 0 )
    memset(v3, 0, 4 * a2);
  v6 = 0;
  for ( i = 0; v6 < *(_DWORD *)(v4 + 8); i = v6 )
  {
    v7 = *(_DWORD **)(*(_DWORD *)v4 + 4 * v6);
    if ( v7 )
    {
      do
      {
        v8 = (_DWORD *)*v7;
        v9 = (v2 - 1) & v7[2];
        v10 = *v7 == 0;
        *v7 = v5[v9];
        v5[v9] = v7;
        v7 = v8;
      }
      while ( !v10 );
      v2 = a2;
      v6 = i;
    }
    ++v6;
  }
  result = sub_1001B810(a1, *(void **)v4, 4 * *(_DWORD *)(v4 + 8), 0);
  *(_DWORD *)v4 = v5;
  *(_DWORD *)(v4 + 8) = v2;
  return result;
}

//----- (10019410) --------------------------------------------------------
_DWORD *__usercall sub_10019410@<eax>(int a1@<eax>, _DWORD *a2, const void *a3, unsigned int a4)
{
  _DWORD *v5; // ebp
  _DWORD *v6; // eax
  int v7; // ebx
  int v8; // edi
  int v9; // eax

  v5 = sub_1001B810(a2, 0, 0, a4 + 17);
  v5[3] = a4;
  v5[2] = a1;
  *((_BYTE *)v5 + 5) = 0;
  *((_BYTE *)v5 + 4) = 4;
  *((_BYTE *)v5 + 6) = 0;
  qmemcpy(v5 + 4, a3, a4);
  *((_BYTE *)v5 + a4 + 16) = 0;
  v6 = (_DWORD *)a2[4];
  v7 = (v6[2] - 1) & a1;
  *v5 = *(_DWORD *)(*v6 + 4 * v7);
  *(_DWORD *)(*v6 + 4 * v7) = v5;
  v8 = v6[1] + 1;
  v6[1] = v8;
  v9 = v6[2];
  if ( v8 > v9 && v9 <= 1073741822 )
    sub_10019370(a2, 2 * v9);
  return v5;
}

//----- (100194B0) --------------------------------------------------------
_DWORD *__cdecl sub_100194B0(int a1, char *a2, unsigned int a3)
{
  char *v3; // esi
  unsigned int v4; // ecx
  unsigned int v5; // edx
  unsigned int i; // eax
  int v7; // edi
  _DWORD *result; // eax

  v3 = a2;
  v4 = (a3 >> 5) + 1;
  v5 = a3;
  for ( i = a3; i >= v4; v5 ^= v7 )
  {
    v7 = (v5 >> 2) + 32 * v5 + (unsigned __int8)a2[i - 1];
    i -= v4;
  }
  for ( result = *(_DWORD **)(**(_DWORD **)(a1 + 16) + 4 * (v5 & (*(_DWORD *)(*(_DWORD *)(a1 + 16) + 8) - 1)));
        result;
        result = (_DWORD *)*result )
  {
    if ( result[3] == a3 )
    {
      if ( !memcmp(v3, result + 4, a3) )
        return result;
      v3 = a2;
    }
  }
  return sub_10019410(v5, (_DWORD *)a1, v3, a3);
}

//----- (10019540) --------------------------------------------------------
_DWORD *__cdecl sub_10019540(_DWORD *a1, int a2)
{
  _DWORD *result; // eax

  result = sub_1001B810(a1, 0, 0, a2 + 16);
  result[3] = a2;
  *((_BYTE *)result + 5) = 2;
  *((_BYTE *)result + 4) = 7;
  result[2] = *(_DWORD *)(a1[4] + 72);
  *result = *(_DWORD *)(a1[4] + 16);
  *(_DWORD *)(a1[4] + 16) = result;
  return result;
}

//----- (10019580) --------------------------------------------------------
_BYTE *__cdecl sub_10019580(_DWORD *a1, int a2)
{
  _BYTE *v2; // esi

  v2 = sub_1001B810(a1, 0, 0, 16 * (a2 + 1));
  sub_10016E80((int)a1, (int)v2, 6);
  v2[7] = a2;
  v2[6] = 1;
  return v2;
}

//----- (100195C0) --------------------------------------------------------
_BYTE *__cdecl sub_100195C0(_DWORD *a1, int a2, _DWORD *a3)
{
  _BYTE *v3; // esi
  int v4; // edx
  _BYTE *result; // eax

  v3 = sub_1001B810(a1, 0, 0, 4 * a2 + 36);
  sub_10016E80((int)a1, (int)v3, 6);
  v3[6] = 0;
  *((_DWORD *)v3 + 4) = *a3;
  *((_DWORD *)v3 + 5) = a3[1];
  *((_DWORD *)v3 + 6) = a3[2];
  v4 = a3[3];
  v3[7] = a2;
  result = v3;
  *((_DWORD *)v3 + 7) = v4;
  return result;
}

//----- (10019620) --------------------------------------------------------
_DWORD *__cdecl sub_10019620(_DWORD *a1, unsigned int a2)
{
  _DWORD *result; // eax
  _DWORD *i; // esi
  unsigned int v4; // ecx

  result = (_DWORD *)a1[20];
  for ( i = a1 + 20; result; result = (_DWORD *)*result )
  {
    v4 = result[2];
    if ( v4 < a2 )
      break;
    if ( v4 == a2 )
      return result;
    i = result;
  }
  result = sub_1001B810(a1, 0, 0, 0x20u);
  *((_BYTE *)result + 4) = 10;
  *((_BYTE *)result + 5) = 1;
  result[2] = a2;
  *result = *i;
  *i = result;
  return result;
}

//----- (10019670) --------------------------------------------------------
_DWORD *__cdecl sub_10019670(int a1, unsigned int a2)
{
  _DWORD *result; // eax
  _DWORD *v3; // edx

  for ( result = *(_DWORD **)(a1 + 80); result; result = *(_DWORD **)(a1 + 80) )
  {
    v3 = (_DWORD *)result[2];
    if ( (unsigned int)v3 < a2 )
      break;
    result[4] = *v3;
    result[6] = v3[2];
    result[7] = v3[3];
    result[2] = result + 4;
    *(_DWORD *)(a1 + 80) = *result;
    sub_10016E80(a1, (int)result, 10);
  }
  return result;
}

//----- (100196C0) --------------------------------------------------------
_DWORD *__cdecl sub_100196C0(_DWORD *a1)
{
  _DWORD *v1; // esi

  v1 = sub_1001B810(a1, 0, 0, 0x48u);
  sub_10016E80((int)a1, (int)v1, 9);
  v1[2] = 0;
  v1[10] = 0;
  v1[4] = 0;
  v1[13] = 0;
  v1[3] = 0;
  v1[11] = 0;
  v1[12] = 0;
  v1[9] = 0;
  *((_BYTE *)v1 + 68) = 0;
  v1[7] = 0;
  *((_BYTE *)v1 + 69) = 0;
  *((_BYTE *)v1 + 70) = 0;
  *((_BYTE *)v1 + 71) = 0;
  v1[5] = 0;
  v1[14] = 0;
  v1[6] = 0;
  v1[15] = 0;
  v1[8] = 0;
  return v1;
}

//----- (10019720) --------------------------------------------------------
void *__cdecl sub_10019720(_DWORD *a1, int a2)
{
  sub_1001B810(a1, *(void **)(a2 + 12), 4 * *(_DWORD *)(a2 + 44), 0);
  sub_1001B810(a1, *(void **)(a2 + 16), 4 * *(_DWORD *)(a2 + 52), 0);
  sub_1001B810(a1, *(void **)(a2 + 8), 16 * *(_DWORD *)(a2 + 40), 0);
  sub_1001B810(a1, *(void **)(a2 + 20), 4 * *(_DWORD *)(a2 + 48), 0);
  sub_1001B810(a1, *(void **)(a2 + 24), 12 * *(_DWORD *)(a2 + 56), 0);
  sub_1001B810(a1, *(void **)(a2 + 28), 4 * *(_DWORD *)(a2 + 36), 0);
  return sub_1001B810(a1, (void *)a2, 72, 0);
}

//----- (100197C0) --------------------------------------------------------
void *__cdecl sub_100197C0(_DWORD *a1, _BYTE *a2)
{
  int v2; // eax

  v2 = (unsigned __int8)a2[7];
  if ( a2[6] )
    return sub_1001B810(a1, a2, 16 * (v2 + 1), 0);
  else
    return sub_1001B810(a1, a2, 4 * v2 + 36, 0);
}

//----- (10019800) --------------------------------------------------------
int __cdecl sub_10019800(int a1, int a2, int a3)
{
  int v3; // edx
  int v4; // ecx
  int v5; // edi
  _DWORD *i; // eax

  v3 = *(_DWORD *)(a1 + 56);
  v4 = 0;
  if ( v3 > 0 )
  {
    v5 = *(_DWORD *)(a1 + 24);
    for ( i = (_DWORD *)(v5 + 8); *(i - 1) <= a3; i += 3 )
    {
      if ( a3 < *i && !--a2 )
        return *(_DWORD *)(v5 + 12 * v4) + 16;
      if ( ++v4 >= v3 )
        return 0;
    }
  }
  return 0;
}

//----- (10019850) --------------------------------------------------------
unsigned int __usercall sub_10019850@<eax>(int a1@<esi>, double a2)
{
  double v3; // [esp+4h] [ebp+4h]

  v3 = a2 + 1.0;
  return *(_DWORD *)(a1 + 16) + 40 * ((HIDWORD(v3) + LODWORD(v3)) % (((1 << *(_BYTE *)(a1 + 7)) - 1) | 1u));
}

//----- (10019890) --------------------------------------------------------
unsigned int __cdecl sub_10019890(int a1, int a2)
{
  unsigned int result; // eax

  switch ( *(_DWORD *)a2 )
  {
    case 1:
      result = *(_DWORD *)(a1 + 16) + 40 * (*(_DWORD *)(a2 + 8) & ((1 << *(_BYTE *)(a1 + 7)) - 1));
      break;
    case 2:
      result = *(_DWORD *)(a1 + 16) + 40 * (*(_DWORD *)(a2 + 8) % (((1 << *(_BYTE *)(a1 + 7)) - 1) | 1u));
      break;
    case 3:
      result = sub_10019850(a1, *(double *)(a2 + 8));
      break;
    case 4:
      result = *(_DWORD *)(a1 + 16) + 40 * (*(_DWORD *)(*(_DWORD *)(a2 + 8) + 8) & ((1 << *(_BYTE *)(a1 + 7)) - 1));
      break;
    default:
      result = *(_DWORD *)(a1 + 16) + 40 * (*(_DWORD *)(a2 + 8) % (((1 << *(_BYTE *)(a1 + 7)) - 1) | 1u));
      break;
  }
  return result;
}

//----- (10019960) --------------------------------------------------------
int __usercall sub_10019960@<eax>(int *a1@<edx>, int a2, int *a3, _DWORD *a4)
{
  int v4; // eax
  int v5; // ebp
  int v6; // ecx
  int *v7; // ebx
  int result; // eax
  int v9; // [esp+8h] [ebp-4h]

  v4 = *a1;
  v9 = *a1;
  v5 = (*a1 != 0) - 1;
  if ( *a1 < *a3 )
  {
    v6 = 0;
    v7 = a1 + 1;
    do
    {
      if ( *a3 < 1 << v6 )
        break;
      if ( *v7 > 0 )
      {
        v4 += *v7;
        if ( v4 >= 1 << v6 )
        {
          v5 = v6 + 1;
          v9 = v4;
        }
      }
      ++v7;
      ++v6;
    }
    while ( v4 < *a3 );
  }
  *a4 = a2 - v9;
  if ( v5 == -1 )
  {
    result = 0;
    *a3 = 0;
  }
  else
  {
    result = 1 << v5;
    *a3 = 1 << v5;
  }
  return result;
}

//----- (100199F0) --------------------------------------------------------
int __cdecl sub_100199F0(int a1, int *a2, _DWORD *a3)
{
  int v3; // ebp
  int v4; // edi
  int v5; // edx
  int v6; // ebx
  int *v7; // esi
  int v8; // eax
  _DWORD *v9; // ecx
  int v10; // eax
  char v12; // cl
  int v13; // edi
  int v14; // esi
  int v15; // eax
  int v16; // esi
  int v17; // ecx
  int v18; // eax
  int v20; // [esp+10h] [ebp-68h]
  int v21[25]; // [esp+14h] [ebp-64h] BYREF
  int v22; // [esp+80h] [ebp+8h]

  v3 = 0;
  v4 = *(_DWORD *)(a1 + 28);
  v5 = 0;
  v20 = 0;
  v6 = 0;
  v7 = v21;
  while ( 1 )
  {
    v8 = 1 << v6;
    if ( 1 << v6 > v4 )
    {
      v8 = v4;
      if ( v5 >= v4 )
        break;
    }
    *v7 = 0;
    if ( v5 < v8 )
    {
      v9 = (_DWORD *)(*(_DWORD *)(a1 + 12) + 16 * v5);
      v3 = v20;
      v10 = v8 - v5;
      v5 += v10;
      do
      {
        if ( *v9 )
        {
          ++*v7;
          ++v3;
        }
        v9 += 4;
        --v10;
      }
      while ( v10 );
      v20 = v3;
    }
    ++v6;
    ++v7;
    if ( v6 > 24 )
      goto LABEL_13;
  }
  memset(&v21[v6], 0, 4 * (25 - v6));
LABEL_13:
  *a2 = v3;
  v12 = *(_BYTE *)(a1 + 7);
  if ( 1 << v12 )
  {
    v13 = 40 * (1 << v12);
    v22 = 1 << v12;
    do
    {
      v14 = *(_DWORD *)(a1 + 16);
      v13 -= 40;
      v15 = *(_DWORD *)(v14 + v13 + 16);
      v16 = v13 + v14;
      if ( v15 )
      {
        if ( *(_DWORD *)v16 == 3 )
        {
          v17 = (unsigned __int64)*(double *)(v16 + 8);
          if ( *(double *)(v16 + 8) == (double)v17 && v17 >= 1 && ((v17 - 1) & 0xFF000000) == 0 )
          {
            v18 = sub_10018DC0(v17 - 1);
            ++v21[v18 + 1];
            ++*a2;
          }
        }
        ++v3;
      }
      --v22;
    }
    while ( v22 );
  }
  return sub_10019960(v21, v3, a2, a3);
}
// 10019A61: conditional instruction was optimized away because ebx.4<19
// 10019AE8: conditional instruction was optimized away because ecx.4>=1

//----- (10019B30) --------------------------------------------------------
char *__usercall sub_10019B30@<eax>(int a1@<edi>, int a2@<esi>, _DWORD *a3)
{
  char *result; // eax
  int v4; // edx
  int v5; // ecx

  result = (char *)sub_1001B810(a3, *(void **)(a2 + 12), 16 * *(_DWORD *)(a2 + 28), 16 * a1);
  v4 = *(_DWORD *)(a2 + 28);
  *(_DWORD *)(a2 + 12) = result;
  if ( v4 < a1 )
  {
    result = (char *)(16 * v4);
    v5 = a1 - v4;
    do
    {
      *(_DWORD *)&result[*(_DWORD *)(a2 + 12)] = 0;
      result += 16;
      --v5;
    }
    while ( v5 );
  }
  *(_DWORD *)(a2 + 28) = a1;
  return result;
}

//----- (10019B80) --------------------------------------------------------
int __usercall sub_10019B80@<eax>(_DWORD *a1@<ebx>, int a2@<esi>, int a3)
{
  int v3; // edi
  int v4; // eax
  int v5; // ecx
  int v6; // edx
  int result; // eax
  int v8; // [esp+0h] [ebp-8h]

  v3 = 1 << a3;
  if ( a3 > 24 )
    sub_1001B4B0(a1, "table overflow", v8);
  if ( a3 )
  {
    *(_DWORD *)(a2 + 16) = sub_1001B810(a1, 0, 0, 40 * v3);
    if ( v3 > 0 )
    {
      v4 = 0;
      v5 = 1 << a3;
      do
      {
        *(_DWORD *)(*(_DWORD *)(a2 + 16) + v4 + 32) = 0;
        *(_DWORD *)(v4 + *(_DWORD *)(a2 + 16)) = 0;
        *(_DWORD *)(*(_DWORD *)(a2 + 16) + v4 + 16) = 0;
        v4 += 40;
        --v5;
      }
      while ( v5 );
    }
  }
  else
  {
    *(_DWORD *)(a2 + 16) = a1[4] + 88;
  }
  v6 = *(_DWORD *)(a2 + 16);
  *(_BYTE *)(a2 + 7) = a3;
  result = v6 + 40 * v3 - 40;
  *(_DWORD *)(a2 + 20) = result;
  return result;
}
// 10019B98: variable 'v8' is possibly undefined

//----- (10019C10) --------------------------------------------------------
_DWORD *__cdecl sub_10019C10(_DWORD *a1, int a2, int a3)
{
  _DWORD *v3; // esi

  v3 = sub_1001B810(a1, 0, 0, 0x20u);
  sub_10016E80((int)a1, (int)v3, 5);
  v3[2] = *(_DWORD *)(a1[4] + 72);
  *((_BYTE *)v3 + 6) = -1;
  v3[3] = 0;
  v3[7] = 0;
  *((_BYTE *)v3 + 7) = 0;
  v3[4] = 0;
  sub_10019B30(a2, (int)v3, a1);
  sub_10019B80(a1, (int)v3, a3);
  return v3;
}

//----- (10019C70) --------------------------------------------------------
void *__cdecl sub_10019C70(_DWORD *a1, int a2)
{
  char v2; // cl

  v2 = *(_BYTE *)(a2 + 7);
  if ( v2 )
    sub_1001B810(a1, *(void **)(a2 + 16), 40 * (1 << v2), 0);
  sub_1001B810(a1, *(void **)(a2 + 12), 16 * *(_DWORD *)(a2 + 28), 0);
  return sub_1001B810(a1, (void *)a2, 32, 0);
}

//----- (10019CD0) --------------------------------------------------------
void *__usercall sub_10019CD0@<eax>(_DWORD *a1@<edi>, int a2)
{
  int v3; // esi

  if ( !*a1 )
    return &unk_1003F368;
  v3 = sub_10019890(a2, (int)a1);
  while ( !sub_10018E20(v3, (int)a1) )
  {
    v3 = *(_DWORD *)(v3 + 32);
    if ( !v3 )
      return &unk_1003F368;
  }
  return (void *)(v3 + 16);
}

//----- (10019D20) --------------------------------------------------------
void *__cdecl sub_10019D20(int a1, int a2)
{
  double v3; // st7
  unsigned int v4; // ecx
  double v5; // [esp+4h] [ebp-8h]

  if ( a2 >= 1 && a2 <= *(_DWORD *)(a1 + 28) )
    return (void *)(*(_DWORD *)(a1 + 12) + 16 * a2 - 16);
  v3 = (double)a2;
  v5 = v3 + 1.0;
  v4 = *(_DWORD *)(a1 + 16) + 40 * ((HIDWORD(v5) + LODWORD(v5)) % (((1 << *(_BYTE *)(a1 + 7)) - 1) | 1u));
  while ( *(_DWORD *)v4 != 3 || *(double *)(v4 + 8) != v3 )
  {
    v4 = *(_DWORD *)(v4 + 32);
    if ( !v4 )
      return &unk_1003F368;
  }
  return (void *)(v4 + 16);
}

//----- (10019DB0) --------------------------------------------------------
_DWORD *__cdecl sub_10019DB0(int a1, int a2)
{
  _DWORD *v2; // eax

  v2 = (_DWORD *)(*(_DWORD *)(a1 + 16) + 40 * (*(_DWORD *)(a2 + 8) & ((1 << *(_BYTE *)(a1 + 7)) - 1)));
  while ( *v2 != 4 || v2[2] != a2 )
  {
    v2 = (_DWORD *)v2[8];
    if ( !v2 )
      return &unk_1003F368;
  }
  return v2 + 4;
}

//----- (10019DF0) --------------------------------------------------------
_DWORD *__cdecl sub_10019DF0(int a1, double *a2)
{
  int v3; // ecx

  if ( *(_DWORD *)a2 == 3 )
  {
    v3 = (unsigned __int64)a2[1];
    if ( a2[1] == (double)v3 )
      return sub_10019D20(a1, v3);
  }
  else if ( *(_DWORD *)a2 == 4 )
  {
    return sub_10019DB0(a1, *((_DWORD *)a2 + 2));
  }
  return sub_10019CD0(a2, a1);
}

//----- (10019E50) --------------------------------------------------------
_DWORD *__cdecl sub_10019E50(_DWORD *a1, int a2, double *a3)
{
  _DWORD *result; // eax
  int v4; // [esp-4h] [ebp-Ch]

  result = sub_10019DF0(a2, a3);
  *(_BYTE *)(a2 + 6) = 0;
  if ( result == (_DWORD *)&unk_1003F368 )
  {
    if ( !*(_DWORD *)a3 )
      sub_1001B4B0(a1, "table index is nil", v4);
    return sub_1001A2E0(a1, a2, (unsigned int)a3);
  }
  return result;
}
// 10019E9C: variable 'v4' is possibly undefined

//----- (10019EC0) --------------------------------------------------------
unsigned int __usercall sub_10019EC0@<eax>(double *a1@<eax>, int a2@<edi>, _DWORD *a3)
{
  int v4; // eax
  unsigned int result; // eax
  int v6; // ecx
  _DWORD *v7; // eax
  int v8; // [esp+0h] [ebp-8h]

  v4 = *(_DWORD *)a1;
  if ( !v4 )
    return -1;
  if ( v4 != 3
    || (v6 = (unsigned __int64)a1[1], a1[1] != (double)v6)
    || v6 < 1
    || (result = v6 - 1, ((v6 - 1) & 0xFF000000) != 0)
    || v6 > *(_DWORD *)(a2 + 28) )
  {
    v7 = sub_10019DF0(a2, a1);
    if ( v7 == (_DWORD *)&unk_1003F368 )
      sub_1001B4B0(a3, "invalid key for `next'", v8);
    return *(_DWORD *)(a2 + 28) + ((unsigned int)v7 - *(_DWORD *)(a2 + 16) - 16) / 0x28;
  }
  return result;
}
// 10019F04: conditional instruction was optimized away because ecx.4>=1
// 10019F29: variable 'v8' is possibly undefined

//----- (10019F50) --------------------------------------------------------
int __cdecl sub_10019F50(_DWORD *a1, int a2, int a3)
{
  unsigned int v3; // eax
  int v4; // edx
  signed int v5; // eax
  _DWORD *v6; // ecx
  int v7; // eax
  int v8; // edx
  int v9; // ecx
  _DWORD *i; // ebx
  double v12; // st7
  int v13; // eax
  int v14; // ecx
  int v15; // edx
  int v16; // eax
  int v17; // eax
  int v18; // edx
  int v19; // ecx
  int v20; // eax

  v3 = sub_10019EC0((double *)a3, a2, a1);
  v4 = *(_DWORD *)(a2 + 28);
  v5 = v3 + 1;
  if ( v5 >= v4 )
  {
LABEL_5:
    v7 = v5 - v4;
    v8 = 1 << *(_BYTE *)(a2 + 7);
    if ( v7 >= v8 )
    {
      return 0;
    }
    else
    {
      v9 = *(_DWORD *)(a2 + 16);
      for ( i = (_DWORD *)(v9 + 40 * v7 + 16); !*i; i += 10 )
      {
        if ( ++v7 >= v8 )
          return 0;
      }
      v17 = 40 * v7;
      *(_DWORD *)a3 = *(_DWORD *)(v9 + v17);
      *(_DWORD *)(a3 + 8) = *(_DWORD *)(v9 + v17 + 8);
      *(_DWORD *)(a3 + 12) = *(_DWORD *)(v9 + v17 + 12);
      v18 = *(_DWORD *)(a2 + 16);
      v19 = *(_DWORD *)(v18 + v17 + 16);
      v20 = v18 + v17 + 16;
      *(_DWORD *)(a3 + 16) = v19;
      *(_DWORD *)(a3 + 24) = *(_DWORD *)(v20 + 8);
      *(_DWORD *)(a3 + 28) = *(_DWORD *)(v20 + 12);
      return 1;
    }
  }
  else
  {
    v6 = (_DWORD *)(*(_DWORD *)(a2 + 12) + 16 * v5);
    while ( !*v6 )
    {
      ++v5;
      v6 += 4;
      if ( v5 >= v4 )
        goto LABEL_5;
    }
    v12 = (double)(v5 + 1);
    *(_DWORD *)a3 = 3;
    v13 = 16 * v5;
    *(double *)(a3 + 8) = v12;
    v14 = *(_DWORD *)(a2 + 12);
    v15 = *(_DWORD *)(v13 + v14);
    v16 = v14 + v13;
    *(_DWORD *)(a3 + 16) = v15;
    *(_DWORD *)(a3 + 24) = *(_DWORD *)(v16 + 8);
    *(_DWORD *)(a3 + 28) = *(_DWORD *)(v16 + 12);
    return 1;
  }
}

//----- (1001A030) --------------------------------------------------------
void *__cdecl sub_1001A030(_DWORD *a1, int a2, int a3, int a4)
{
  void *v5; // eax
  int v6; // edx
  int v8; // ecx
  size_t v9; // ebx
  int v10; // edi
  _DWORD *v11; // esi
  _DWORD *v12; // eax
  int v13; // edx
  int v14; // eax
  char *v15; // ebx
  char *v16; // edi
  _DWORD *v17; // eax
  _DWORD *v18; // eax
  int v19; // ecx
  int v20; // esi
  void *result; // eax
  int v22; // [esp+0h] [ebp-54h]
  char *v23; // [esp+10h] [ebp-44h]
  int v24; // [esp+14h] [ebp-40h]
  void *v25; // [esp+18h] [ebp-3Ch]
  int v26; // [esp+1Ch] [ebp-38h] BYREF
  double v27; // [esp+24h] [ebp-30h]
  char v28[40]; // [esp+2Ch] [ebp-28h] BYREF
  int v29; // [esp+5Ch] [ebp+8h]
  int v30; // [esp+60h] [ebp+Ch]
  int v31; // [esp+60h] [ebp+Ch]

  v5 = (void *)*(unsigned __int8 *)(a2 + 7);
  v6 = *(_DWORD *)(a2 + 28);
  v24 = v6;
  v25 = v5;
  if ( v5 )
  {
    v23 = *(char **)(a2 + 16);
  }
  else
  {
    qmemcpy(v28, *(const void **)(a2 + 16), sizeof(v28));
    v23 = v28;
    *(_DWORD *)(a1[4] + 88) = 0;
    *(_DWORD *)(a1[4] + 104) = 0;
  }
  if ( a3 > v6 )
    sub_10019B30(a3, a2, a1);
  sub_10019B80(a1, a2, a4);
  v8 = v24;
  if ( a3 < v24 )
  {
    v9 = 16 * a3;
    *(_DWORD *)(a2 + 28) = a3;
    v30 = a3 + 1;
    v29 = 16 * a3;
    v10 = v8 - a3;
    do
    {
      v11 = (_DWORD *)(*(_DWORD *)(a2 + 12) + v29);
      if ( *v11 )
      {
        v12 = sub_10019D20(a2, v30);
        if ( v12 == (_DWORD *)&unk_1003F368 )
        {
          v27 = (double)v30;
          v26 = 3;
          v12 = sub_1001A2E0(a1, a2, (unsigned int)&v26);
        }
        *v12 = *v11;
        v12[2] = v11[2];
        v12[3] = v11[3];
        v8 = v24;
      }
      --v10;
      v29 += 16;
      ++v30;
    }
    while ( v10 );
    *(_DWORD *)(a2 + 12) = sub_1001B810(a1, *(void **)(a2 + 12), 16 * v8, v9);
  }
  v13 = 1 << (char)v25;
  v14 = (1 << (char)v25) - 1;
  v24 = 1 << (char)v25;
  if ( v14 >= 0 )
  {
    v15 = &v23[40 * v14 + 8];
    v31 = 1 << (char)v25;
    while ( 1 )
    {
      v16 = v15 - 8;
      if ( *((_DWORD *)v15 + 2) )
        break;
LABEL_38:
      v15 -= 40;
      if ( !--v31 )
        goto LABEL_39;
    }
    if ( *(_DWORD *)v16 == 3 )
    {
      v19 = (unsigned __int64)*(double *)v15;
      if ( *(double *)v15 == (double)v19 )
      {
        v18 = sub_10019D20(a2, v19);
LABEL_24:
        *(_BYTE *)(a2 + 6) = 0;
        if ( v18 == (_DWORD *)&unk_1003F368 )
        {
          if ( !*(_DWORD *)v16 )
            sub_1001B4B0(a1, "table index is nil", v22);
          v18 = sub_1001A2E0(a1, a2, (unsigned int)(v15 - 8));
        }
        *v18 = *((_DWORD *)v15 + 2);
        v18[2] = *((_DWORD *)v15 + 4);
        v18[3] = *((_DWORD *)v15 + 5);
        v13 = v24;
        goto LABEL_38;
      }
    }
    else if ( *(_DWORD *)v16 == 4 )
    {
      v17 = (_DWORD *)(*(_DWORD *)(a2 + 16) + 40 * (*(_DWORD *)(*(_DWORD *)v15 + 8) & ((1 << *(_BYTE *)(a2 + 7)) - 1)));
      while ( *v17 != 4 || v17[2] != *(_DWORD *)v15 )
      {
        v17 = (_DWORD *)v17[8];
        if ( !v17 )
          goto LABEL_23;
      }
      v18 = v17 + 4;
      goto LABEL_24;
    }
    if ( *(_DWORD *)v16 )
    {
      v20 = sub_10019890(a2, (int)(v15 - 8));
      while ( !sub_10018E20(v20, (int)(v15 - 8)) )
      {
        v20 = *(_DWORD *)(v20 + 32);
        if ( !v20 )
          goto LABEL_23;
      }
      v18 = (_DWORD *)(v20 + 16);
    }
    else
    {
LABEL_23:
      v18 = &unk_1003F368;
    }
    goto LABEL_24;
  }
LABEL_39:
  result = v25;
  if ( v25 )
    return sub_1001B810(a1, v23, 40 * v13, 0);
  return result;
}
// 1001A26F: variable 'v22' is possibly undefined

//----- (1001A2E0) --------------------------------------------------------
_DWORD *__cdecl sub_1001A2E0(_DWORD *a1, int a2, unsigned int a3)
{
  int v3; // ebp
  unsigned int v4; // esi
  _DWORD *v5; // ebx
  unsigned int v6; // eax
  _DWORD *v7; // edi
  int v8; // ecx
  int v9; // eax
  _DWORD *result; // eax
  int v11; // eax

  v3 = a2;
  v4 = a3;
  v5 = (_DWORD *)sub_10019890(a2, a3);
  if ( v5[4] )
  {
    v6 = sub_10019890(v3, (int)v5);
    v7 = *(_DWORD **)(v3 + 20);
    if ( (_DWORD *)v6 == v5 )
    {
      v7[8] = v5[8];
      v5[8] = v7;
      v5 = v7;
    }
    else
    {
      for ( ; *(_DWORD **)(v6 + 32) != v5; v6 = *(_DWORD *)(v6 + 32) )
        ;
      *(_DWORD *)(v6 + 32) = v7;
      qmemcpy(v7, v5, 0x28u);
      v4 = a3;
      v5[8] = 0;
      v5[4] = 0;
    }
  }
  *v5 = *(_DWORD *)v4;
  v5[2] = *(_DWORD *)(v4 + 8);
  v5[3] = *(_DWORD *)(v4 + 12);
  if ( !**(_DWORD **)(v3 + 20) )
    return v5 + 4;
  v8 = *(_DWORD *)(v3 + 16);
  while ( 1 )
  {
    v9 = *(_DWORD *)(v3 + 20);
    if ( v9 == v8 )
      break;
    *(_DWORD *)(v3 + 20) = v9 - 40;
    if ( !*(_DWORD *)(v9 - 40) )
      return v5 + 4;
  }
  v5[4] = 1;
  v5[6] = 0;
  sub_100199F0(v3, &a2, &a3);
  v11 = sub_10018DC0(a3);
  sub_1001A030(a1, v3, a2, v11 + 1);
  result = sub_10019DF0(v3, (double *)v4);
  *result = 0;
  return result;
}

//----- (1001A3D0) --------------------------------------------------------
_DWORD *__cdecl sub_1001A3D0(_DWORD *a1, int a2, int a3)
{
  _DWORD *result; // eax
  int v4; // [esp+4h] [ebp-10h] BYREF
  double v5; // [esp+Ch] [ebp-8h]

  result = sub_10019D20(a2, a3);
  if ( result == (_DWORD *)&unk_1003F368 )
  {
    v5 = (double)a3;
    v4 = 3;
    return sub_1001A2E0(a1, a2, (unsigned int)&v4);
  }
  return result;
}

//----- (1001A420) --------------------------------------------------------
int __cdecl sub_1001A420(int a1)
{
  _DWORD *v1; // esi
  unsigned __int8 *v2; // eax
  int v3; // ecx
  int v4; // ecx

  v1 = (_DWORD *)a1;
  v2 = (unsigned __int8 *)(*(int (__cdecl **)(_DWORD, _DWORD, int *))(a1 + 8))(0, *(_DWORD *)(a1 + 12), &a1);
  if ( !v2 )
    return -1;
  v3 = a1;
  if ( !a1 )
    return -1;
  v1[1] = v2;
  *v1 = v3 - 1;
  v4 = *v2;
  v1[1] = v2 + 1;
  return v4;
}

//----- (1001A460) --------------------------------------------------------
int __cdecl sub_1001A460(int a1)
{
  _DWORD *v1; // esi
  int v2; // eax
  int v3; // ecx
  int v4; // eax

  v1 = (_DWORD *)a1;
  if ( !*(_DWORD *)a1 )
  {
    v2 = (*(int (__cdecl **)(_DWORD, _DWORD, int *))(a1 + 8))(0, *(_DWORD *)(a1 + 12), &a1);
    if ( !v2 || !a1 )
      return -1;
    v3 = a1 - 1;
    v1[1] = v2;
    *v1 = v3;
    v4 = v2 + 1;
    v1[1] = v4;
    *v1 = v3 + 1;
    v1[1] = v4 - 1;
  }
  return *(unsigned __int8 *)v1[1];
}
// 1001A497: conditional instruction was optimized away because edx.4<100u

//----- (1001A4B0) --------------------------------------------------------
_DWORD *__cdecl sub_1001A4B0(_DWORD *a1, int a2, int a3, int a4)
{
  _DWORD *result; // eax

  result = a1;
  a1[2] = a2;
  a1[3] = a3;
  a1[4] = a4;
  *a1 = 0;
  a1[1] = 0;
  return result;
}

//----- (1001A4E0) --------------------------------------------------------
unsigned int __cdecl sub_1001A4E0(int a1, char *a2, unsigned int a3)
{
  unsigned int v3; // ebp
  int v4; // eax
  unsigned int v5; // ecx
  int v6; // eax
  unsigned int v7; // eax
  unsigned int v8; // esi

  v3 = a3;
  if ( !a3 )
    return 0;
  while ( *(_DWORD *)a1 )
  {
LABEL_6:
    v7 = *(_DWORD *)a1;
    if ( v3 <= *(_DWORD *)a1 )
      v7 = v3;
    qmemcpy(a2, *(const void **)(a1 + 4), v7);
    v8 = v7 + *(_DWORD *)(a1 + 4);
    v3 -= v7;
    *(_DWORD *)a1 -= v7;
    *(_DWORD *)(a1 + 4) = v8;
    a2 += v7;
    if ( !v3 )
      return 0;
  }
  v4 = (*(int (__cdecl **)(_DWORD, _DWORD, unsigned int *))(a1 + 8))(0, *(_DWORD *)(a1 + 12), &a3);
  if ( v4 && a3 )
  {
    v5 = a3 - 1;
    *(_DWORD *)(a1 + 4) = v4;
    *(_DWORD *)a1 = v5;
    v6 = v4 + 1;
    *(_DWORD *)(a1 + 4) = v6;
    *(_DWORD *)a1 = v5 + 1;
    *(_DWORD *)(a1 + 4) = v6 - 1;
    goto LABEL_6;
  }
  return v3;
}
// 1001A522: conditional instruction was optimized away because edx.4<100u

//----- (1001A580) --------------------------------------------------------
void *__cdecl sub_1001A580(_DWORD *a1, void **a2, unsigned int a3)
{
  unsigned int v3; // eax
  size_t v4; // edi

  v3 = (unsigned int)a2[1];
  v4 = a3;
  if ( a3 > v3 )
  {
    if ( a3 < 0x20 )
      v4 = 32;
    *a2 = sub_1001B810(a1, *a2, v3, v4);
    a2[1] = (void *)v4;
  }
  return *a2;
}

//----- (1001A5C0) --------------------------------------------------------
int __usercall sub_1001A5C0@<eax>(int a1@<eax>, int *a2@<esi>)
{
  int v2; // ebx
  int v3; // edi
  int v5; // [esp-14h] [ebp-1Ch]
  int v6; // [esp-10h] [ebp-18h]
  int v7; // [esp-8h] [ebp-10h]
  int v8; // [esp-4h] [ebp-Ch]
  int v9; // [esp+4h] [ebp-4h] BYREF

  if ( !a1 || (v2 = a1 + 16, a1 == -16) )
  {
    v8 = a2[2];
    v6 = *a2;
    v9 = 0;
    return ((int (__cdecl *)(int, int *, int, int))a2[1])(v6, &v9, 4, v8);
  }
  else
  {
    v7 = a2[2];
    v5 = *a2;
    v9 = *(_DWORD *)(a1 + 12) + 1;
    v3 = v9;
    ((void (__cdecl *)(int, int *, int, int))a2[1])(v5, &v9, 4, v7);
    return ((int (__cdecl *)(_DWORD, int, int, int))a2[1])(*a2, v2, v3, a2[2]);
  }
}

//----- (1001A620) --------------------------------------------------------
int __usercall sub_1001A620@<eax>(_DWORD *a1@<esi>, int a2)
{
  int v2; // ebp
  int v3; // edi
  int result; // eax
  int v5; // ebx
  int v6; // eax
  int v7; // edi
  int v8; // [esp-18h] [ebp-28h]
  int v9; // [esp-14h] [ebp-24h]
  int v10; // [esp-14h] [ebp-24h]
  int v11; // [esp-10h] [ebp-20h]
  int v12; // [esp-8h] [ebp-18h]
  int v13; // [esp-8h] [ebp-18h]
  int v14; // [esp-8h] [ebp-18h]
  int v15; // [esp-4h] [ebp-14h]
  int v16; // [esp+8h] [ebp-8h] BYREF
  int v17; // [esp+Ch] [ebp-4h] BYREF

  v2 = a2;
  v15 = a1[2];
  v11 = *a1;
  a2 = *(_DWORD *)(a2 + 56);
  v3 = a2;
  result = ((int (__cdecl *)(int, int *, int, int))a1[1])(v11, &a2, 4, v15);
  if ( v3 > 0 )
  {
    v5 = 0;
    a2 = v3;
    do
    {
      v6 = *(_DWORD *)(v5 + *(_DWORD *)(v2 + 24));
      if ( !v6 || (v17 = v6 + 16, v6 == -16) )
      {
        v13 = a1[2];
        v10 = *a1;
        v17 = 0;
        ((void (__cdecl *)(int, int *, int, int))a1[1])(v10, &v17, 4, v13);
      }
      else
      {
        v12 = a1[2];
        v9 = *a1;
        v16 = *(_DWORD *)(v6 + 12) + 1;
        v7 = v16;
        ((void (__cdecl *)(int, int *, int, int))a1[1])(v9, &v16, 4, v12);
        ((void (__cdecl *)(_DWORD, int, int, _DWORD))a1[1])(*a1, v17, v7, a1[2]);
      }
      v14 = a1[2];
      v17 = *(_DWORD *)(*(_DWORD *)(v2 + 24) + v5 + 4);
      ((void (__cdecl *)(_DWORD, int *, int, int))a1[1])(*a1, &v17, 4, v14);
      v8 = a1[2];
      v17 = *(_DWORD *)(*(_DWORD *)(v2 + 24) + v5 + 8);
      ((void (__cdecl *)(_DWORD, int *, int, int))a1[1])(*a1, &v17, 4, v8);
      v5 += 12;
      result = --a2;
    }
    while ( a2 );
  }
  return result;
}

//----- (1001A710) --------------------------------------------------------
int __usercall sub_1001A710@<eax>(int *a1@<esi>, int a2)
{
  int v2; // edi
  int result; // eax
  int i; // ebp
  int v5; // eax
  int v6; // ebx
  int v7; // edi
  int v8; // [esp-14h] [ebp-24h]
  int v9; // [esp-14h] [ebp-24h]
  int v10; // [esp-10h] [ebp-20h]
  int v11; // [esp-8h] [ebp-18h]
  int v12; // [esp-8h] [ebp-18h]
  int v13; // [esp-4h] [ebp-14h]
  int v14; // [esp+8h] [ebp-8h] BYREF
  int v15; // [esp+Ch] [ebp-4h]

  v2 = *(_DWORD *)(a2 + 36);
  v13 = a1[2];
  v10 = *a1;
  v15 = v2;
  v14 = v2;
  result = ((int (__cdecl *)(int, int *, int, int))a1[1])(v10, &v14, 4, v13);
  for ( i = 0; i < v2; ++i )
  {
    v5 = *(_DWORD *)(*(_DWORD *)(a2 + 28) + 4 * i);
    if ( !v5 || (v6 = v5 + 16, v5 == -16) )
    {
      v12 = a1[2];
      v9 = *a1;
      v14 = 0;
      result = ((int (__cdecl *)(int, int *, int, int))a1[1])(v9, &v14, 4, v12);
    }
    else
    {
      v11 = a1[2];
      v8 = *a1;
      v14 = *(_DWORD *)(v5 + 12) + 1;
      v7 = v14;
      ((void (__cdecl *)(int, int *, int, int))a1[1])(v8, &v14, 4, v11);
      result = ((int (__cdecl *)(_DWORD, int, int, int))a1[1])(*a1, v6, v7, a1[2]);
      v2 = v15;
    }
  }
  return result;
}

//----- (1001A7B0) --------------------------------------------------------
int __usercall sub_1001A7B0@<eax>(int *a1@<esi>, _DWORD *a2)
{
  int v2; // edi
  int v3; // edi
  char v4; // dl
  int v5; // edi
  int v6; // edi
  int v7; // ebx
  int v8; // edi
  bool v9; // zf
  int v10; // ebx
  int result; // eax
  int i; // edi
  int v13; // [esp-10h] [ebp-30h]
  int v14; // [esp-10h] [ebp-30h]
  int v15; // [esp-10h] [ebp-30h]
  int v16; // [esp-4h] [ebp-24h]
  int v17; // [esp-4h] [ebp-24h]
  int v18; // [esp-4h] [ebp-24h]
  int v19; // [esp-4h] [ebp-24h]
  int v20; // [esp-4h] [ebp-24h]
  int v21; // [esp-4h] [ebp-24h]
  char v22; // [esp+Fh] [ebp-11h] BYREF
  int v23; // [esp+10h] [ebp-10h]
  int v24; // [esp+14h] [ebp-Ch] BYREF
  double v25; // [esp+18h] [ebp-8h] BYREF

  v16 = a1[2];
  v13 = *a1;
  v24 = a2[10];
  v2 = v24;
  ((void (__cdecl *)(int, int *, int, int))a1[1])(v13, &v24, 4, v16);
  if ( v2 > 0 )
  {
    v23 = 0;
    v24 = v2;
    do
    {
      v3 = a2[2];
      v4 = *(_BYTE *)(v3 + v23);
      v17 = a1[2];
      v5 = v23 + v3;
      v22 = v4;
      ((void (__cdecl *)(int, char *, int, int))a1[1])(*a1, &v22, 1, v17);
      if ( *(_DWORD *)v5 == 3 )
      {
        v20 = a1[2];
        v25 = *(double *)(v5 + 8);
        ((void (__cdecl *)(int, double *, int, int))a1[1])(*a1, &v25, 8, v20);
      }
      else if ( *(_DWORD *)v5 == 4 )
      {
        v6 = *(_DWORD *)(v5 + 8);
        if ( !v6 || (v7 = v6 + 16, v6 == -16) )
        {
          v19 = a1[2];
          LODWORD(v25) = 0;
          ((void (__cdecl *)(int, double *, int, int))a1[1])(*a1, &v25, 4, v19);
        }
        else
        {
          v18 = a1[2];
          v8 = *(_DWORD *)(v6 + 12) + 1;
          v14 = *a1;
          LODWORD(v25) = v8;
          ((void (__cdecl *)(int, double *, int, int))a1[1])(v14, &v25, 4, v18);
          ((void (__cdecl *)(int, int, int, int))a1[1])(*a1, v7, v8, a1[2]);
        }
      }
      v9 = v24 == 1;
      v23 += 16;
      --v24;
    }
    while ( !v9 );
  }
  v21 = a1[2];
  v15 = *a1;
  LODWORD(v25) = a2[13];
  v10 = LODWORD(v25);
  result = ((int (__cdecl *)(int, double *, int, int))a1[1])(v15, &v25, 4, v21);
  for ( i = 0; i < v10; ++i )
    result = sub_1001A8F0(*(_DWORD *)(a2[4] + 4 * i), a2[8], a1);
  return result;
}

//----- (1001A8F0) --------------------------------------------------------
int __cdecl sub_1001A8F0(int a1, int a2, int *a3)
{
  int *v3; // esi
  int v4; // edi
  int v6; // [esp-40h] [ebp-48h]
  int v7; // [esp-34h] [ebp-3Ch]
  int v8; // [esp-24h] [ebp-2Ch]
  int v9; // [esp-14h] [ebp-1Ch]
  int v10; // [esp-14h] [ebp-1Ch]
  int v11; // [esp-4h] [ebp-Ch]
  int v12; // [esp-4h] [ebp-Ch]

  v3 = a3;
  v4 = a1;
  sub_1001A5C0(*(_DWORD *)(a1 + 32) == a2 ? 0 : *(_DWORD *)(a1 + 32), a3);
  v11 = v3[2];
  a1 = *(_DWORD *)(v4 + 60);
  ((void (__cdecl *)(int, int *, int, int))v3[1])(*v3, &a1, 4, v11);
  v9 = v3[2];
  LOBYTE(a1) = *(_BYTE *)(v4 + 68);
  ((void (__cdecl *)(int, int *, int, int))v3[1])(*v3, &a1, 1, v9);
  v8 = v3[2];
  LOBYTE(a1) = *(_BYTE *)(v4 + 69);
  ((void (__cdecl *)(int, int *, int, int))v3[1])(*v3, &a1, 1, v8);
  v7 = v3[2];
  LOBYTE(a1) = *(_BYTE *)(v4 + 70);
  ((void (__cdecl *)(int, int *, int, int))v3[1])(*v3, &a1, 1, v7);
  v12 = v3[2];
  LOBYTE(a1) = *(_BYTE *)(v4 + 71);
  ((void (__cdecl *)(int, int *, int, int))v3[1])(*v3, &a1, 1, v12);
  v10 = v3[2];
  a1 = *(_DWORD *)(v4 + 48);
  ((void (__cdecl *)(int, int *, int, int))v3[1])(*v3, &a1, 4, v10);
  ((void (__cdecl *)(int, _DWORD, int, int))v3[1])(*v3, *(_DWORD *)(v4 + 20), 4 * *(_DWORD *)(v4 + 48), v3[2]);
  sub_1001A620(v3, v4);
  sub_1001A710(v3, v4);
  sub_1001A7B0(v3, (_DWORD *)v4);
  v6 = v3[2];
  a1 = *(_DWORD *)(v4 + 44);
  ((void (__cdecl *)(int, int *, int, int))v3[1])(*v3, &a1, 4, v6);
  return ((int (__cdecl *)(int, _DWORD, int, int))v3[1])(*v3, *(_DWORD *)(v4 + 12), 4 * *(_DWORD *)(v4 + 44), v3[2]);
}

//----- (1001AA00) --------------------------------------------------------
int __usercall sub_1001AA00@<eax>(_DWORD *a1@<esi>)
{
  char v1; // al
  int v2; // ecx
  int v3; // edx
  int v5; // [esp-40h] [ebp-50h]
  int v6; // [esp-40h] [ebp-50h]
  int v7; // [esp-34h] [ebp-44h]
  int v8; // [esp-34h] [ebp-44h]
  int v9; // [esp-30h] [ebp-40h]
  int v10; // [esp-30h] [ebp-40h]
  int v11; // [esp-24h] [ebp-34h]
  int v12; // [esp-24h] [ebp-34h]
  int v13; // [esp-24h] [ebp-34h]
  int v14; // [esp-20h] [ebp-30h]
  int v15; // [esp-20h] [ebp-30h]
  int v16; // [esp-20h] [ebp-30h]
  int v17; // [esp-14h] [ebp-24h]
  int v18; // [esp-14h] [ebp-24h]
  int v19; // [esp-14h] [ebp-24h]
  int v20; // [esp-10h] [ebp-20h]
  int v21; // [esp-4h] [ebp-14h]
  int v22; // [esp-4h] [ebp-14h]
  char v23; // [esp+7h] [ebp-9h] BYREF
  double v24; // [esp+8h] [ebp-8h] BYREF

  ((void (__cdecl *)(_DWORD, const char *, int, _DWORD))a1[1])(*a1, "\x1BLua", 4, a1[2]);
  v17 = a1[2];
  v14 = *a1;
  v23 = 80;
  ((void (__cdecl *)(int, char *, int, int))a1[1])(v14, &v23, 1, v17);
  v1 = sub_10020580();
  v2 = *a1;
  v11 = a1[2];
  v23 = v1;
  ((void (__cdecl *)(int, char *, int, int))a1[1])(v2, &v23, 1, v11);
  v7 = a1[2];
  v5 = *a1;
  v23 = 4;
  ((void (__cdecl *)(int, char *, int, int))a1[1])(v5, &v23, 1, v7);
  v21 = a1[2];
  v20 = *a1;
  v23 = 4;
  ((void (__cdecl *)(int, char *, int, int))a1[1])(v20, &v23, 1, v21);
  v18 = a1[2];
  v15 = *a1;
  v23 = 4;
  ((void (__cdecl *)(int, char *, int, int))a1[1])(v15, &v23, 1, v18);
  v12 = a1[2];
  v9 = *a1;
  v23 = 6;
  ((void (__cdecl *)(int, char *, int, int))a1[1])(v9, &v23, 1, v12);
  v8 = a1[2];
  v6 = *a1;
  v23 = 8;
  ((void (__cdecl *)(int, char *, int, int))a1[1])(v6, &v23, 1, v8);
  v22 = a1[2];
  v23 = 9;
  ((void (__cdecl *)(_DWORD, char *, int, int))a1[1])(*a1, &v23, 1, v22);
  v19 = a1[2];
  v16 = *a1;
  v23 = 9;
  ((void (__cdecl *)(int, char *, int, int))a1[1])(v16, &v23, 1, v19);
  v13 = a1[2];
  v10 = *a1;
  v23 = 8;
  ((void (__cdecl *)(int, char *, int, int))a1[1])(v10, &v23, 1, v13);
  v3 = a1[2];
  v24 = 31415926.53589793;
  return ((int (__cdecl *)(_DWORD, double *, int, int))a1[1])(*a1, &v24, 8, v3);
}

//----- (1001AB20) --------------------------------------------------------
int __cdecl sub_1001AB20(int a1, int a2, int a3, int a4)
{
  int v5[3]; // [esp+4h] [ebp-Ch] BYREF

  v5[0] = a1;
  v5[1] = a3;
  v5[2] = a4;
  sub_1001AA00(v5);
  return sub_1001A8F0(a2, 0, v5);
}

//----- (1001AB60) --------------------------------------------------------
int __usercall sub_1001AB60@<eax>(int a1@<eax>)
{
  int v1; // ecx
  int v2; // ecx
  int v3; // eax
  int v5; // ecx

  v1 = *(_DWORD *)(a1 + 8);
  if ( (v1 & 1) != 0 )
    return -1;
  if ( (v1 & 2) != 0 )
    *(_DWORD *)(a1 + 12) = **(_DWORD **)(a1 + 16);
  v2 = *(_DWORD *)(*(_DWORD *)(*(_DWORD *)a1 - 8) + 12);
  v3 = ((*(_DWORD *)(a1 + 12) - *(_DWORD *)(v2 + 12)) >> 2) - 1;
  if ( v3 < 0 )
    return -1;
  v5 = *(_DWORD *)(v2 + 20);
  if ( v5 )
    return *(_DWORD *)(v5 + 4 * v3);
  else
    return 0;
}

//----- (1001ABA0) --------------------------------------------------------
int __cdecl sub_1001ABA0(int a1)
{
  int result; // eax
  int v2; // ecx

  for ( result = *(_DWORD *)(a1 + 20); result != *(_DWORD *)(a1 + 40); result -= 24 )
  {
    v2 = *(_DWORD *)(result + 8);
    if ( (v2 & 1) == 0 && (v2 & 2) != 0 )
      *(_DWORD *)(result + 12) = **(_DWORD **)(result + 16);
  }
  *(_BYTE *)(a1 + 50) = 1;
  return result;
}

//----- (1001ABE0) --------------------------------------------------------
int __cdecl sub_1001ABE0(int a1, int a2, int a3)
{
  int v3; // ecx
  unsigned int v4; // eax
  int v5; // edx
  int result; // eax
  unsigned int v7; // edx

  v3 = a2;
  v4 = *(_DWORD *)(a1 + 20);
  if ( a2 > 0 )
  {
    while ( v4 > *(_DWORD *)(a1 + 40) )
    {
      --v3;
      if ( (*(_BYTE *)(v4 + 8) & 1) == 0 )
        v3 -= *(_DWORD *)(v4 + 20);
      v4 -= 24;
      if ( v3 <= 0 )
        goto LABEL_8;
    }
    if ( v3 > 0 )
      return 0;
  }
LABEL_8:
  v5 = *(_DWORD *)(a1 + 40);
  if ( v4 == v5 )
    return 0;
  if ( v3 >= 0 )
  {
    v7 = (int)((unsigned __int64)(715827883i64 * (int)(v4 - v5)) >> 32) >> 2;
    *(_DWORD *)(a3 + 92) = v7 + (v7 >> 31);
    return 1;
  }
  else
  {
    result = 1;
    *(_DWORD *)(a3 + 92) = 0;
  }
  return result;
}

//----- (1001AC60) --------------------------------------------------------
char __usercall sub_1001AC60@<al>(int a1@<eax>, int a2@<ecx>)
{
  int v2; // eax
  char *v3; // edx
  int v5; // eax
  bool v6; // zf
  const char *v7; // eax
  char *v8; // edx

  v2 = *(_DWORD *)(a1 + 8);
  if ( *(_BYTE *)(v2 + 6) )
  {
    *(_DWORD *)(a2 + 16) = "=[C]";
    v3 = *(char **)(a2 + 16);
    *(_DWORD *)(a2 + 28) = -1;
    *(_DWORD *)(a2 + 12) = "C";
    return sub_10019220((char *)(a2 + 32), v3, 0x3Cu);
  }
  else
  {
    *(_DWORD *)(a2 + 16) = *(_DWORD *)(*(_DWORD *)(v2 + 12) + 32) + 16;
    v5 = *(_DWORD *)(*(_DWORD *)(v2 + 12) + 60);
    *(_DWORD *)(a2 + 28) = v5;
    v6 = v5 == 0;
    v7 = "main";
    if ( !v6 )
      v7 = "Lua";
    v8 = *(char **)(a2 + 16);
    *(_DWORD *)(a2 + 12) = v7;
    return sub_10019220((char *)(a2 + 32), v8, 0x3Cu);
  }
}

//----- (1001ACD0) --------------------------------------------------------
int __usercall sub_1001ACD0@<eax>(int a1@<eax>, int a2)
{
  int v2; // ebp
  int v3; // edi
  int v4; // ebx
  _DWORD *v5; // esi

  v2 = *(_DWORD *)(a1 + 72);
  v3 = 1 << *(_BYTE *)(v2 + 7);
  if ( !v3 )
    return 0;
  v4 = 40 * v3;
  while ( 1 )
  {
    v4 -= 40;
    v5 = (_DWORD *)(v4 + *(_DWORD *)(v2 + 16));
    --v3;
    if ( sub_10018E20(a2, (int)(v5 + 4)) )
    {
      if ( *v5 == 4 )
        break;
    }
    if ( !v3 )
      return 0;
  }
  return v5[2] + 16;
}

//----- (1001AD30) --------------------------------------------------------
int __usercall sub_1001AD30@<eax>(int a1@<esi>, int a2)
{
  int result; // eax

  *(_DWORD *)(a1 + 8) = byte_1003D986;
  *(_DWORD *)(a1 + 4) = byte_1003D986;
  *(_DWORD *)(a1 + 20) = -1;
  *(_DWORD *)(a1 + 28) = -1;
  *(_DWORD *)(a1 + 12) = "tail";
  *(_DWORD *)(a1 + 16) = "=(tail call)";
  LOBYTE(result) = sub_10019220((char *)(a1 + 32), "=(tail call)", 0x3Cu);
  *(_DWORD *)(a1 + 24) = 0;
  **(_DWORD **)(a2 + 8) = 0;
  return result;
}

//----- (1001AD80) --------------------------------------------------------
BOOL __usercall sub_1001AD80@<eax>(int a1@<eax>, int a2@<edx>)
{
  int v2; // eax

  v2 = *(_DWORD *)(*(_DWORD *)(a1 + 12) + 4 * a2 + 4);
  if ( (v2 & 0x3Fu) >= 0x19 )
  {
    if ( (v2 & 0x3Fu) <= 0x1B )
      return (v2 & 0xFF8000) == 0;
    if ( (v2 & 0x3F) == 32 )
      return 1;
  }
  return 0;
}

//----- (1001ADB0) --------------------------------------------------------
BOOL __usercall sub_1001ADB0@<eax>(int a1@<eax>, int a2@<ecx>)
{
  return a1 < *(unsigned __int8 *)(a2 + 71) || a1 >= 250 && a1 - 250 < *(_DWORD *)(a2 + 40);
}

//----- (1001ADE0) --------------------------------------------------------
int __cdecl sub_1001ADE0(int a1, int a2, int a3)
{
  int v3; // ecx
  unsigned __int8 v4; // bl
  int v5; // edx
  int v6; // eax
  int v8; // ecx
  unsigned int v9; // eax
  int v10; // ecx
  int v11; // edi
  int v12; // esi
  int v13; // ebp
  char v14; // bl
  bool v15; // cc
  int v16; // eax
  int v17; // edx
  int v18; // edi
  int v19; // eax
  int v20; // ebp
  int v21; // esi
  int v22; // ecx
  _DWORD *v23; // edx
  int v24; // eax
  int v25; // [esp+4h] [ebp-18h]
  int v26; // [esp+8h] [ebp-14h]
  int v27; // [esp+Ch] [ebp-10h]
  int v28; // [esp+10h] [ebp-Ch]
  int v29; // [esp+14h] [ebp-8h]
  int v30; // [esp+18h] [ebp-4h]

  v3 = *(_DWORD *)(a1 + 44);
  v4 = *(_BYTE *)(a1 + 71);
  v28 = v3;
  v27 = v3 - 1;
  if ( v4 > 0xFAu )
    return 0;
  v5 = *(_DWORD *)(a1 + 48);
  if ( v5 != v3 )
  {
    if ( v5 )
      return 0;
  }
  v6 = *(_DWORD *)(a1 + 12);
  v29 = v6;
  if ( (*(_BYTE *)(v6 + 4 * v3 - 4) & 0x3F) != 27 )
    return 0;
  v8 = 0;
  v25 = 0;
  if ( a2 > 0 )
  {
    v26 = v4;
    while ( 2 )
    {
      v9 = *(_DWORD *)(v6 + 4 * v8);
      v10 = v9 & 0x3F;
      v11 = HIBYTE(v9);
      v12 = 0;
      v13 = 0;
      v30 = v10;
      if ( (int)HIBYTE(v9) >= v26 )
        return 0;
      v14 = byte_1003FC04[v10];
      if ( (v14 & 3) != 0 )
      {
        if ( (byte_1003FC04[v10] & 3) != 1 )
        {
          if ( (byte_1003FC04[v10] & 3) == 2 )
            v12 = ((v9 >> 6) & 0x3FFFF) - 0x1FFFF;
          goto LABEL_27;
        }
        v12 = (v9 >> 6) & 0x3FFFF;
        if ( (v14 & 0x40) == 0 )
        {
LABEL_27:
          v17 = v25;
          v16 = v26;
          goto LABEL_28;
        }
        v15 = v12 < *(_DWORD *)(a1 + 40);
      }
      else
      {
        v12 = (v9 >> 15) & 0x1FF;
        v13 = (v9 >> 6) & 0x1FF;
        if ( (v14 & 4) != 0 )
        {
          v16 = v26;
          if ( v12 >= v26 )
            return 0;
        }
        else
        {
          if ( (v14 & 8) != 0 )
          {
            if ( !sub_1001ADB0(v12, a1) )
              return 0;
            v10 = v30;
          }
          v16 = v26;
        }
        v17 = v25;
        if ( (v14 & 0x10) == 0 || v13 < v16 )
        {
LABEL_28:
          if ( (v14 & 0x20) != 0 && v11 == a3 )
            v27 = v17;
          if ( v14 >= 0 || v17 + 2 < v28 && (v17 = v25, (*(_BYTE *)(v29 + 4 * v25 + 4) & 0x3F) == 20) )
          {
            switch ( v10 )
            {
              case 2:
                if ( v13 && v17 + 2 >= v28 )
                  return 0;
                goto LABEL_82;
              case 3:
                if ( v11 <= a3 && a3 <= v12 )
                  v27 = v17;
                goto LABEL_82;
              case 4:
              case 8:
                if ( v12 >= *(unsigned __int8 *)(a1 + 68) )
                  return 0;
                goto LABEL_82;
              case 5:
              case 7:
                if ( *(_DWORD *)(16 * v12 + *(_DWORD *)(a1 + 8)) != 4 )
                  return 0;
                goto LABEL_82;
              case 11:
                v18 = v11 + 1;
                if ( v18 >= v16 )
                  return 0;
                if ( a3 == v18 )
                  v27 = v17;
                goto LABEL_82;
              case 19:
                if ( v13 >= 250 || v12 >= v13 )
                  return 0;
                goto LABEL_82;
              case 20:
                goto LABEL_55;
              case 25:
              case 26:
                if ( v12 && v12 + v11 - 1 >= v16 )
                  return 0;
                v20 = v13 - 1;
                if ( v20 == -1 )
                {
                  if ( !sub_1001AD80(a1, v25) )
                    return 0;
                }
                else if ( v20 && v11 + v20 - 1 >= v16 )
                {
                  return 0;
                }
                if ( a3 >= v11 )
                  v27 = v17;
LABEL_82:
                v8 = v25 + 1;
                v15 = v25 + 1 < a2;
                v6 = v29;
                ++v25;
                if ( !v15 )
                  return *(_DWORD *)(v6 + 4 * v27);
                continue;
              case 27:
                v21 = v12 - 1;
                if ( v21 > 0 && v21 + v11 - 1 >= v16 )
                  return 0;
                goto LABEL_82;
              case 28:
                goto LABEL_54;
              case 29:
                if ( v11 + v13 + 5 >= v16 )
                  return 0;
                if ( a3 >= v11 )
                  v27 = v17;
LABEL_54:
                if ( v11 + 2 >= v16 )
                  return 0;
LABEL_55:
                v19 = v12 + v17 + 1;
                if ( v19 < 0 || v19 >= v28 )
                  return 0;
                if ( a3 != 255 && v17 < v19 && v19 <= a2 )
                  v25 = v17 + v12;
                goto LABEL_82;
              case 31:
                if ( (v12 & 0x1F) + v11 + 1 >= v16 )
                  return 0;
                goto LABEL_82;
              case 34:
                if ( v12 >= *(_DWORD *)(a1 + 52) )
                  return 0;
                v22 = *(unsigned __int8 *)(*(_DWORD *)(*(_DWORD *)(a1 + 16) + 4 * v12) + 68);
                if ( v22 + v17 >= v28 )
                  return 0;
                if ( !*(_BYTE *)(*(_DWORD *)(*(_DWORD *)(a1 + 16) + 4 * v12) + 68) )
                  goto LABEL_82;
                v23 = (_DWORD *)(v29 + 4 * (v22 + v17));
                while ( 1 )
                {
                  v24 = *v23 & 0x3F;
                  if ( v24 != 4 )
                  {
                    if ( v24 )
                      return 0;
                  }
                  --v22;
                  --v23;
                  if ( v22 <= 0 )
                    goto LABEL_82;
                }
              default:
                goto LABEL_82;
            }
          }
          return 0;
        }
        if ( v13 < 250 )
          return 0;
        v15 = v13 - 250 < *(_DWORD *)(a1 + 40);
      }
      break;
    }
    if ( !v15 )
      return 0;
    goto LABEL_27;
  }
  return *(_DWORD *)(v6 + 4 * v27);
}
// 1001B0A5: variable 'v17' is possibly undefined

//----- (1001B1A0) --------------------------------------------------------
int __cdecl sub_1001B1A0(int a1)
{
  return sub_1001ADE0(a1, *(_DWORD *)(a1 + 44), 255);
}

//----- (1001B1C0) --------------------------------------------------------
void *__usercall sub_1001B1C0@<eax>(int a1@<eax>, int a2@<ecx>)
{
  int v2; // eax
  int v3; // edx
  int v4; // eax
  int v5; // ecx
  int v6; // eax

  v2 = a1 - 250;
  if ( v2 >= 0 && (v3 = *(_DWORD *)(a2 + 8), v4 = 16 * v2, v5 = *(_DWORD *)(v4 + v3), v6 = v3 + v4, v5 == 4) )
    return (void *)(*(_DWORD *)(v6 + 8) + 16);
  else
    return &unk_1003E150;
}

//----- (1001B1F0) --------------------------------------------------------
const char *__usercall sub_1001B1F0@<eax>(int *a1@<ebx>, int a2, _DWORD *a3)
{
  int v4; // ecx
  int v5; // edi
  int v6; // eax
  int v7; // esi
  int v8; // eax
  unsigned int v9; // eax
  const char *result; // eax

  if ( (a1[2] & 1) != 0 )
    return 0;
  while ( 2 )
  {
    v4 = *a1;
    v5 = *(_DWORD *)(*(_DWORD *)(*a1 - 8) + 12);
    v6 = a1[2];
    if ( (v6 & 1) != 0 )
    {
      v7 = -1;
    }
    else
    {
      if ( (v6 & 2) != 0 )
        a1[3] = *(_DWORD *)a1[4];
      v7 = ((a1[3] - *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v4 - 8) + 12) + 12)) >> 2) - 1;
    }
    v8 = sub_10019800(v5, a2 + 1, v7);
    *a3 = v8;
    if ( v8 )
      return "local";
    v9 = sub_1001ADE0(v5, v7, a2);
    switch ( v9 & 0x3F )
    {
      case 0u:
        if ( (int)((v9 >> 15) & 0x1FF) >= (int)HIBYTE(v9) )
          return 0;
        a2 = (v9 >> 15) & 0x1FF;
        if ( (a1[2] & 1) != 0 )
          return 0;
        continue;
      case 5u:
        *a3 = *(_DWORD *)(16 * ((v9 >> 6) & 0x3FFFF) + *(_DWORD *)(v5 + 8) + 8) + 16;
        result = "global";
        break;
      case 6u:
        *a3 = sub_1001B1C0((v9 >> 6) & 0x1FF, v5);
        result = "field";
        break;
      case 0xBu:
        *a3 = sub_1001B1C0((v9 >> 6) & 0x1FF, v5);
        result = "method";
        break;
      default:
        return 0;
    }
    break;
  }
  return result;
}

//----- (1001B320) --------------------------------------------------------
const char *__usercall sub_1001B320@<eax>(int a1@<eax>, _DWORD *a2)
{
  int v4; // eax
  int v5; // ebx
  int v6; // eax
  unsigned int v7; // eax
  int v8; // ecx

  if ( (*(_BYTE *)(a1 + 8) & 1) == 0 && *(int *)(a1 + 20) > 0 || (*(_BYTE *)(a1 - 16) & 1) != 0 )
    return 0;
  v4 = *(_DWORD *)(a1 - 16);
  v5 = a1 - 24;
  if ( (v4 & 1) != 0 )
  {
    v6 = -1;
  }
  else
  {
    if ( (v4 & 2) != 0 )
      *(_DWORD *)(v5 + 12) = **(_DWORD **)(v5 + 16);
    v6 = ((*(_DWORD *)(v5 + 12) - *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(*(_DWORD *)v5 - 8) + 12) + 12)) >> 2) - 1;
  }
  v7 = *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(*(_DWORD *)(*(_DWORD *)v5 - 8) + 12) + 12) + 4 * v6);
  v8 = v7 & 0x3F;
  if ( v8 == 25 || v8 == 26 )
    return sub_1001B1F0((int *)v5, HIBYTE(v7), a2);
  else
    return 0;
}

//----- (1001B3A0) --------------------------------------------------------
int __usercall sub_1001B3A0@<eax>(_DWORD *a1@<edi>)
{
  int result; // eax
  int v2; // ecx
  char Destination[60]; // [esp+0h] [ebp-3Ch] BYREF

  result = a1[5];
  v2 = *(_DWORD *)(result + 8);
  if ( (v2 & 1) == 0 )
  {
    if ( (v2 & 2) != 0 )
      *(_DWORD *)(result + 12) = **(_DWORD **)(result + 16);
    sub_10019220(
      Destination,
      (char *)(*(_DWORD *)(*(_DWORD *)(*(_DWORD *)(*(_DWORD *)result - 8) + 12) + 32) + 16),
      0x3Cu);
    return sub_10019200(a1, "%s:%d: %s", (int)Destination);
  }
  return result;
}

//----- (1001B420) --------------------------------------------------------
void __cdecl __noreturn sub_1001B420(_DWORD *a1)
{
  int v1; // eax
  _DWORD *v2; // edi
  _DWORD *v3; // eax
  _DWORD *v4; // eax
  int v5; // eax

  v1 = a1[23];
  if ( v1 )
  {
    v2 = (_DWORD *)(v1 + a1[7]);
    if ( *v2 != 6 )
      sub_10015840((int)a1, 5);
    v3 = (_DWORD *)a1[2];
    *v3 = *(v3 - 4);
    v3[2] = *(v3 - 2);
    v3[3] = *(v3 - 1);
    v4 = (_DWORD *)(a1[2] - 16);
    *v4 = *v2;
    v4[2] = v2[2];
    v4[3] = v2[3];
    if ( a1[6] - a1[2] <= 16 )
      sub_10015A20(a1, 1);
    v5 = a1[2] + 16;
    a1[2] = v5;
    sub_10015FC0((int)a1, (char *)(v5 - 32), 1);
  }
  sub_10015840((int)a1, 1);
}

//----- (1001B4B0) --------------------------------------------------------
void __cdecl __noreturn sub_1001B4B0(_DWORD *a1, char *Str, int a3)
{
  sub_10018F30(a1, Str, (int)&a3);
  sub_1001B3A0(a1);
  sub_1001B420(a1);
}

//----- (1001B4E0) --------------------------------------------------------
int __usercall sub_1001B4E0@<eax>(int a1@<ebx>, _DWORD *a2@<edi>, _DWORD *a3@<esi>, int a4, char *a5)
{
  char v5; // al
  const char *v6; // eax
  int v7; // eax
  _DWORD *v8; // eax
  int v10; // [esp+4h] [ebp-4h]

  v5 = *a5;
  v10 = 1;
  if ( !*a5 )
    return 1;
  do
  {
    switch ( v5 )
    {
      case 'S':
        sub_1001AC60((int)a2, (int)a3);
        break;
      case 'f':
        v8 = *(_DWORD **)(a4 + 8);
        *v8 = *a2;
        v8[2] = a2[2];
        v8[3] = a2[3];
        break;
      case 'l':
        if ( a1 )
          a3[5] = sub_1001AB60(a1);
        else
          a3[5] = -1;
        break;
      case 'n':
        if ( a1 )
          v6 = sub_1001B320(a1, a3 + 1);
        else
          v6 = 0;
        a3[2] = v6;
        if ( !v6 )
        {
          v7 = sub_1001ACD0(a4, (int)a2);
          a3[1] = v7;
          if ( v7 )
            a3[2] = "global";
          else
            a3[2] = byte_1003D986;
        }
        break;
      case 'u':
        a3[6] = *(unsigned __int8 *)(a2[2] + 7);
        break;
      default:
        v10 = 0;
        break;
    }
    v5 = *++a5;
  }
  while ( *a5 );
  return v10;
}

//----- (1001B610) --------------------------------------------------------
int __cdecl sub_1001B610(_DWORD *a1, char *Str, _DWORD *a3)
{
  const char *v3; // ebx
  int v4; // edi
  int v5; // edi
  int v6; // eax
  _DWORD *v7; // edi
  int v8; // eax
  int v10; // [esp+0h] [ebp-10h]

  v3 = Str;
  v4 = 1;
  if ( *Str == 62 )
  {
    v5 = a1[2];
    v6 = *(_DWORD *)(v5 - 16);
    v7 = (_DWORD *)(v5 - 16);
    if ( v6 != 6 )
      sub_1001B4B0(a1, "value for `lua_getinfo' is not a function", v10);
    v3 = Str;
    v4 = sub_1001B4E0(0, v7, a3, (int)a1, Str + 1);
    a1[2] -= 16;
  }
  else
  {
    v8 = a3[23];
    if ( v8 )
    {
      v3 = Str;
      v4 = sub_1001B4E0(a1[10] + 24 * v8, (_DWORD *)(*(_DWORD *)(a1[10] + 24 * v8) - 16), a3, (int)a1, Str);
    }
    else
    {
      sub_1001AD30((int)a3, (int)a1);
    }
  }
  if ( strchr(v3, 102) )
  {
    if ( a1[6] - a1[2] <= 16 )
      sub_10015A20(a1, 1);
    a1[2] += 16;
  }
  return v4;
}
// 1001B63A: variable 'v10' is possibly undefined

//----- (1001B6D0) --------------------------------------------------------
void __cdecl __noreturn sub_1001B6D0(_DWORD *a1, int a2, int a3)
{
  int v3; // ecx
  int *v4; // ebx
  unsigned int v5; // eax
  unsigned int v6; // edx
  int v7; // [esp+0h] [ebp-4h] BYREF

  v7 = v3;
  v4 = (int *)a1[5];
  v7 = 0;
  v5 = *v4;
  v6 = v4[1];
  if ( *v4 < v6 )
  {
    while ( a2 != v5 )
    {
      v5 += 16;
      if ( v5 >= v6 )
        goto LABEL_4;
    }
    if ( sub_1001B1F0(v4, (a2 - a1[3]) >> 4, &v7) )
      sub_1001B4B0(a1, "attempt to %s %s `%s' (a %s value)", a3);
  }
LABEL_4:
  sub_1001B4B0(a1, "attempt to %s a %s value", a3);
}
// 1001B6D0: variable 'v3' is possibly undefined

//----- (1001B760) --------------------------------------------------------
void __cdecl __noreturn sub_1001B760(_DWORD *a1, _DWORD *a2, _DWORD *a3)
{
  _DWORD *v3; // eax

  v3 = a2;
  if ( *a2 == 4 )
    v3 = a3;
  sub_1001B6D0(a1, (int)v3, (int)"concatenate");
}

//----- (1001B780) --------------------------------------------------------
void __cdecl __noreturn sub_1001B780(_DWORD *a1, _DWORD *a2, int a3)
{
  bool v3; // zf
  int v4; // eax
  char v5[16]; // [esp+4h] [ebp-10h] BYREF

  v3 = sub_10016F30(a2, (int)v5) == 0;
  v4 = (int)a2;
  if ( !v3 )
    v4 = a3;
  sub_1001B6D0(a1, v4, (int)"perform arithmetic on");
}
// 1001B780: using guessed type char var_10[16];

//----- (1001B7C0) --------------------------------------------------------
void __cdecl __noreturn sub_1001B7C0(_DWORD *a1, _DWORD *a2, _DWORD *a3)
{
  int v3; // eax

  v3 = *(&off_1003F1A8 + *a2);
  if ( *(_BYTE *)(v3 + 2) == *(_BYTE *)(*(&off_1003F1A8 + *a3) + 2) )
    sub_1001B4B0(a1, "attempt to compare two %s values", v3);
  sub_1001B4B0(a1, "attempt to compare %s with %s", v3);
}

//----- (1001B810) --------------------------------------------------------
void *__cdecl sub_1001B810(_DWORD *a1, void *Block, int a3, size_t Size)
{
  void *v4; // edi
  int v6; // [esp+0h] [ebp-Ch]

  if ( Size )
  {
    if ( Size >= 0xFFFFFFFD )
      sub_1001B4B0(a1, "memory allocation error: block too big", v6);
    v4 = realloc(Block, Size);
    if ( v4 )
      goto LABEL_4;
    if ( a1 )
      sub_10015840((int)a1, 4);
    return 0;
  }
  if ( !Block )
    return 0;
  free(Block);
  v4 = 0;
LABEL_4:
  if ( a1 )
  {
    *(_DWORD *)(a1[4] + 36) -= a3;
    *(_DWORD *)(a1[4] + 36) += Size;
  }
  return v4;
}
// 1001B85C: variable 'v6' is possibly undefined

//----- (1001B8A0) --------------------------------------------------------
void *__cdecl sub_1001B8A0(_DWORD *a1, void *a2, int *a3, int a4, int a5, char *Str)
{
  int v6; // ecx
  int v7; // esi
  void *result; // eax
  int v9; // [esp-4h] [ebp-10h]

  v6 = *a3;
  v7 = 2 * *a3;
  if ( v7 >= 4 )
  {
    if ( v6 >= a5 / 2 )
    {
      if ( v6 >= a5 - 4 )
        sub_1001B4B0(a1, Str, v9);
      v7 = a5;
    }
  }
  else
  {
    v7 = 4;
  }
  result = sub_1001B810(a1, a2, a4 * *a3, a4 * v7);
  *a3 = v7;
  return result;
}
// 1001B8DD: variable 'v9' is possibly undefined

//----- (1001B910) --------------------------------------------------------
void __usercall __noreturn sub_1001B910(int a1@<eax>)
{
  _DWORD *v1; // esi
  char Destination[80]; // [esp+8h] [ebp-50h] BYREF

  v1 = *(_DWORD **)(a1 + 52);
  sub_10019220(Destination, (char *)(*(_DWORD *)(a1 + 64) + 16), 0x50u);
  sub_10019200(v1, "%s:%d: %s near `%s'", (int)Destination);
  sub_10015840((int)v1, 3);
}

//----- (1001B960) --------------------------------------------------------
int __cdecl sub_1001B960(int a1, int a2)
{
  if ( a2 >= 257 )
    return dword_1003F23C[a2];
  else
    return sub_10019200(*(_DWORD **)(a1 + 52), "%c", a2);
}
// 1003F23C: using guessed type int dword_1003F23C[];

//----- (1001B990) --------------------------------------------------------
int __cdecl sub_1001B990(int a1, int *a2, _DWORD *a3, int a4)
{
  bool v4; // zf
  int v5; // ecx
  unsigned __int8 *v6; // edx
  int result; // eax
  _DWORD *v8; // eax
  int v9; // ecx
  unsigned __int8 *v10; // edx

  a2[13] = a1;
  a2[1] = 1;
  a2[2] = 1;
  a2[8] = 287;
  a2[14] = (int)a3;
  a2[12] = 0;
  a2[16] = a4;
  v4 = (*a3)-- == 0;
  if ( v4 )
  {
    result = sub_1001A420(a2[14]);
  }
  else
  {
    v5 = a2[14];
    v6 = *(unsigned __int8 **)(v5 + 4);
    result = *v6;
    *(_DWORD *)(v5 + 4) = v6 + 1;
  }
  *a2 = result;
  if ( result == 35 )
  {
    do
    {
      v8 = (_DWORD *)a2[14];
      v4 = (*v8)-- == 0;
      if ( v4 )
      {
        result = sub_1001A420(a2[14]);
      }
      else
      {
        v9 = a2[14];
        v10 = *(unsigned __int8 **)(v9 + 4);
        result = *v10;
        *(_DWORD *)(v9 + 4) = v10 + 1;
      }
      *a2 = result;
    }
    while ( result != 10 && result != -1 );
  }
  return result;
}

//----- (1001BA30) --------------------------------------------------------
int __usercall sub_1001BA30@<eax>(int a1@<esi>)
{
  int v1; // eax
  int v2; // edi
  int v3; // eax
  _DWORD *v4; // eax
  int v6; // ecx
  unsigned __int8 *v7; // edx
  int v8; // eax

  v1 = *(_DWORD *)(a1 + 60);
  v2 = 0;
  if ( *(_DWORD *)(v1 + 4) < 5u )
    sub_1001A580(*(_DWORD **)(a1 + 52), (void **)v1, 0x20u);
  do
  {
    v3 = *(_DWORD *)(a1 + 60);
    if ( (unsigned int)(v2 + 5) > *(_DWORD *)(v3 + 4) )
      sub_1001A580(*(_DWORD **)(a1 + 52), (void **)v3, v2 + 32);
    *(_BYTE *)(v2 + **(_DWORD **)(a1 + 60)) = *(_BYTE *)a1;
    v4 = *(_DWORD **)(a1 + 56);
    ++v2;
    if ( (*v4)-- == 0 )
    {
      v8 = sub_1001A420(*(_DWORD *)(a1 + 56));
    }
    else
    {
      v6 = *(_DWORD *)(a1 + 56);
      v7 = *(unsigned __int8 **)(v6 + 4);
      v8 = *v7;
      *(_DWORD *)(v6 + 4) = v7 + 1;
    }
    *(_DWORD *)a1 = v8;
  }
  while ( isalnum(v8) || *(_DWORD *)a1 == 95 );
  *(_BYTE *)(v2 + **(_DWORD **)(a1 + 60)) = 0;
  return v2;
}

//----- (1001BAD0) --------------------------------------------------------
int __usercall sub_1001BAD0@<eax>(int a1@<esi>, int a2, double *a3)
{
  int v3; // eax
  int v4; // edi
  int v5; // eax
  _DWORD *v6; // eax
  bool v7; // zf
  int v8; // ecx
  unsigned __int8 *v9; // edx
  int v10; // eax
  _DWORD *v11; // eax
  int v12; // ecx
  unsigned __int8 *v13; // edx
  int v14; // eax
  _DWORD *v15; // eax
  int v16; // edi
  int v17; // ecx
  unsigned __int8 *v18; // edx
  int v19; // eax
  _DWORD *v20; // ecx
  _DWORD *v21; // ebx
  int v22; // eax
  _DWORD *v23; // eax
  int v24; // ecx
  unsigned __int8 *v25; // edx
  int v26; // eax
  _DWORD *v27; // eax
  int v28; // ecx
  unsigned __int8 *v29; // edx
  int v30; // eax
  _DWORD *v31; // eax
  int v32; // ecx
  unsigned __int8 *v33; // edx
  int v34; // eax
  int v35; // eax
  _DWORD *v36; // eax
  int v37; // ecx
  unsigned __int8 *v38; // edx
  int v39; // eax
  int result; // eax
  _DWORD *v41; // edi
  char Destination[80]; // [esp+Ch] [ebp-50h] BYREF

  v3 = *(_DWORD *)(a1 + 60);
  v4 = 0;
  if ( *(_DWORD *)(v3 + 4) < 5u )
    sub_1001A580(*(_DWORD **)(a1 + 52), (void **)v3, 0x20u);
  if ( a2 )
  {
    ***(_BYTE ***)(a1 + 60) = 46;
    v4 = 1;
  }
  if ( isdigit(*(_DWORD *)a1) )
  {
    do
    {
      v5 = *(_DWORD *)(a1 + 60);
      if ( (unsigned int)(v4 + 5) > *(_DWORD *)(v5 + 4) )
        sub_1001A580(*(_DWORD **)(a1 + 52), (void **)v5, v4 + 32);
      *(_BYTE *)(v4 + **(_DWORD **)(a1 + 60)) = *(_BYTE *)a1;
      v6 = *(_DWORD **)(a1 + 56);
      ++v4;
      v7 = (*v6)-- == 0;
      if ( v7 )
      {
        v10 = sub_1001A420(*(_DWORD *)(a1 + 56));
      }
      else
      {
        v8 = *(_DWORD *)(a1 + 56);
        v9 = *(unsigned __int8 **)(v8 + 4);
        v10 = *v9;
        *(_DWORD *)(v8 + 4) = v9 + 1;
      }
      *(_DWORD *)a1 = v10;
    }
    while ( isdigit(v10) );
  }
  if ( *(_DWORD *)a1 == 46 )
  {
    *(_BYTE *)(v4 + **(_DWORD **)(a1 + 60)) = *(_BYTE *)a1;
    v11 = *(_DWORD **)(a1 + 56);
    ++v4;
    v7 = (*v11)-- == 0;
    if ( v7 )
    {
      v14 = sub_1001A420(*(_DWORD *)(a1 + 56));
    }
    else
    {
      v12 = *(_DWORD *)(a1 + 56);
      v13 = *(unsigned __int8 **)(v12 + 4);
      v14 = *v13;
      *(_DWORD *)(v12 + 4) = v13 + 1;
    }
    *(_DWORD *)a1 = v14;
    if ( v14 == 46 )
    {
      *(_BYTE *)(v4 + **(_DWORD **)(a1 + 60)) = 46;
      v15 = *(_DWORD **)(a1 + 56);
      v16 = v4 + 1;
      v7 = (*v15)-- == 0;
      if ( v7 )
      {
        v19 = sub_1001A420(*(_DWORD *)(a1 + 56));
      }
      else
      {
        v17 = *(_DWORD *)(a1 + 56);
        v18 = *(unsigned __int8 **)(v17 + 4);
        v19 = *v18;
        *(_DWORD *)(v17 + 4) = v18 + 1;
      }
      v20 = *(_DWORD **)(a1 + 60);
      *(_DWORD *)a1 = v19;
      *(_BYTE *)(v16 + *v20) = 0;
      v21 = *(_DWORD **)(a1 + 52);
      sub_10019220(Destination, (char *)(*(_DWORD *)(a1 + 64) + 16), 0x50u);
      sub_10019200(v21, "%s:%d: %s near `%s'", (int)Destination);
      sub_10015840((int)v21, 3);
    }
  }
  if ( isdigit(*(_DWORD *)a1) )
  {
    do
    {
      v22 = *(_DWORD *)(a1 + 60);
      if ( (unsigned int)(v4 + 5) > *(_DWORD *)(v22 + 4) )
        sub_1001A580(*(_DWORD **)(a1 + 52), (void **)v22, v4 + 32);
      *(_BYTE *)(v4 + **(_DWORD **)(a1 + 60)) = *(_BYTE *)a1;
      v23 = *(_DWORD **)(a1 + 56);
      ++v4;
      v7 = (*v23)-- == 0;
      if ( v7 )
      {
        v26 = sub_1001A420(*(_DWORD *)(a1 + 56));
      }
      else
      {
        v24 = *(_DWORD *)(a1 + 56);
        v25 = *(unsigned __int8 **)(v24 + 4);
        v26 = *v25;
        *(_DWORD *)(v24 + 4) = v25 + 1;
      }
      *(_DWORD *)a1 = v26;
    }
    while ( isdigit(v26) );
  }
  if ( *(_DWORD *)a1 == 101 || *(_DWORD *)a1 == 69 )
  {
    *(_BYTE *)(v4 + **(_DWORD **)(a1 + 60)) = *(_BYTE *)a1;
    v27 = *(_DWORD **)(a1 + 56);
    ++v4;
    v7 = (*v27)-- == 0;
    if ( v7 )
    {
      v30 = sub_1001A420(*(_DWORD *)(a1 + 56));
    }
    else
    {
      v28 = *(_DWORD *)(a1 + 56);
      v29 = *(unsigned __int8 **)(v28 + 4);
      v30 = *v29;
      *(_DWORD *)(v28 + 4) = v29 + 1;
    }
    *(_DWORD *)a1 = v30;
    if ( v30 == 43 || v30 == 45 )
    {
      *(_BYTE *)(v4 + **(_DWORD **)(a1 + 60)) = *(_BYTE *)a1;
      v31 = *(_DWORD **)(a1 + 56);
      ++v4;
      v7 = (*v31)-- == 0;
      if ( v7 )
      {
        v34 = sub_1001A420(*(_DWORD *)(a1 + 56));
      }
      else
      {
        v32 = *(_DWORD *)(a1 + 56);
        v33 = *(unsigned __int8 **)(v32 + 4);
        v34 = *v33;
        *(_DWORD *)(v32 + 4) = v33 + 1;
      }
      *(_DWORD *)a1 = v34;
    }
    if ( isdigit(*(_DWORD *)a1) )
    {
      do
      {
        v35 = *(_DWORD *)(a1 + 60);
        if ( (unsigned int)(v4 + 5) > *(_DWORD *)(v35 + 4) )
          sub_1001A580(*(_DWORD **)(a1 + 52), (void **)v35, v4 + 32);
        *(_BYTE *)(v4 + **(_DWORD **)(a1 + 60)) = *(_BYTE *)a1;
        v36 = *(_DWORD **)(a1 + 56);
        ++v4;
        v7 = (*v36)-- == 0;
        if ( v7 )
        {
          v39 = sub_1001A420(*(_DWORD *)(a1 + 56));
        }
        else
        {
          v37 = *(_DWORD *)(a1 + 56);
          v38 = *(unsigned __int8 **)(v37 + 4);
          v39 = *v38;
          *(_DWORD *)(v37 + 4) = v38 + 1;
        }
        *(_DWORD *)a1 = v39;
      }
      while ( isdigit(v39) );
    }
  }
  *(_BYTE *)(v4 + **(_DWORD **)(a1 + 60)) = 0;
  result = sub_10018E70(**(char ***)(a1 + 60), a3);
  if ( !result )
  {
    v41 = *(_DWORD **)(a1 + 52);
    sub_10019220(Destination, (char *)(*(_DWORD *)(a1 + 64) + 16), 0x50u);
    sub_10019200(v41, "%s:%d: %s near `%s'", (int)Destination);
    sub_10015840((int)v41, 3);
  }
  return result;
}

//----- (1001BE20) --------------------------------------------------------
void __cdecl __noreturn sub_1001BE20(int a1)
{
  int v1; // eax
  _DWORD *v2; // ebx
  char Destination[80]; // [esp+10h] [ebp-50h] BYREF

  v1 = *(_DWORD *)(a1 + 16);
  if ( v1 != 278 && (v1 <= 284 || v1 > 286) && v1 < 257 )
    sub_10019200(*(_DWORD **)(a1 + 52), "%c", *(_DWORD *)(a1 + 16));
  v2 = *(_DWORD **)(a1 + 52);
  sub_10019220(Destination, (char *)(*(_DWORD *)(a1 + 64) + 16), 0x50u);
  sub_10019200(v2, "%s:%d: %s near `%s'", (int)Destination);
  sub_10015840((int)v2, 3);
}

//----- (1001BEC0) --------------------------------------------------------
int __cdecl sub_1001BEC0(int a1, int a2, int a3, int a4)
{
  int result; // eax

  result = a3;
  if ( a2 > a3 )
  {
    sub_10019200(*(_DWORD **)(a1 + 52), "too many %s (limit=%d)", a4);
    sub_1001BE20(a1);
  }
  return result;
}

//----- (1001BEF0) --------------------------------------------------------
int __usercall sub_1001BEF0@<eax>(int a1@<esi>)
{
  _DWORD *v1; // eax
  int v3; // ecx
  unsigned __int8 *v4; // edx
  int v5; // eax
  int v6; // edx
  int result; // eax

  v1 = *(_DWORD **)(a1 + 56);
  if ( (*v1)-- == 0 )
  {
    v5 = sub_1001A420(*(_DWORD *)(a1 + 56));
  }
  else
  {
    v3 = *(_DWORD *)(a1 + 56);
    v4 = *(unsigned __int8 **)(v3 + 4);
    v5 = *v4;
    *(_DWORD *)(v3 + 4) = v4 + 1;
  }
  v6 = *(_DWORD *)(a1 + 4) + 1;
  *(_DWORD *)a1 = v5;
  result = v6;
  *(_DWORD *)(a1 + 4) = v6;
  if ( v6 > 2147483645 )
  {
    sub_10019200(*(_DWORD **)(a1 + 52), "too many %s (limit=%d)", (int)"lines in a chunk");
    sub_1001BE20(a1);
  }
  return result;
}

//----- (1001BF50) --------------------------------------------------------
_DWORD *__usercall sub_1001BF50@<eax>(int a1@<eax>, _DWORD *a2)
{
  int v3; // eax
  int v4; // ebx
  _DWORD *v5; // eax
  bool v6; // zf
  int v7; // edi
  int v8; // ecx
  unsigned __int8 *v9; // edx
  int v10; // eax
  int v11; // eax
  _DWORD *v12; // eax
  int v13; // ecx
  unsigned __int8 *v14; // edx
  int v15; // eax
  _DWORD *v16; // eax
  int v17; // ecx
  int v18; // ecx
  unsigned __int8 *v19; // edx
  int v20; // eax
  _DWORD *v21; // eax
  int v22; // ecx
  unsigned __int8 *v23; // edx
  int v24; // eax
  _DWORD *v25; // eax
  int v26; // edi
  int v27; // ecx
  unsigned __int8 *v28; // edx
  _DWORD *result; // eax
  _DWORD *v30; // ecx

  v3 = *(_DWORD *)(a1 + 60);
  v4 = 0;
  if ( *(_DWORD *)(v3 + 4) < 5u )
    sub_1001A580(*(_DWORD **)(a1 + 52), (void **)v3, 0x20u);
  ***(_BYTE ***)(a1 + 60) = 91;
  *(_BYTE *)(**(_DWORD **)(a1 + 60) + 1) = *(_BYTE *)a1;
  v5 = *(_DWORD **)(a1 + 56);
  v6 = *v5 == 0;
  v7 = 2;
  --*v5;
  if ( v6 )
  {
    v10 = sub_1001A420(*(_DWORD *)(a1 + 56));
  }
  else
  {
    v8 = *(_DWORD *)(a1 + 56);
    v9 = *(unsigned __int8 **)(v8 + 4);
    v10 = *v9;
    *(_DWORD *)(v8 + 4) = v9 + 1;
  }
  *(_DWORD *)a1 = v10;
  if ( v10 == 10 )
    sub_1001BEF0(a1);
  while ( 2 )
  {
    v11 = *(_DWORD *)(a1 + 60);
    if ( (unsigned int)(v7 + 5) > *(_DWORD *)(v11 + 4) )
      sub_1001A580(*(_DWORD **)(a1 + 52), (void **)v11, v7 + 32);
    switch ( *(_DWORD *)a1 )
    {
      case 0xFFFFFFFF:
        *(_BYTE *)(v7 + **(_DWORD **)(a1 + 60)) = 0;
        sub_1001B910(a1);
      case 0xA:
        *(_BYTE *)(v7 + **(_DWORD **)(a1 + 60)) = 10;
        ++v7;
        sub_1001BEF0(a1);
        if ( !a2 )
          v7 = 0;
        continue;
      case 0x5B:
        *(_BYTE *)(v7 + **(_DWORD **)(a1 + 60)) = *(_BYTE *)a1;
        v12 = *(_DWORD **)(a1 + 56);
        ++v7;
        v6 = (*v12)-- == 0;
        if ( v6 )
        {
          v15 = sub_1001A420(*(_DWORD *)(a1 + 56));
        }
        else
        {
          v13 = *(_DWORD *)(a1 + 56);
          v14 = *(unsigned __int8 **)(v13 + 4);
          v15 = *v14;
          *(_DWORD *)(v13 + 4) = v14 + 1;
        }
        *(_DWORD *)a1 = v15;
        if ( v15 != 91 )
          continue;
        ++v4;
        *(_BYTE *)(v7 + **(_DWORD **)(a1 + 60)) = 91;
LABEL_17:
        v16 = *(_DWORD **)(a1 + 56);
        v17 = (*v16)--;
        goto LABEL_18;
      case 0x5D:
        *(_BYTE *)(v7 + **(_DWORD **)(a1 + 60)) = *(_BYTE *)a1;
        v21 = *(_DWORD **)(a1 + 56);
        ++v7;
        v6 = (*v21)-- == 0;
        if ( v6 )
        {
          v24 = sub_1001A420(*(_DWORD *)(a1 + 56));
        }
        else
        {
          v22 = *(_DWORD *)(a1 + 56);
          v23 = *(unsigned __int8 **)(v22 + 4);
          v24 = *v23;
          *(_DWORD *)(v22 + 4) = v23 + 1;
        }
        *(_DWORD *)a1 = v24;
        if ( v24 != 93 )
          continue;
        *(_BYTE *)(v7 + **(_DWORD **)(a1 + 60)) = 93;
        v25 = *(_DWORD **)(a1 + 56);
        v17 = (*v25)--;
        if ( v4 )
        {
          --v4;
LABEL_18:
          ++v7;
          if ( v17 )
          {
            v18 = *(_DWORD *)(a1 + 56);
            v19 = *(unsigned __int8 **)(v18 + 4);
            v20 = *v19;
            *(_DWORD *)(v18 + 4) = v19 + 1;
            *(_DWORD *)a1 = v20;
          }
          else
          {
            *(_DWORD *)a1 = sub_1001A420(*(_DWORD *)(a1 + 56));
          }
          continue;
        }
        v26 = v7 + 1;
        if ( v17 )
        {
          v27 = *(_DWORD *)(a1 + 56);
          v28 = *(unsigned __int8 **)(v27 + 4);
          result = (_DWORD *)*v28;
          *(_DWORD *)(v27 + 4) = v28 + 1;
        }
        else
        {
          result = (_DWORD *)sub_1001A420(*(_DWORD *)(a1 + 56));
        }
        v30 = *(_DWORD **)(a1 + 60);
        *(_DWORD *)a1 = result;
        *(_BYTE *)(v26 + *v30) = 0;
        if ( a2 )
        {
          result = sub_100194B0(*(_DWORD *)(a1 + 52), (char *)(**(_DWORD **)(a1 + 60) + 2), v26 - 4);
          *a2 = result;
        }
        return result;
      default:
        *(_BYTE *)(v7 + **(_DWORD **)(a1 + 60)) = *(_BYTE *)a1;
        goto LABEL_17;
    }
  }
}

//----- (1001C1F0) --------------------------------------------------------
_DWORD *__usercall sub_1001C1F0@<eax>(int a1@<eax>, int a2, _DWORD *a3)
{
  int v4; // eax
  _DWORD *v5; // eax
  bool v6; // zf
  int v7; // edi
  int v8; // ecx
  unsigned __int8 *v9; // edx
  int v10; // eax
  unsigned int v11; // ebp
  int v12; // eax
  int v13; // eax
  _DWORD *v14; // eax
  int v15; // ecx
  unsigned __int8 *v16; // edx
  int v17; // eax
  _DWORD *v18; // eax
  int v19; // ecx
  unsigned __int8 *v20; // edx
  int v21; // eax
  _DWORD *v22; // eax
  int v23; // ecx
  unsigned __int8 *v24; // edx
  int v25; // eax
  _DWORD *v26; // eax
  int v27; // ecx
  unsigned __int8 *v28; // edx
  int v29; // eax
  _DWORD *v30; // eax
  int v31; // ecx
  unsigned __int8 *v32; // edx
  int v33; // eax
  _DWORD *v34; // eax
  int v35; // ecx
  unsigned __int8 *v36; // edx
  int v37; // eax
  _DWORD *v38; // eax
  int v39; // ecx
  unsigned __int8 *v40; // edx
  int v41; // eax
  _DWORD *v42; // eax
  int v43; // ecx
  unsigned __int8 *v44; // edx
  int v45; // eax
  _DWORD *v46; // eax
  int v47; // ecx
  unsigned __int8 *v48; // edx
  int v49; // eax
  _DWORD *v50; // eax
  int v51; // ecx
  unsigned __int8 *v52; // edx
  int v53; // eax
  int v54; // eax
  int v55; // ebx
  _DWORD *v56; // eax
  int v57; // ecx
  unsigned __int8 *v58; // edx
  int v59; // eax
  _DWORD *v60; // ebx
  _DWORD *v61; // ebx
  char *v62; // edx
  _DWORD *v63; // eax
  int v64; // edi
  int v65; // ecx
  unsigned __int8 *v66; // edx
  int v67; // eax
  _DWORD *v68; // ecx
  _DWORD *result; // eax
  int v70; // [esp+10h] [ebp-F4h]
  char Destination[80]; // [esp+14h] [ebp-F0h] BYREF
  char v72[80]; // [esp+64h] [ebp-A0h] BYREF
  char v73[80]; // [esp+B4h] [ebp-50h] BYREF

  v4 = *(_DWORD *)(a1 + 60);
  if ( *(_DWORD *)(v4 + 4) < 5u )
    sub_1001A580(*(_DWORD **)(a1 + 52), (void **)v4, 0x20u);
  ***(_BYTE ***)(a1 + 60) = *(_BYTE *)a1;
  v5 = *(_DWORD **)(a1 + 56);
  v6 = *v5 == 0;
  v7 = 1;
  --*v5;
  if ( v6 )
  {
    v10 = sub_1001A420(*(_DWORD *)(a1 + 56));
  }
  else
  {
    v8 = *(_DWORD *)(a1 + 56);
    v9 = *(unsigned __int8 **)(v8 + 4);
    v10 = *v9;
    *(_DWORD *)(v8 + 4) = v9 + 1;
  }
  *(_DWORD *)a1 = v10;
  if ( v10 != a2 )
  {
    v11 = 6;
    while ( 1 )
    {
      v12 = *(_DWORD *)(a1 + 60);
      if ( v11 > *(_DWORD *)(v12 + 4) )
        sub_1001A580(*(_DWORD **)(a1 + 52), (void **)v12, v7 + 32);
      v13 = *(_DWORD *)a1;
      if ( *(_DWORD *)a1 == -1 )
        break;
      if ( v13 == 10 )
      {
        *(_BYTE *)(v7 + **(_DWORD **)(a1 + 60)) = 0;
        v61 = *(_DWORD **)(a1 + 52);
        sub_10019220(v72, (char *)(*(_DWORD *)(a1 + 64) + 16), 0x50u);
        v62 = v72;
        goto LABEL_50;
      }
      if ( v13 == 92 )
      {
        v18 = *(_DWORD **)(a1 + 56);
        v6 = (*v18)-- == 0;
        if ( v6 )
        {
          v21 = sub_1001A420(*(_DWORD *)(a1 + 56));
        }
        else
        {
          v19 = *(_DWORD *)(a1 + 56);
          v20 = *(unsigned __int8 **)(v19 + 4);
          v21 = *v20;
          *(_DWORD *)(v19 + 4) = v20 + 1;
        }
        *(_DWORD *)a1 = v21;
        switch ( v21 )
        {
          case -1:
            break;
          case 10:
            *(_BYTE *)(v7 + **(_DWORD **)(a1 + 60)) = 10;
            ++v7;
            ++v11;
            sub_1001BEF0(a1);
            break;
          case 97:
            *(_BYTE *)(v7 + **(_DWORD **)(a1 + 60)) = 7;
            v22 = *(_DWORD **)(a1 + 56);
            ++v7;
            ++v11;
            v6 = (*v22)-- == 0;
            if ( v6 )
              goto LABEL_37;
            v23 = *(_DWORD *)(a1 + 56);
            v24 = *(unsigned __int8 **)(v23 + 4);
            v25 = *v24;
            *(_DWORD *)(v23 + 4) = v24 + 1;
            *(_DWORD *)a1 = v25;
            break;
          case 98:
            *(_BYTE *)(v7 + **(_DWORD **)(a1 + 60)) = 8;
            v26 = *(_DWORD **)(a1 + 56);
            ++v7;
            ++v11;
            v6 = (*v26)-- == 0;
            if ( v6 )
              goto LABEL_37;
            v27 = *(_DWORD *)(a1 + 56);
            v28 = *(unsigned __int8 **)(v27 + 4);
            v29 = *v28;
            *(_DWORD *)(v27 + 4) = v28 + 1;
            *(_DWORD *)a1 = v29;
            break;
          case 102:
            *(_BYTE *)(v7 + **(_DWORD **)(a1 + 60)) = 12;
            v30 = *(_DWORD **)(a1 + 56);
            ++v7;
            ++v11;
            v6 = (*v30)-- == 0;
            if ( v6 )
              goto LABEL_37;
            v31 = *(_DWORD *)(a1 + 56);
            v32 = *(unsigned __int8 **)(v31 + 4);
            v33 = *v32;
            *(_DWORD *)(v31 + 4) = v32 + 1;
            *(_DWORD *)a1 = v33;
            break;
          case 110:
            *(_BYTE *)(v7 + **(_DWORD **)(a1 + 60)) = 10;
            v34 = *(_DWORD **)(a1 + 56);
            ++v7;
            ++v11;
            v6 = (*v34)-- == 0;
            if ( v6 )
              goto LABEL_37;
            v35 = *(_DWORD *)(a1 + 56);
            v36 = *(unsigned __int8 **)(v35 + 4);
            v37 = *v36;
            *(_DWORD *)(v35 + 4) = v36 + 1;
            *(_DWORD *)a1 = v37;
            break;
          case 114:
            *(_BYTE *)(v7 + **(_DWORD **)(a1 + 60)) = 13;
            v38 = *(_DWORD **)(a1 + 56);
            ++v7;
            ++v11;
            v6 = (*v38)-- == 0;
            if ( v6 )
              goto LABEL_37;
            v39 = *(_DWORD *)(a1 + 56);
            v40 = *(unsigned __int8 **)(v39 + 4);
            v41 = *v40;
            *(_DWORD *)(v39 + 4) = v40 + 1;
            *(_DWORD *)a1 = v41;
            break;
          case 116:
            *(_BYTE *)(v7 + **(_DWORD **)(a1 + 60)) = 9;
            v42 = *(_DWORD **)(a1 + 56);
            ++v7;
            ++v11;
            v6 = (*v42)-- == 0;
            if ( v6 )
              goto LABEL_37;
            v43 = *(_DWORD *)(a1 + 56);
            v44 = *(unsigned __int8 **)(v43 + 4);
            v45 = *v44;
            *(_DWORD *)(v43 + 4) = v44 + 1;
            *(_DWORD *)a1 = v45;
            break;
          case 118:
            *(_BYTE *)(v7 + **(_DWORD **)(a1 + 60)) = 11;
            v46 = *(_DWORD **)(a1 + 56);
            ++v7;
            ++v11;
            v6 = (*v46)-- == 0;
            if ( v6 )
              goto LABEL_37;
            v47 = *(_DWORD *)(a1 + 56);
            v48 = *(unsigned __int8 **)(v47 + 4);
            v49 = *v48;
            *(_DWORD *)(v47 + 4) = v48 + 1;
            *(_DWORD *)a1 = v49;
            break;
          default:
            if ( isdigit(v21) )
            {
              v54 = 0;
              v55 = 0;
              while ( 1 )
              {
                v70 = *(_DWORD *)a1 + 10 * v54 - 48;
                v56 = *(_DWORD **)(a1 + 56);
                v6 = (*v56)-- == 0;
                if ( v6 )
                {
                  v59 = sub_1001A420(*(_DWORD *)(a1 + 56));
                }
                else
                {
                  v57 = *(_DWORD *)(a1 + 56);
                  v58 = *(unsigned __int8 **)(v57 + 4);
                  v59 = *v58;
                  *(_DWORD *)(v57 + 4) = v58 + 1;
                }
                ++v55;
                *(_DWORD *)a1 = v59;
                if ( v55 >= 3 || !isdigit(v59) )
                  break;
                v54 = v70;
              }
              if ( v70 > 255 )
              {
                *(_BYTE *)(v7 + **(_DWORD **)(a1 + 60)) = 0;
                v60 = *(_DWORD **)(a1 + 52);
                sub_10019220(Destination, (char *)(*(_DWORD *)(a1 + 64) + 16), 0x50u);
                sub_10019200(v60, "%s:%d: %s near `%s'", (int)Destination);
                sub_10015840((int)v60, 3);
              }
              *(_BYTE *)(v7 + **(_DWORD **)(a1 + 60)) = v70;
              ++v7;
              ++v11;
            }
            else
            {
              *(_BYTE *)(v7 + **(_DWORD **)(a1 + 60)) = *(_BYTE *)a1;
              v50 = *(_DWORD **)(a1 + 56);
              ++v7;
              ++v11;
              v6 = (*v50)-- == 0;
              if ( v6 )
                goto LABEL_37;
              v51 = *(_DWORD *)(a1 + 56);
              v52 = *(unsigned __int8 **)(v51 + 4);
              v53 = *v52;
              *(_DWORD *)(v51 + 4) = v52 + 1;
              *(_DWORD *)a1 = v53;
            }
            break;
        }
      }
      else
      {
        *(_BYTE *)(v7 + **(_DWORD **)(a1 + 60)) = *(_BYTE *)a1;
        v14 = *(_DWORD **)(a1 + 56);
        ++v7;
        ++v11;
        v6 = (*v14)-- == 0;
        if ( v6 )
        {
LABEL_37:
          *(_DWORD *)a1 = sub_1001A420(*(_DWORD *)(a1 + 56));
        }
        else
        {
          v15 = *(_DWORD *)(a1 + 56);
          v16 = *(unsigned __int8 **)(v15 + 4);
          v17 = *v16;
          *(_DWORD *)(v15 + 4) = v16 + 1;
          *(_DWORD *)a1 = v17;
        }
      }
      if ( *(_DWORD *)a1 == a2 )
        goto LABEL_52;
    }
    *(_BYTE *)(v7 + **(_DWORD **)(a1 + 60)) = 0;
    v61 = *(_DWORD **)(a1 + 52);
    sub_10019220(v73, (char *)(*(_DWORD *)(a1 + 64) + 16), 0x50u);
    v62 = v73;
LABEL_50:
    sub_10019200(v61, "%s:%d: %s near `%s'", (int)v62);
    sub_10015840((int)v61, 3);
  }
LABEL_52:
  *(_BYTE *)(v7 + **(_DWORD **)(a1 + 60)) = *(_BYTE *)a1;
  v63 = *(_DWORD **)(a1 + 56);
  v64 = v7 + 1;
  v6 = (*v63)-- == 0;
  if ( v6 )
  {
    v67 = sub_1001A420(*(_DWORD *)(a1 + 56));
  }
  else
  {
    v65 = *(_DWORD *)(a1 + 56);
    v66 = *(unsigned __int8 **)(v65 + 4);
    v67 = *v66;
    *(_DWORD *)(v65 + 4) = v66 + 1;
  }
  v68 = *(_DWORD **)(a1 + 60);
  *(_DWORD *)a1 = v67;
  *(_BYTE *)(v64 + *v68) = 0;
  result = sub_100194B0(*(_DWORD *)(a1 + 52), (char *)(**(_DWORD **)(a1 + 60) + 1), v64 - 2);
  *a3 = result;
  return result;
}

//----- (1001C750) --------------------------------------------------------
int __cdecl sub_1001C750(int a1, double *a2)
{
  _DWORD *v2; // eax
  bool v3; // zf
  int v4; // ecx
  unsigned __int8 *v5; // edx
  int v6; // eax
  _DWORD *v7; // eax
  int v8; // ecx
  unsigned __int8 *v9; // edx
  int v10; // eax
  _DWORD *v11; // eax
  int v12; // ecx
  unsigned __int8 *v13; // edx
  int v14; // eax
  _DWORD *v15; // eax
  int v16; // ecx
  unsigned __int8 *v17; // edx
  int v18; // eax
  _DWORD *v19; // eax
  int v20; // ecx
  unsigned __int8 *v21; // edx
  int v22; // eax
  _DWORD *v24; // eax
  int v25; // ecx
  unsigned __int8 *v26; // edx
  int v27; // eax
  _DWORD *v28; // eax
  int v29; // ecx
  unsigned __int8 *v30; // edx
  int v31; // eax
  _DWORD *v32; // eax
  int v33; // ecx
  unsigned __int8 *v34; // edx
  int v35; // eax
  _DWORD *v36; // eax
  int v37; // ecx
  unsigned __int8 *v38; // edx
  int v39; // eax
  _DWORD *v40; // eax
  int v41; // ecx
  unsigned __int8 *v42; // edx
  int v43; // eax
  _DWORD *v44; // eax
  int v45; // ecx
  unsigned __int8 *v46; // edx
  int v47; // eax
  _DWORD *v48; // eax
  int v49; // ecx
  unsigned __int8 *v50; // edx
  int v51; // eax
  _DWORD *v52; // eax
  int v53; // ecx
  unsigned __int8 *v54; // edx
  int v55; // eax
  _DWORD *v56; // eax
  int v57; // ecx
  unsigned __int8 *v58; // edx
  int v59; // eax
  _DWORD *v60; // eax
  int v61; // ecx
  unsigned __int8 *v62; // edx
  int v63; // eax
  _DWORD *v64; // eax
  int v65; // ecx
  unsigned __int8 *v66; // edx
  int v67; // eax
  _DWORD *v68; // eax
  int v69; // ecx
  unsigned __int8 *v70; // edx
  int v71; // eax
  int v72; // edi
  _DWORD *v73; // edi
  _DWORD *v74; // eax
  int v75; // ecx
  unsigned __int8 *v76; // edx
  int v77; // eax
  int v78; // eax
  _DWORD *v79; // eax
  unsigned __int8 v80; // cl
  char Destination[80]; // [esp+4h] [ebp-50h] BYREF

  while ( 2 )
  {
    switch ( *(_DWORD *)a1 )
    {
      case 0xFFFFFFFF:
        return 287;
      case 0xA:
        sub_1001BEF0(a1);
        continue;
      case 0x22:
      case 0x27:
        sub_1001C1F0(a1, *(_DWORD *)a1, a2);
        return 286;
      case 0x2D:
        v2 = *(_DWORD **)(a1 + 56);
        v3 = (*v2)-- == 0;
        if ( v3 )
        {
          v6 = sub_1001A420(*(_DWORD *)(a1 + 56));
        }
        else
        {
          v4 = *(_DWORD *)(a1 + 56);
          v5 = *(unsigned __int8 **)(v4 + 4);
          v6 = *v5;
          *(_DWORD *)(v4 + 4) = v5 + 1;
        }
        *(_DWORD *)a1 = v6;
        if ( v6 != 45 )
          return 45;
        v7 = *(_DWORD **)(a1 + 56);
        v3 = (*v7)-- == 0;
        if ( v3 )
        {
          v10 = sub_1001A420(*(_DWORD *)(a1 + 56));
        }
        else
        {
          v8 = *(_DWORD *)(a1 + 56);
          v9 = *(unsigned __int8 **)(v8 + 4);
          v10 = *v9;
          *(_DWORD *)(v8 + 4) = v9 + 1;
        }
        *(_DWORD *)a1 = v10;
        if ( v10 != 91 )
          goto LABEL_16;
        v11 = *(_DWORD **)(a1 + 56);
        v3 = (*v11)-- == 0;
        if ( v3 )
        {
          v14 = sub_1001A420(*(_DWORD *)(a1 + 56));
        }
        else
        {
          v12 = *(_DWORD *)(a1 + 56);
          v13 = *(unsigned __int8 **)(v12 + 4);
          v14 = *v13;
          *(_DWORD *)(v12 + 4) = v13 + 1;
        }
        *(_DWORD *)a1 = v14;
        if ( v14 == 91 )
        {
          sub_1001BF50(a1, 0);
        }
        else
        {
LABEL_16:
          if ( *(_DWORD *)a1 != 10 )
          {
            do
            {
              if ( *(_DWORD *)a1 == -1 )
                break;
              v15 = *(_DWORD **)(a1 + 56);
              v3 = (*v15)-- == 0;
              if ( v3 )
              {
                v18 = sub_1001A420(*(_DWORD *)(a1 + 56));
              }
              else
              {
                v16 = *(_DWORD *)(a1 + 56);
                v17 = *(unsigned __int8 **)(v16 + 4);
                v18 = *v17;
                *(_DWORD *)(v16 + 4) = v17 + 1;
              }
              *(_DWORD *)a1 = v18;
            }
            while ( v18 != 10 );
          }
        }
        continue;
      case 0x2E:
        v60 = *(_DWORD **)(a1 + 56);
        v3 = (*v60)-- == 0;
        if ( v3 )
        {
          v63 = sub_1001A420(*(_DWORD *)(a1 + 56));
        }
        else
        {
          v61 = *(_DWORD *)(a1 + 56);
          v62 = *(unsigned __int8 **)(v61 + 4);
          v63 = *v62;
          *(_DWORD *)(v61 + 4) = v62 + 1;
        }
        *(_DWORD *)a1 = v63;
        if ( v63 == 46 )
        {
          v64 = *(_DWORD **)(a1 + 56);
          v3 = (*v64)-- == 0;
          if ( v3 )
          {
            v67 = sub_1001A420(*(_DWORD *)(a1 + 56));
          }
          else
          {
            v65 = *(_DWORD *)(a1 + 56);
            v66 = *(unsigned __int8 **)(v65 + 4);
            v67 = *v66;
            *(_DWORD *)(v65 + 4) = v66 + 1;
          }
          *(_DWORD *)a1 = v67;
          if ( v67 == 46 )
          {
            v68 = *(_DWORD **)(a1 + 56);
            v3 = (*v68)-- == 0;
            if ( v3 )
            {
              *(_DWORD *)a1 = sub_1001A420(*(_DWORD *)(a1 + 56));
            }
            else
            {
              v69 = *(_DWORD *)(a1 + 56);
              v70 = *(unsigned __int8 **)(v69 + 4);
              v71 = *v70;
              *(_DWORD *)(v69 + 4) = v70 + 1;
              *(_DWORD *)a1 = v71;
            }
            return 280;
          }
          else
          {
            return 279;
          }
        }
        else if ( isdigit(v63) )
        {
          sub_1001BAD0(a1, 1, a2);
          return 285;
        }
        else
        {
          return 46;
        }
      case 0x3C:
        v36 = *(_DWORD **)(a1 + 56);
        v3 = (*v36)-- == 0;
        if ( v3 )
        {
          v39 = sub_1001A420(*(_DWORD *)(a1 + 56));
        }
        else
        {
          v37 = *(_DWORD *)(a1 + 56);
          v38 = *(unsigned __int8 **)(v37 + 4);
          v39 = *v38;
          *(_DWORD *)(v37 + 4) = v38 + 1;
        }
        *(_DWORD *)a1 = v39;
        if ( v39 != 61 )
          return 60;
        v40 = *(_DWORD **)(a1 + 56);
        v3 = (*v40)-- == 0;
        if ( v3 )
        {
          *(_DWORD *)a1 = sub_1001A420(*(_DWORD *)(a1 + 56));
        }
        else
        {
          v41 = *(_DWORD *)(a1 + 56);
          v42 = *(unsigned __int8 **)(v41 + 4);
          v43 = *v42;
          *(_DWORD *)(v41 + 4) = v42 + 1;
          *(_DWORD *)a1 = v43;
        }
        return 283;
      case 0x3D:
        v28 = *(_DWORD **)(a1 + 56);
        v3 = (*v28)-- == 0;
        if ( v3 )
        {
          v31 = sub_1001A420(*(_DWORD *)(a1 + 56));
        }
        else
        {
          v29 = *(_DWORD *)(a1 + 56);
          v30 = *(unsigned __int8 **)(v29 + 4);
          v31 = *v30;
          *(_DWORD *)(v29 + 4) = v30 + 1;
        }
        *(_DWORD *)a1 = v31;
        if ( v31 != 61 )
          return 61;
        v32 = *(_DWORD **)(a1 + 56);
        v3 = (*v32)-- == 0;
        if ( v3 )
        {
          *(_DWORD *)a1 = sub_1001A420(*(_DWORD *)(a1 + 56));
        }
        else
        {
          v33 = *(_DWORD *)(a1 + 56);
          v34 = *(unsigned __int8 **)(v33 + 4);
          v35 = *v34;
          *(_DWORD *)(v33 + 4) = v34 + 1;
          *(_DWORD *)a1 = v35;
        }
        return 281;
      case 0x3E:
        v44 = *(_DWORD **)(a1 + 56);
        v3 = (*v44)-- == 0;
        if ( v3 )
        {
          v47 = sub_1001A420(*(_DWORD *)(a1 + 56));
        }
        else
        {
          v45 = *(_DWORD *)(a1 + 56);
          v46 = *(unsigned __int8 **)(v45 + 4);
          v47 = *v46;
          *(_DWORD *)(v45 + 4) = v46 + 1;
        }
        *(_DWORD *)a1 = v47;
        if ( v47 != 61 )
          return 62;
        v48 = *(_DWORD **)(a1 + 56);
        v3 = (*v48)-- == 0;
        if ( v3 )
        {
          *(_DWORD *)a1 = sub_1001A420(*(_DWORD *)(a1 + 56));
        }
        else
        {
          v49 = *(_DWORD *)(a1 + 56);
          v50 = *(unsigned __int8 **)(v49 + 4);
          v51 = *v50;
          *(_DWORD *)(v49 + 4) = v50 + 1;
          *(_DWORD *)a1 = v51;
        }
        return 282;
      case 0x5B:
        v24 = *(_DWORD **)(a1 + 56);
        v3 = (*v24)-- == 0;
        if ( v3 )
        {
          v27 = sub_1001A420(*(_DWORD *)(a1 + 56));
        }
        else
        {
          v25 = *(_DWORD *)(a1 + 56);
          v26 = *(unsigned __int8 **)(v25 + 4);
          v27 = *v26;
          *(_DWORD *)(v25 + 4) = v26 + 1;
        }
        *(_DWORD *)a1 = v27;
        if ( v27 != 91 )
          return 91;
        sub_1001BF50(a1, a2);
        return 286;
      case 0x7E:
        v52 = *(_DWORD **)(a1 + 56);
        v3 = (*v52)-- == 0;
        if ( v3 )
        {
          v55 = sub_1001A420(*(_DWORD *)(a1 + 56));
        }
        else
        {
          v53 = *(_DWORD *)(a1 + 56);
          v54 = *(unsigned __int8 **)(v53 + 4);
          v55 = *v54;
          *(_DWORD *)(v53 + 4) = v54 + 1;
        }
        *(_DWORD *)a1 = v55;
        if ( v55 != 61 )
          return 126;
        v56 = *(_DWORD **)(a1 + 56);
        v3 = (*v56)-- == 0;
        if ( v3 )
        {
          *(_DWORD *)a1 = sub_1001A420(*(_DWORD *)(a1 + 56));
        }
        else
        {
          v57 = *(_DWORD *)(a1 + 56);
          v58 = *(unsigned __int8 **)(v57 + 4);
          v59 = *v58;
          *(_DWORD *)(v57 + 4) = v58 + 1;
          *(_DWORD *)a1 = v59;
        }
        return 284;
      default:
        if ( isspace(*(_DWORD *)a1) )
        {
          v19 = *(_DWORD **)(a1 + 56);
          v3 = (*v19)-- == 0;
          if ( v3 )
          {
            *(_DWORD *)a1 = sub_1001A420(*(_DWORD *)(a1 + 56));
          }
          else
          {
            v20 = *(_DWORD *)(a1 + 56);
            v21 = *(unsigned __int8 **)(v20 + 4);
            v22 = *v21;
            *(_DWORD *)(v20 + 4) = v21 + 1;
            *(_DWORD *)a1 = v22;
          }
          continue;
        }
        if ( isdigit(*(_DWORD *)a1) )
        {
          sub_1001BAD0(a1, 0, a2);
          return 285;
        }
        else if ( isalpha(*(_DWORD *)a1) || (v72 = *(_DWORD *)a1, *(_DWORD *)a1 == 95) )
        {
          v78 = sub_1001BA30(a1);
          v79 = sub_100194B0(*(_DWORD *)(a1 + 52), **(char ***)(a1 + 60), v78);
          v80 = *((_BYTE *)v79 + 6);
          if ( v80 )
          {
            return v80 + 256;
          }
          else
          {
            *(_DWORD *)a2 = v79;
            return 278;
          }
        }
        else
        {
          if ( iscntrl(v72) )
          {
            sub_10019200(*(_DWORD **)(a1 + 52), "char(%d)", v72);
            v73 = *(_DWORD **)(a1 + 52);
            sub_10019220(Destination, (char *)(*(_DWORD *)(a1 + 64) + 16), 0x50u);
            sub_10019200(v73, "%s:%d: %s near `%s'", (int)Destination);
            sub_10015840((int)v73, 3);
          }
          v74 = *(_DWORD **)(a1 + 56);
          v3 = (*v74)-- == 0;
          if ( v3 )
          {
            *(_DWORD *)a1 = sub_1001A420(*(_DWORD *)(a1 + 56));
          }
          else
          {
            v75 = *(_DWORD *)(a1 + 56);
            v76 = *(unsigned __int8 **)(v75 + 4);
            v77 = *v76;
            *(_DWORD *)(v75 + 4) = v76 + 1;
            *(_DWORD *)a1 = v77;
          }
          return v72;
        }
    }
  }
}

//----- (1001CDD0) --------------------------------------------------------
_DWORD *__usercall sub_1001CDD0@<eax>(int a1@<eax>)
{
  int v2; // ecx
  _DWORD *result; // eax
  _DWORD *v4; // esi
  int v5; // ecx

  v2 = *(_DWORD *)(a1 + 32);
  *(_DWORD *)(a1 + 8) = *(_DWORD *)(a1 + 4);
  result = (_DWORD *)(a1 + 32);
  if ( v2 == 287 )
  {
    result = (_DWORD *)sub_1001C750(a1, (double *)(a1 + 24));
    *(_DWORD *)(a1 + 16) = result;
  }
  else
  {
    v4 = (_DWORD *)(a1 + 16);
    *v4 = *result;
    v4[1] = result[1];
    v5 = result[3];
    v4[2] = result[2];
    v4[3] = v5;
    *result = 287;
  }
  return result;
}

//----- (1001CE20) --------------------------------------------------------
_DWORD *__usercall sub_1001CE20@<eax>(int a1@<eax>, int a2@<edi>, int a3@<esi>, int a4)
{
  int v5; // eax
  int v6; // eax

  if ( *(_DWORD *)(a3 + 16) != a2 )
  {
    if ( a1 == *(_DWORD *)(a3 + 4) )
    {
      v5 = sub_1001B960(a3, a2);
      sub_10019200(*(_DWORD **)(a3 + 52), "`%s' expected", v5);
      sub_1001BE20(a3);
    }
    sub_1001B960(a3, a4);
    v6 = sub_1001B960(a3, a2);
    sub_10019200(*(_DWORD **)(a3 + 52), "`%s' expected (to close `%s' at line %d)", v6);
    sub_1001BE20(a3);
  }
  return sub_1001CDD0(a3);
}

//----- (1001CE90) --------------------------------------------------------
int __usercall sub_1001CE90@<eax>(int a1@<esi>)
{
  int *v1; // edi
  int v2; // edx
  int v3; // ebx
  int *v4; // eax
  int v5; // ecx

  v1 = (int *)(a1 + 16);
  if ( *(_DWORD *)(a1 + 16) != 278 )
    sub_1001BE20(a1);
  v2 = *(_DWORD *)(a1 + 32);
  v3 = *(_DWORD *)(a1 + 24);
  *(_DWORD *)(a1 + 8) = *(_DWORD *)(a1 + 4);
  v4 = (int *)(a1 + 32);
  if ( v2 == 287 )
  {
    *v1 = sub_1001C750(a1, (double *)(a1 + 24));
  }
  else
  {
    *v1 = *v4;
    *(_DWORD *)(a1 + 20) = *(_DWORD *)(a1 + 36);
    v5 = *(_DWORD *)(a1 + 44);
    *(_DWORD *)(a1 + 24) = *(_DWORD *)(a1 + 40);
    *(_DWORD *)(a1 + 28) = v5;
    *v4 = 287;
  }
  return v3;
}

//----- (1001CF00) --------------------------------------------------------
int __usercall sub_1001CF00@<eax>(int a1@<eax>, int a2@<ecx>, _DWORD *a3@<esi>)
{
  int result; // eax

  result = sub_10020B40(*(int **)(a2 + 48), a1);
  a3[3] = -1;
  a3[4] = -1;
  *a3 = 4;
  a3[1] = result;
  return result;
}

//----- (1001CF20) --------------------------------------------------------
int __cdecl sub_1001CF20(int a1)
{
  int v1; // ecx
  _DWORD *v2; // esi
  int v3; // edi
  int result; // eax

  v2 = *(_DWORD **)(v1 + 48);
  v3 = *v2;
  if ( v2[12] + 1 > *(_DWORD *)(*v2 + 56) )
    *(_DWORD *)(v3 + 24) = sub_1001B8A0(
                             *(_DWORD **)(v1 + 52),
                             *(void **)(v3 + 24),
                             (int *)(*v2 + 56),
                             12,
                             2147483645,
                             byte_1003D986);
  *(_DWORD *)(*(_DWORD *)(v3 + 24) + 12 * v2[12]) = a1;
  result = v2[12];
  v2[12] = result + 1;
  return result;
}
// 1001CF22: variable 'v1' is possibly undefined

//----- (1001CF80) --------------------------------------------------------
_DWORD *__usercall sub_1001CF80@<eax>(int a1@<eax>, int a2@<edx>)
{
  _DWORD *result; // eax
  int v3; // ecx

  result = *(_DWORD **)(a1 + 48);
  for ( result[13] += a2; a2; *(_DWORD *)(*(_DWORD *)(*result + 24) + 12 * result[v3 + 174] + 4) = result[6] )
    v3 = result[13] - a2--;
  return result;
}

//----- (1001CFC0) --------------------------------------------------------
_DWORD *__usercall sub_1001CFC0@<eax>(int a1@<eax>, int a2@<edx>)
{
  _DWORD *result; // eax
  int v3; // edi
  int v4; // esi

  for ( result = *(_DWORD **)(a1 + 48);
        result[13] > a2;
        *(_DWORD *)(*(_DWORD *)(*result + 24) + 12 * result[v4 + 174] + 8) = v3 )
  {
    v3 = result[6];
    v4 = result[13] - 1;
    result[13] = v4;
  }
  return result;
}

//----- (1001D000) --------------------------------------------------------
int __usercall sub_1001D000@<eax>(char *a1@<edx>, int a2@<edi>, int a3)
{
  _DWORD *v3; // eax
  int v4; // esi
  int v5; // ebx
  int result; // eax

  v3 = sub_100194B0(*(_DWORD *)(a2 + 52), a1, strlen(a1));
  v4 = *(_DWORD *)(a2 + 48);
  v5 = (int)v3;
  sub_1001BEC0(a2, *(_DWORD *)(v4 + 52) + a3 + 1, 200, (int)"local variables");
  result = sub_1001CF20(v5);
  *(_DWORD *)(v4 + 4 * (a3 + *(_DWORD *)(v4 + 52)) + 696) = result;
  return result;
}

//----- (1001D060) --------------------------------------------------------
int __usercall sub_1001D060@<eax>(int *a1@<ebx>, int *a2@<edi>, int a3)
{
  int v3; // esi
  int result; // eax
  _DWORD *v5; // ecx
  int *v6; // eax

  v3 = *a2;
  result = 0;
  if ( *(_BYTE *)(*a2 + 68) )
  {
    v5 = a2 + 15;
    while ( *(v5 - 1) != *a1 || *v5 != a1[1] )
    {
      ++result;
      v5 += 5;
      if ( result >= *(unsigned __int8 *)(v3 + 68) )
        goto LABEL_6;
    }
  }
  else
  {
LABEL_6:
    sub_1001BEC0(a2[3], *(unsigned __int8 *)(*a2 + 68) + 1, 32, (int)"upvalues");
    if ( *(unsigned __int8 *)(v3 + 68) + 1 > *(_DWORD *)(*a2 + 36) )
      *(_DWORD *)(*a2 + 28) = sub_1001B8A0(
                                (_DWORD *)a2[4],
                                *(void **)(*a2 + 28),
                                (int *)(*a2 + 36),
                                4,
                                2147483645,
                                byte_1003D986);
    *(_DWORD *)(*(_DWORD *)(*a2 + 28) + 4 * *(unsigned __int8 *)(v3 + 68)) = a3;
    v6 = &a2[5 * *(unsigned __int8 *)(v3 + 68) + 14];
    *v6 = *a1;
    v6[1] = a1[1];
    v6[2] = a1[2];
    v6[3] = a1[3];
    v6[4] = a1[4];
    LOBYTE(result) = *(_BYTE *)(v3 + 68);
    *(_BYTE *)(v3 + 68) = result + 1;
    return (unsigned __int8)result;
  }
  return result;
}

//----- (1001D120) --------------------------------------------------------
int __cdecl sub_1001D120(int *a1, int a2, int *a3, int a4)
{
  int result; // eax
  int *v5; // edx
  _DWORD *v6; // ecx

  if ( a1 )
  {
    result = a1[13] - 1;
    if ( result < 0 )
    {
LABEL_7:
      sub_1001D120(a1[2], a2, a3, 0);
      if ( *a3 == 7 )
      {
        result = a4;
        if ( a4 )
        {
          result = sub_10020B40(a1, a2);
          a3[1] = result;
        }
      }
      else
      {
        result = sub_1001D060(a3, a1, a2);
        *a3 = 6;
        a3[1] = result;
      }
    }
    else
    {
      v5 = &a1[result + 174];
      while ( a2 != *(_DWORD *)(*(_DWORD *)(*a1 + 24) + 12 * *v5) )
      {
        --result;
        --v5;
        if ( result < 0 )
          goto LABEL_7;
      }
      a3[3] = -1;
      a3[4] = -1;
      *a3 = 5;
      a3[1] = result;
      if ( !a4 )
      {
        v6 = (_DWORD *)a1[5];
        if ( v6 )
        {
          while ( v6[2] > result )
          {
            v6 = (_DWORD *)*v6;
            if ( !v6 )
              return result;
          }
          v6[3] = 1;
        }
      }
    }
  }
  else
  {
    result = (int)a3;
    a3[3] = -1;
    a3[4] = -1;
    *a3 = 7;
    a3[1] = 255;
  }
  return result;
}
// 1001D1A8: conditional instruction was optimized away because eax.4>=0

//----- (1001D200) --------------------------------------------------------
int *__usercall sub_1001D200@<eax>(int a1@<eax>, int a2@<edx>, int **a3@<ecx>, int a4)
{
  int *v4; // edi
  int *result; // eax
  int v7; // esi
  int v8; // esi
  int v9; // ebx

  v4 = *(int **)(a1 + 48);
  result = *a3;
  v7 = a4 - a2;
  if ( *a3 == (int *)12 )
  {
    v8 = v7 + 1;
    if ( v8 > 0 )
    {
      sub_10020A50(v4, v8 - 1);
      return sub_10020BE0((int)v4, a3, v8);
    }
    else
    {
      return sub_10020BE0((int)v4, a3, 0);
    }
  }
  else
  {
    if ( result )
      result = (int *)sub_10021270(v4, a3);
    if ( v7 > 0 )
    {
      v9 = v4[9];
      sub_10020A50(v4, v7);
      return (int *)sub_10020DD0(v4, v9, v7);
    }
  }
  return result;
}

//----- (1001D280) --------------------------------------------------------
int __usercall sub_1001D280@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ebx>)
{
  int *v4; // esi
  int *v5; // eax
  int v6; // edx
  int v7; // ecx

  v4 = *(int **)(a1 + 48);
  sub_1001CF80(a1, a2);
  sub_1001BEC0(a1, v4[13], 100, (int)"parameters");
  *(_BYTE *)(*v4 + 69) = *((_BYTE *)v4 + 52);
  *(_BYTE *)(*v4 + 70) = a3;
  if ( a3 )
  {
    sub_1001D000("arg", a1, 0);
    v5 = *(int **)(a1 + 48);
    v6 = *v5;
    v7 = v5[13] + 1;
    v5[13] = v7;
    *(_DWORD *)(*(_DWORD *)(v6 + 24) + 12 * v5[v7 + 173] + 4) = v5[6];
  }
  return sub_10020A50(v4, v4[13]);
}

//----- (1001D2F0) --------------------------------------------------------
char __usercall sub_1001D2F0@<al>(_DWORD *a1@<eax>, int a2@<ecx>, _DWORD *a3)
{
  _DWORD *v3; // esi
  int v4; // ebx
  int *v6; // eax
  int v7; // eax
  int v8; // ebx
  _DWORD *v9; // edi
  int v11; // [esp-4h] [ebp-14h]

  v3 = *(_DWORD **)(a2 + 48);
  v4 = *v3;
  v6 = (int *)(*v3 + 52);
  if ( v3[11] + 1 > *v6 )
    *(_DWORD *)(v4 + 16) = sub_1001B8A0(
                             *(_DWORD **)(a2 + 52),
                             *(void **)(v4 + 16),
                             v6,
                             4,
                             0x3FFFF,
                             "constant table overflow");
  *(_DWORD *)(*(_DWORD *)(v4 + 16) + 4 * v3[11]) = *a3;
  v11 = v3[11];
  v3[11] = v11 + 1;
  v7 = sub_10020DA0((int)v3, 34, 0, v11);
  a1[3] = -1;
  a1[4] = -1;
  *a1 = 10;
  a1[1] = v7;
  LOBYTE(v7) = *(_BYTE *)(*a3 + 68);
  v8 = 0;
  if ( (_BYTE)v7 )
  {
    v9 = a3 + 14;
    do
    {
      sub_10020D60((int)v3, *v9 == 5 ? 0 : 4, 0, v9[1], 0);
      v7 = *(unsigned __int8 *)(*a3 + 68);
      ++v8;
      v9 += 5;
    }
    while ( v8 < v7 );
  }
  return v7;
}

//----- (1001D3B0) --------------------------------------------------------
_DWORD *__usercall sub_1001D3B0@<eax>(int a1@<edi>, _DWORD *a2@<esi>)
{
  _DWORD *v2; // ebx
  _DWORD *result; // eax

  v2 = sub_100196C0(*(_DWORD **)(a1 + 52));
  *a2 = v2;
  a2[2] = *(_DWORD *)(a1 + 48);
  a2[3] = a1;
  a2[4] = *(_DWORD *)(a1 + 52);
  *(_DWORD *)(a1 + 48) = a2;
  a2[6] = 0;
  a2[7] = 0;
  a2[8] = -1;
  a2[9] = 0;
  a2[10] = 0;
  result = sub_10019C10(*(_DWORD **)(a1 + 52), 0, 0);
  a2[11] = 0;
  a2[12] = 0;
  a2[13] = 0;
  a2[5] = 0;
  a2[1] = result;
  v2[8] = *(_DWORD *)(a1 + 64);
  *((_BYTE *)v2 + 71) = 2;
  return result;
}

//----- (1001D410) --------------------------------------------------------
int __cdecl sub_1001D410(int a1)
{
  _DWORD *v1; // ebx
  int *v2; // edi
  int v3; // esi
  int v4; // edx
  void *v5; // eax
  int v6; // edx
  int v7; // eax
  void *v8; // eax
  int v9; // ecx
  void *v10; // eax
  int v11; // edx
  int v12; // eax
  void *v13; // eax
  int v14; // edx
  int result; // eax

  v1 = *(_DWORD **)(a1 + 52);
  v2 = *(int **)(a1 + 48);
  v3 = *v2;
  sub_1001CFC0(a1, 0);
  sub_10020D60((int)v2, 27, v4, 1, v4);
  v5 = sub_1001B810(v1, *(void **)(v3 + 12), 4 * *(_DWORD *)(v3 + 44), 4 * v2[6]);
  v6 = *(_DWORD *)(v3 + 48);
  *(_DWORD *)(v3 + 12) = v5;
  *(_DWORD *)(v3 + 44) = v2[6];
  *(_DWORD *)(v3 + 20) = sub_1001B810(v1, *(void **)(v3 + 20), 4 * v6, 4 * v2[6]);
  v7 = *(_DWORD *)(v3 + 40);
  *(_DWORD *)(v3 + 48) = v2[6];
  v8 = sub_1001B810(v1, *(void **)(v3 + 8), 16 * v7, 16 * v2[10]);
  v9 = *(_DWORD *)(v3 + 52);
  *(_DWORD *)(v3 + 8) = v8;
  *(_DWORD *)(v3 + 40) = v2[10];
  *(_DWORD *)(v3 + 16) = sub_1001B810(v1, *(void **)(v3 + 16), 4 * v9, 4 * v2[11]);
  *(_DWORD *)(v3 + 52) = v2[11];
  v10 = sub_1001B810(v1, *(void **)(v3 + 24), 12 * *(_DWORD *)(v3 + 56), 12 * v2[12]);
  v11 = *(unsigned __int8 *)(v3 + 68);
  *(_DWORD *)(v3 + 24) = v10;
  v12 = 4 * *(_DWORD *)(v3 + 36);
  *(_DWORD *)(v3 + 56) = v2[12];
  v13 = sub_1001B810(v1, *(void **)(v3 + 28), v12, 4 * v11);
  v14 = *(unsigned __int8 *)(v3 + 68);
  *(_DWORD *)(v3 + 28) = v13;
  *(_DWORD *)(v3 + 36) = v14;
  result = v2[2];
  *(_DWORD *)(a1 + 48) = result;
  return result;
}
// 1001D430: variable 'v4' is possibly undefined

//----- (1001D520) --------------------------------------------------------
int __usercall sub_1001D520@<eax>(int a1@<eax>, _DWORD *a2@<ebx>)
{
  int *v3; // edi
  int v4; // ecx
  _DWORD *v5; // eax
  int v6; // edx
  int v7; // eax
  int v8; // eax
  _DWORD *v10; // [esp+0h] [ebp-20h]
  int v11[5]; // [esp+Ch] [ebp-14h] BYREF

  v3 = *(int **)(a1 + 48);
  sub_100212F0(v3, v10);
  v4 = *(_DWORD *)(a1 + 32);
  *(_DWORD *)(a1 + 8) = *(_DWORD *)(a1 + 4);
  v5 = (_DWORD *)(a1 + 32);
  if ( v4 == 287 )
  {
    *(_DWORD *)(a1 + 16) = sub_1001C750(a1, (double *)(a1 + 24));
  }
  else
  {
    *(_DWORD *)(a1 + 16) = *v5;
    *(_DWORD *)(a1 + 20) = *(_DWORD *)(a1 + 36);
    v6 = *(_DWORD *)(a1 + 44);
    *(_DWORD *)(a1 + 24) = *(_DWORD *)(a1 + 40);
    *(_DWORD *)(a1 + 28) = v6;
    *v5 = 287;
  }
  v7 = sub_1001CE90(a1);
  v8 = sub_10020B40(*(int **)(a1 + 48), v7);
  v11[3] = -1;
  v11[4] = -1;
  v11[0] = 4;
  v11[1] = v8;
  return sub_10021860(v3, a2, v11);
}
// 1001D52C: variable 'v10' is possibly undefined

//----- (1001D5C0) --------------------------------------------------------
_DWORD *__usercall sub_1001D5C0@<eax>(int *a1@<ebx>, int a2@<esi>)
{
  int v2; // ecx
  int *v3; // eax
  int *v4; // edi
  int v5; // ecx
  int v7; // eax

  v2 = *(_DWORD *)(a2 + 32);
  *(_DWORD *)(a2 + 8) = *(_DWORD *)(a2 + 4);
  v3 = (int *)(a2 + 32);
  v4 = (int *)(a2 + 16);
  if ( v2 == 287 )
  {
    *v4 = sub_1001C750(a2, (double *)(a2 + 24));
  }
  else
  {
    *v4 = *v3;
    *(_DWORD *)(a2 + 20) = *(_DWORD *)(a2 + 36);
    v5 = *(_DWORD *)(a2 + 44);
    *(_DWORD *)(a2 + 24) = *(_DWORD *)(a2 + 40);
    *(_DWORD *)(a2 + 28) = v5;
    *v3 = 287;
  }
  sub_1001E4B0(a2, a1, -1);
  sub_10021340(*(int **)(a2 + 48), a1);
  if ( *v4 != 93 )
  {
    v7 = sub_1001B960(a2, 93);
    sub_10019200(*(_DWORD **)(a2 + 52), "`%s' expected", v7);
    sub_1001BE20(a2);
  }
  return sub_1001CDD0(a2);
}

//----- (1001D660) --------------------------------------------------------
int __usercall sub_1001D660@<eax>(int a1@<eax>, int a2)
{
  int *v4; // edi
  int v5; // eax
  int v6; // eax
  int v7; // eax
  int v8; // eax
  int result; // eax
  int v10; // [esp-4h] [ebp-38h]
  int v11[5]; // [esp+Ch] [ebp-28h] BYREF
  int v12[5]; // [esp+20h] [ebp-14h] BYREF
  int v13; // [esp+38h] [ebp+4h]

  v4 = *(int **)(a1 + 48);
  v13 = v4[9];
  if ( *(_DWORD *)(a1 + 16) == 278 )
  {
    sub_1001BEC0(a1, *(_DWORD *)(a2 + 24), 2147483645, (int)"items in a constructor");
    ++*(_DWORD *)(a2 + 24);
    v5 = sub_1001CE90(a1);
    v6 = sub_10020B40(*(int **)(a1 + 48), v5);
    v11[3] = -1;
    v11[4] = -1;
    v11[0] = 4;
    v11[1] = v6;
  }
  else
  {
    sub_1001D5C0(v11, a1);
  }
  if ( *(_DWORD *)(a1 + 16) != 61 )
  {
    v7 = sub_1001B960(a1, 61);
    sub_10019200(*(_DWORD **)(a1 + 52), "`%s' expected", v7);
    sub_1001BE20(a1);
  }
  sub_1001CDD0(a1);
  sub_10021360(v4, v11);
  sub_1001E4B0(a1, v12, -1);
  v10 = sub_10021360(v4, v12);
  v8 = sub_10021360(v4, v11);
  result = sub_10020D60((int)v4, 9, *(_DWORD *)(*(_DWORD *)(a2 + 20) + 4), v8, v10);
  v4[9] = v13;
  return result;
}
// 1001D660: using guessed type _DWORD var_14[5];

//----- (1001D760) --------------------------------------------------------
int __usercall sub_1001D760@<eax>(int *a1@<edi>, _DWORD *a2@<esi>)
{
  int result; // eax

  result = a2[8];
  if ( result )
  {
    if ( *a2 == 12 )
    {
      sub_10020BE0((int)a1, a2, -1);
      sub_10020DA0((int)a1, 32, *(_DWORD *)(a2[5] + 4), a2[7] - 1);
      result = a2[5];
      a1[9] = *(_DWORD *)(result + 4) + 1;
    }
    else
    {
      if ( *a2 )
        sub_10021270(a1, a2);
      sub_10020DA0((int)a1, 31, *(_DWORD *)(a2[5] + 4), a2[7] - 1);
      result = a2[5];
      a1[9] = *(_DWORD *)(result + 4) + 1;
    }
  }
  return result;
}

//----- (1001D7D0) --------------------------------------------------------
int __usercall sub_1001D7D0@<eax>(_DWORD *a1@<eax>, int a2@<ecx>)
{
  int *v3; // ebx
  int v5; // eax
  int *v6; // edi
  int v7; // eax
  int v8; // ecx
  int *v9; // eax
  int v10; // ecx
  int v11; // eax
  int *v12; // eax
  int v13; // edx
  _DWORD *v14; // esi
  _DWORD *v15; // esi
  int result; // eax
  int *v17; // [esp-1Ch] [ebp-58h]
  int v18; // [esp+10h] [ebp-2Ch]
  int v19; // [esp+14h] [ebp-28h]
  int v20[5]; // [esp+18h] [ebp-24h] BYREF
  _DWORD *v21; // [esp+2Ch] [ebp-10h]
  unsigned int v22; // [esp+30h] [ebp-Ch]
  int v23; // [esp+34h] [ebp-8h]
  int v24; // [esp+38h] [ebp-4h]

  v3 = *(int **)(a2 + 48);
  v18 = *(_DWORD *)(a2 + 4);
  v5 = sub_10020D60((int)v3, 10, 0, 0, 0);
  a1[3] = -1;
  a1[4] = -1;
  *a1 = 10;
  a1[1] = v5;
  v20[3] = -1;
  v20[4] = -1;
  v17 = *(int **)(a2 + 48);
  v19 = v5;
  v24 = 0;
  v22 = 0;
  v23 = 0;
  v21 = a1;
  v20[0] = 0;
  v20[1] = 0;
  sub_10021270(v17, a1);
  v6 = (int *)(a2 + 16);
  if ( *(_DWORD *)(a2 + 16) != 123 )
  {
    v7 = sub_1001B960(a2, 123);
    sub_10019200(*(_DWORD **)(a2 + 52), "`%s' expected", v7);
    sub_1001BE20(a2);
  }
  sub_1001CDD0(a2);
  while ( 1 )
  {
    if ( *v6 == 59 )
    {
      v8 = *(_DWORD *)(a2 + 32);
      *(_DWORD *)(a2 + 8) = *(_DWORD *)(a2 + 4);
      v9 = (int *)(a2 + 32);
      if ( v8 == 287 )
      {
        *v6 = sub_1001C750(a2, (double *)(a2 + 24));
      }
      else
      {
        *v6 = *v9;
        *(_DWORD *)(a2 + 20) = *(_DWORD *)(a2 + 36);
        v10 = *(_DWORD *)(a2 + 44);
        *(_DWORD *)(a2 + 24) = *(_DWORD *)(a2 + 40);
        *(_DWORD *)(a2 + 28) = v10;
        *v9 = 287;
      }
    }
    if ( *v6 == 125 )
      break;
    if ( v20[0] )
    {
      sub_10021270(v3, v20);
      v20[0] = 0;
      if ( v24 == 32 )
      {
        sub_10020DA0((int)v3, 31, v21[1], v23 - 1);
        v24 = 0;
        v3[9] = v21[1] + 1;
      }
    }
    if ( *v6 == 91 || *v6 == 278 && (v11 = sub_1001C750(a2, (double *)(a2 + 40)), *(_DWORD *)(a2 + 32) = v11, v11 == 61) )
    {
      sub_1001D660(a2, (int)v20);
    }
    else
    {
      sub_1001E4B0(a2, v20, -1);
      sub_1001BEC0(a2, v23++, 0x3FFFF, (int)"items in a constructor");
      ++v24;
    }
    if ( *v6 != 44 && *v6 != 59 )
      break;
    v12 = (int *)(a2 + 32);
    *(_DWORD *)(a2 + 8) = *(_DWORD *)(a2 + 4);
    if ( *(_DWORD *)(a2 + 32) == 287 )
    {
      *v6 = sub_1001C750(a2, (double *)(a2 + 24));
    }
    else
    {
      *v6 = *v12;
      *(_DWORD *)(a2 + 20) = *(_DWORD *)(a2 + 36);
      v13 = *(_DWORD *)(a2 + 44);
      *(_DWORD *)(a2 + 24) = *(_DWORD *)(a2 + 40);
      *(_DWORD *)(a2 + 28) = v13;
      *v12 = 287;
    }
  }
  sub_1001CE20(v18, 125, a2, 123);
  sub_1001D760(v3, v20);
  v14 = (_DWORD *)(*(_DWORD *)(*v3 + 12) + 4 * v19);
  *v14 ^= (*v14 ^ (sub_10018DA0(v23) << 15)) & 0xFF8000;
  v15 = (_DWORD *)(*(_DWORD *)(*v3 + 12) + 4 * v19);
  result = ((unsigned __int16)*v15 ^ (unsigned __int16)(((unsigned __int16)sub_10018DC0(v22) + 1) << 6)) & 0x7FC0;
  *v15 ^= result;
  return result;
}

//----- (1001DA50) --------------------------------------------------------
int __usercall sub_1001DA50@<eax>(int a1@<eax>)
{
  int *v2; // ebx
  int v3; // edi
  int v4; // eax
  int v5; // ebp
  _DWORD *v6; // edi
  int v7; // ebx
  int v8; // eax
  int v9; // ecx
  int *v10; // eax
  int v11; // ecx
  int v12; // ecx
  int *v13; // eax
  int v14; // ecx
  int v16; // [esp+Ch] [ebp-Ch]
  int v17; // [esp+10h] [ebp-8h]
  int v18; // [esp+14h] [ebp-4h]

  v2 = (int *)(a1 + 16);
  v3 = 0;
  v16 = 0;
  v17 = 0;
  if ( *(_DWORD *)(a1 + 16) != 41 )
  {
    while ( *v2 == 278 )
    {
      v4 = sub_1001CE90(a1);
      v5 = *(_DWORD *)(a1 + 48);
      v18 = v4;
      sub_1001BEC0(a1, v3 + *(_DWORD *)(v5 + 52) + 1, 200, (int)"local variables");
      v6 = *(_DWORD **)(a1 + 48);
      v7 = *v6;
      if ( v6[12] + 1 > *(_DWORD *)(*v6 + 56) )
        *(_DWORD *)(v7 + 24) = sub_1001B8A0(
                                 *(_DWORD **)(a1 + 52),
                                 *(void **)(v7 + 24),
                                 (int *)(*v6 + 56),
                                 12,
                                 2147483645,
                                 byte_1003D986);
      *(_DWORD *)(*(_DWORD *)(v7 + 24) + 12 * v6[12]) = v18;
      v8 = v6[12];
      v6[12] = v8 + 1;
      *(_DWORD *)(v5 + 4 * (v16 + *(_DWORD *)(v5 + 52)) + 696) = v8;
      v3 = ++v16;
      v2 = (int *)(a1 + 16);
      if ( *(_DWORD *)(a1 + 16) != 44 )
        return sub_1001D280(a1, v3, v17);
      v9 = *(_DWORD *)(a1 + 32);
      *(_DWORD *)(a1 + 8) = *(_DWORD *)(a1 + 4);
      v10 = (int *)(a1 + 32);
      if ( v9 == 287 )
      {
        *v2 = sub_1001C750(a1, (double *)(a1 + 24));
      }
      else
      {
        *v2 = *v10;
        *(_DWORD *)(a1 + 20) = *(_DWORD *)(a1 + 36);
        v11 = *(_DWORD *)(a1 + 44);
        *(_DWORD *)(a1 + 24) = *(_DWORD *)(a1 + 40);
        *(_DWORD *)(a1 + 28) = v11;
        *v10 = 287;
      }
    }
    if ( *v2 != 280 )
      sub_1001BE20(a1);
    v12 = *(_DWORD *)(a1 + 32);
    *(_DWORD *)(a1 + 8) = *(_DWORD *)(a1 + 4);
    v13 = (int *)(a1 + 32);
    v17 = 1;
    if ( v12 != 287 )
    {
      *v2 = *v13;
      v2[1] = *(_DWORD *)(a1 + 36);
      v14 = *(_DWORD *)(a1 + 44);
      v2[2] = *(_DWORD *)(a1 + 40);
      v2[3] = v14;
      *v13 = 287;
      return sub_1001D280(a1, v3, 1);
    }
    *v2 = sub_1001C750(a1, (double *)(a1 + 24));
  }
  return sub_1001D280(a1, v3, v17);
}

//----- (1001DBF0) --------------------------------------------------------
char __usercall sub_1001DBF0@<al>(int a1@<ebx>, _DWORD *a2, int a3, int a4)
{
  int v4; // eax
  _DWORD *v5; // eax
  int v6; // ecx
  int v7; // eax
  int v9[374]; // [esp+Ch] [ebp-5D8h] BYREF

  sub_1001D3B0(a1, v9);
  *(_DWORD *)(v9[0] + 60) = a4;
  if ( *(_DWORD *)(a1 + 16) != 40 )
  {
    v4 = sub_1001B960(a1, 40);
    sub_10019200(*(_DWORD **)(a1 + 52), "`%s' expected", v4);
    sub_1001BE20(a1);
  }
  sub_1001CDD0(a1);
  if ( a3 )
  {
    sub_1001D000("self", a1, 0);
    v5 = *(_DWORD **)(a1 + 48);
    v6 = v5[13] + 1;
    v5[13] = v6;
    *(_DWORD *)(*(_DWORD *)(*v5 + 24) + 12 * v5[v6 + 173] + 4) = v5[6];
  }
  sub_1001DA50(a1);
  if ( *(_DWORD *)(a1 + 16) != 41 )
  {
    v7 = sub_1001B960(a1, 41);
    sub_10019200(*(_DWORD **)(a1 + 52), "`%s' expected", v7);
    sub_1001BE20(a1);
  }
  sub_1001CDD0(a1);
  sub_1001FB20(a1);
  sub_1001CE20(a4, 262, a1, 265);
  sub_1001D410(a1);
  return sub_1001D2F0(a2, a1, v9);
}

//----- (1001DD00) --------------------------------------------------------
int __usercall sub_1001DD00@<eax>(int *a1@<ebx>, int a2@<esi>)
{
  int *v2; // edi
  int v3; // ecx
  int *v4; // eax
  int v5; // ecx
  int v7; // [esp+8h] [ebp-4h]

  v7 = 1;
  sub_1001E4B0(a2, a1, -1);
  v2 = (int *)(a2 + 16);
  while ( *v2 == 44 )
  {
    v3 = *(_DWORD *)(a2 + 32);
    *(_DWORD *)(a2 + 8) = *(_DWORD *)(a2 + 4);
    v4 = (int *)(a2 + 32);
    if ( v3 == 287 )
    {
      *v2 = sub_1001C750(a2, (double *)(a2 + 24));
    }
    else
    {
      *v2 = *v4;
      *(_DWORD *)(a2 + 20) = *(_DWORD *)(a2 + 36);
      v5 = *(_DWORD *)(a2 + 44);
      *(_DWORD *)(a2 + 24) = *(_DWORD *)(a2 + 40);
      *(_DWORD *)(a2 + 28) = v5;
      *v4 = 287;
    }
    sub_10021270(*(int **)(a2 + 48), a1);
    sub_1001E4B0(a2, a1, -1);
    ++v7;
  }
  return v7;
}

//----- (1001DDA0) --------------------------------------------------------
int __usercall sub_1001DDA0@<eax>(_DWORD *a1@<eax>, _DWORD *a2)
{
  int v3; // eax
  int *v4; // ebp
  int v5; // edi
  int v6; // ebx
  int v7; // eax
  int v8; // eax
  int result; // eax
  int v10[5]; // [esp+14h] [ebp-14h] BYREF

  v3 = a1[4];
  v4 = (int *)a1[12];
  v5 = a1[1];
  switch ( v3 )
  {
    case 40:
      if ( v5 != a1[2] )
        sub_1001BE20((int)a1);
      sub_1001CDD0((int)a1);
      if ( a1[4] == 41 )
      {
        v10[0] = 0;
      }
      else
      {
        sub_1001DD00(v10, (int)a1);
        sub_10020BE0((int)v4, v10, -1);
      }
      sub_1001CE20(v5, 41, (int)a1, 40);
      break;
    case 123:
      sub_1001D7D0(v10, (int)a1);
      break;
    case 286:
      v10[1] = sub_10020B40(v4, a1[6]);
      v10[3] = -1;
      v10[4] = -1;
      v10[0] = 4;
      sub_1001CDD0((int)a1);
      break;
    default:
      sub_1001BE20((int)a1);
  }
  v6 = a2[1];
  if ( v10[0] == 12 )
  {
    v7 = -1;
  }
  else
  {
    if ( v10[0] )
      sub_10021270(v4, v10);
    v7 = v4[9] - v6 - 1;
  }
  v8 = sub_10020D60((int)v4, 25, v6, v7 + 1, 2);
  a2[3] = -1;
  a2[4] = -1;
  *a2 = 12;
  a2[1] = v8;
  result = sub_10020C90(v4, v5);
  v4[9] = v6 + 1;
  return result;
}

//----- (1001DEE0) --------------------------------------------------------
int *__usercall sub_1001DEE0@<eax>(_DWORD *a1@<eax>, int *a2@<ebx>)
{
  int v3; // eax
  int v4; // eax
  int v6; // edi

  v3 = a1[4];
  if ( v3 == 40 )
  {
    v6 = a1[1];
    sub_1001CDD0((int)a1);
    sub_1001E4B0((int)a1, a2, -1);
    sub_1001CE20(v6, 41, (int)a1, 40);
    return sub_10020F20(a1[12], a2);
  }
  else
  {
    if ( v3 != 278 )
      sub_1001BE20((int)a1);
    v4 = sub_1001CE90((int)a1);
    return (int *)sub_1001D120((int *)a1[12], v4, a2, 1);
  }
}

//----- (1001DF50) --------------------------------------------------------
unsigned int __usercall sub_1001DF50@<eax>(int a1@<eax>, int *a2@<edi>)
{
  int *v3; // ebp
  int *v4; // ebx
  unsigned int result; // eax
  int v6; // ecx
  int *v7; // eax
  int v8; // ecx
  int v9; // eax
  int v10; // eax
  int v11[5]; // [esp+Ch] [ebp-28h] BYREF
  int v12[5]; // [esp+20h] [ebp-14h] BYREF

  v3 = *(int **)(a1 + 48);
  sub_1001DEE0((_DWORD *)a1, a2);
  v4 = (int *)(a1 + 16);
  result = *(_DWORD *)(a1 + 16) - 40;
  while ( 2 )
  {
    switch ( result )
    {
      case 0u:
      case 0x53u:
      case 0xF6u:
        sub_10021270(v3, a2);
        sub_1001DDA0((_DWORD *)a1, a2);
        goto LABEL_10;
      case 6u:
        sub_1001D520(a1, a2);
        goto LABEL_10;
      case 0x12u:
        v6 = *(_DWORD *)(a1 + 32);
        v7 = (int *)(a1 + 32);
        *(_DWORD *)(a1 + 8) = *(_DWORD *)(a1 + 4);
        if ( v6 == 287 )
        {
          *v4 = sub_1001C750(a1, (double *)(a1 + 24));
        }
        else
        {
          *v4 = *v7;
          v4[1] = *(_DWORD *)(a1 + 36);
          v8 = *(_DWORD *)(a1 + 44);
          v4[2] = *(_DWORD *)(a1 + 40);
          v4[3] = v8;
          *v7 = 287;
        }
        v9 = sub_1001CE90(a1);
        v10 = sub_10020B40(*(int **)(a1 + 48), v9);
        v11[3] = -1;
        v11[4] = -1;
        v11[0] = 4;
        v11[1] = v10;
        sub_100214C0(v3, a2, v11);
        sub_1001DDA0((_DWORD *)a1, a2);
        goto LABEL_10;
      case 0x33u:
        sub_100212F0(v3, a2);
        sub_1001D5C0(v12, a1);
        sub_10021860(v3, a2, v12);
LABEL_10:
        v4 = (int *)(a1 + 16);
        result = *(_DWORD *)(a1 + 16) - 40;
        if ( result > 0xF6 )
          return result;
        continue;
      default:
        return result;
    }
  }
}
// 1001DF50: using guessed type _DWORD var_14[5];

//----- (1001E180) --------------------------------------------------------
char __usercall sub_1001E180@<al>(int *a1@<eax>, int a2@<ecx>)
{
  char result; // al

  switch ( *(_DWORD *)(a2 + 16) )
  {
    case 0x7B:
      return sub_1001D7D0(a1, a2);
    case 0x107:
      *a1 = 3;
      goto LABEL_7;
    case 0x109:
      sub_1001CDD0(a2);
      return sub_1001DBF0(a2, a1, 0, *(_DWORD *)(a2 + 4));
    case 0x10D:
      *a1 = 1;
      goto LABEL_7;
    case 0x113:
      *a1 = 2;
LABEL_7:
      a1[1] = 0;
      a1[3] = -1;
      a1[4] = -1;
      result = (unsigned __int8)sub_1001CDD0(a2);
      break;
    case 0x11D:
      a1[1] = sub_10020B70(*(int **)(a2 + 48), *(double *)(a2 + 24));
      *a1 = 4;
      a1[3] = -1;
      a1[4] = -1;
      result = (unsigned __int8)sub_1001CDD0(a2);
      break;
    case 0x11E:
      sub_1001CF00(*(_DWORD *)(a2 + 24), a2, a1);
      result = (unsigned __int8)sub_1001CDD0(a2);
      break;
    default:
      result = sub_1001DF50(a2, a1);
      break;
  }
  return result;
}

//----- (1001E310) --------------------------------------------------------
int __usercall sub_1001E310@<eax>(int a1@<eax>)
{
  int result; // eax

  switch ( a1 )
  {
    case 42:
      result = 2;
      break;
    case 43:
      result = 0;
      break;
    case 45:
      result = 1;
      break;
    case 47:
      result = 3;
      break;
    case 60:
      result = 8;
      break;
    case 62:
      result = 10;
      break;
    case 94:
      result = 4;
      break;
    case 257:
      result = 12;
      break;
    case 271:
      result = 13;
      break;
    case 279:
      result = 5;
      break;
    case 281:
      result = 7;
      break;
    case 282:
      result = 11;
      break;
    case 283:
      result = 9;
      break;
    case 284:
      result = 6;
      break;
    default:
      result = 14;
      break;
  }
  return result;
}

//----- (1001E4B0) --------------------------------------------------------
int __cdecl sub_1001E4B0(int a1, int *a2, int a3)
{
  int v3; // eax
  bool v4; // sf
  int v5; // eax
  int v6; // edi
  int *v7; // ebp
  int v8; // edi
  int v9; // ecx
  _DWORD *v10; // eax
  int v11; // edx
  int v12; // ebx
  int v14[5]; // [esp+Ch] [ebp-14h] BYREF

  v3 = *(_DWORD *)(a1 + 68) + 1;
  v4 = *(_DWORD *)(a1 + 68) - 199 < 0;
  *(_DWORD *)(a1 + 68) = v3;
  if ( !(v4 ^ __OFSUB__(v3, 200) | (v3 == 200)) )
    sub_1001BE20(a1);
  v5 = *(_DWORD *)(a1 + 16);
  if ( v5 == 45 )
  {
    v6 = 0;
    goto LABEL_7;
  }
  if ( v5 == 270 )
  {
    v6 = 1;
LABEL_7:
    sub_1001CDD0(a1);
    v7 = a2;
    sub_1001E4B0(a1, a2, 8);
    sub_10021880(*(int **)(a1 + 48), v6, a2);
    goto LABEL_9;
  }
  v7 = a2;
  sub_1001E180(a2, a1);
LABEL_9:
  v8 = sub_1001E310(*(_DWORD *)(a1 + 16));
  if ( v8 != 14 )
  {
    do
    {
      if ( (unsigned __int8)byte_1003F85C[2 * v8] <= a3 )
        break;
      v9 = *(_DWORD *)(a1 + 32);
      v10 = (_DWORD *)(a1 + 32);
      *(_DWORD *)(a1 + 8) = *(_DWORD *)(a1 + 4);
      if ( v9 == 287 )
      {
        *(_DWORD *)(a1 + 16) = sub_1001C750(a1, (double *)(a1 + 24));
      }
      else
      {
        *(_DWORD *)(a1 + 16) = *v10;
        *(_DWORD *)(a1 + 20) = *(_DWORD *)(a1 + 36);
        v11 = *(_DWORD *)(a1 + 44);
        *(_DWORD *)(a1 + 24) = *(_DWORD *)(a1 + 40);
        *(_DWORD *)(a1 + 28) = v11;
        *v10 = 287;
      }
      sub_10021940(*(int **)(a1 + 48), v8, v7);
      v12 = sub_1001E4B0(a1, v14, (unsigned __int8)byte_1003F85D[2 * v8]);
      sub_10021A50(*(int **)(a1 + 48), v8, v7, v14);
      v8 = v12;
    }
    while ( v12 != 14 );
  }
  --*(_DWORD *)(a1 + 68);
  return v8;
}
// 1001E4B0: using guessed type int var_14[5];

//----- (1001E5F0) --------------------------------------------------------
int __usercall sub_1001E5F0@<eax>(int a1@<eax>)
{
  int *v1; // esi
  int *v2; // edi
  int v3; // eax
  int v5[5]; // [esp+8h] [ebp-14h] BYREF

  v1 = *(int **)(a1 + 48);
  v5[1] = -1;
  v5[4] = 0;
  v5[2] = v1[13];
  v5[3] = 0;
  v5[0] = v1[5];
  v1[5] = (int)v5;
  sub_1001FB20(a1);
  v2 = (int *)v1[5];
  v3 = v1[3];
  v1[5] = *v2;
  sub_1001CFC0(v3, v2[2]);
  if ( v2[3] )
    sub_10020D60((int)v1, 33, v2[2], 0, 0);
  v1[9] = v1[13];
  return sub_10020F00(v1, v2[1]);
}

//----- (1001E680) --------------------------------------------------------
_DWORD *__usercall sub_1001E680@<eax>(_DWORD *result@<eax>, int a2@<ecx>, int a3@<edi>)
{
  int *v3; // esi
  int v4; // edx
  int v5; // ecx

  v3 = *(int **)(a2 + 48);
  v4 = v3[9];
  v5 = 0;
  if ( result )
  {
    do
    {
      if ( result[1] == 8 )
      {
        if ( result[2] == *(_DWORD *)(a3 + 4) )
        {
          v5 = 1;
          result[2] = v4;
        }
        if ( result[3] == *(_DWORD *)(a3 + 4) )
        {
          v5 = 1;
          result[3] = v4;
        }
      }
      result = (_DWORD *)*result;
    }
    while ( result );
    if ( v5 )
    {
      sub_10020D60((int)v3, 0, v3[9], *(_DWORD *)(a3 + 4), 0);
      return (_DWORD *)sub_10020A50(v3, 1);
    }
  }
  return result;
}

//----- (1001E6E0) --------------------------------------------------------
int __cdecl sub_1001E6E0(int a1, _DWORD *a2, int a3)
{
  int v3; // eax
  _DWORD *v4; // ebp
  int v5; // eax
  int v6; // eax
  int v7; // eax
  int v8; // ebx
  int *v9; // esi
  int *v11[5]; // [esp+10h] [ebp-2Ch] BYREF
  _DWORD *v12; // [esp+24h] [ebp-18h] BYREF
  int v13[5]; // [esp+28h] [ebp-14h] BYREF

  v3 = a2[1];
  v4 = a2 + 1;
  if ( v3 < 5 || v3 > 8 )
    sub_1001BE20(a1);
  v5 = *(_DWORD *)(a1 + 16);
  if ( v5 == 44 )
  {
    sub_1001CDD0(a1);
    v12 = a2;
    sub_1001DF50(a1, v13);
    if ( v13[0] == 5 )
      sub_1001E680(a2, a1, (int)v13);
    sub_1001E6E0(a1, &v12, a3 + 1);
LABEL_14:
    v9 = *(int **)(a1 + 48);
    v11[1] = (int *)(v9[9] - 1);
    v11[3] = (int *)-1;
    v11[4] = (int *)-1;
    v11[0] = (int *)11;
    return sub_100213E0(v9, v4, v11);
  }
  if ( v5 != 61 )
  {
    v6 = sub_1001B960(a1, 61);
    sub_10019200(*(_DWORD **)(a1 + 52), "`%s' expected", v6);
    sub_1001BE20(a1);
  }
  sub_1001CDD0(a1);
  v7 = sub_1001DD00((int *)v11, a1);
  v8 = v7;
  if ( v7 != a3 )
  {
    sub_1001D200(a1, v7, v11, a3);
    if ( v8 > a3 )
      *(_DWORD *)(*(_DWORD *)(a1 + 48) + 36) += a3 - v8;
    goto LABEL_14;
  }
  sub_10020BE0(*(_DWORD *)(a1 + 48), v11, 1);
  return sub_100213E0(*(int **)(a1 + 48), v4, v11);
}

//----- (1001E810) --------------------------------------------------------
int __cdecl sub_1001E810(int a1, int a2)
{
  int v2; // esi
  int v3; // ecx
  int *v4; // ebx
  _DWORD *v5; // eax
  int v6; // edx
  int v7; // edi
  int v8; // edx
  int v9; // ecx
  int v10; // eax
  int *v11; // edi
  int *v12; // eax
  int v13; // edx
  int *v14; // esi
  int v15; // edx
  int *v16; // eax
  int v17; // edx
  int v18; // edi
  int v20; // [esp-Ch] [ebp-1FCh]
  int v21; // [esp-Ch] [ebp-1FCh]
  int v22; // [esp+10h] [ebp-1E0h]
  int i; // [esp+10h] [ebp-1E0h]
  int v24; // [esp+14h] [ebp-1DCh]
  int j; // [esp+14h] [ebp-1DCh]
  int v26; // [esp+18h] [ebp-1D8h]
  int v27[3]; // [esp+1Ch] [ebp-1D4h] BYREF
  int v28; // [esp+28h] [ebp-1C8h]
  int v29; // [esp+2Ch] [ebp-1C4h] BYREF
  int v30; // [esp+30h] [ebp-1C0h]
  int v31[5]; // [esp+34h] [ebp-1BCh] BYREF
  int v32[106]; // [esp+48h] [ebp-1A8h] BYREF

  v2 = a1;
  v3 = *(_DWORD *)(a1 + 32);
  v4 = *(int **)(a1 + 48);
  *(_DWORD *)(a1 + 8) = *(_DWORD *)(a1 + 4);
  v5 = (_DWORD *)(a1 + 32);
  if ( v3 == 287 )
  {
    *(_DWORD *)(a1 + 16) = sub_1001C750(a1, (double *)(a1 + 24));
  }
  else
  {
    *(_DWORD *)(a1 + 16) = *v5;
    *(_DWORD *)(a1 + 20) = *(_DWORD *)(a1 + 36);
    v6 = *(_DWORD *)(a1 + 44);
    *(_DWORD *)(a1 + 24) = *(_DWORD *)(a1 + 40);
    *(_DWORD *)(a1 + 28) = v6;
    *v5 = 287;
  }
  v30 = sub_10020E60((int)v4);
  v22 = sub_100207F0((int)v4);
  sub_1001E4B0(a1, v27, -1);
  if ( v27[0] == 4 )
    v27[0] = 2;
  v24 = *(_DWORD *)(a1 + 4);
  sub_100216E0(v4, v27);
  sub_100209C0(v4, &v29, v4[8]);
  v7 = v4[6] - v22;
  v4[8] = -1;
  if ( v7 > 100 )
    sub_1001BE20(a1);
  if ( v7 > 0 )
  {
    qmemcpy(v32, (const void *)(*(_DWORD *)(*v4 + 12) + 4 * v22), 4 * v7);
    v2 = a1;
  }
  v4[6] = v22;
  v31[1] = -1;
  v31[4] = 1;
  v31[2] = v4[13];
  v31[3] = 0;
  v31[0] = v4[5];
  v4[5] = (int)v31;
  if ( *(_DWORD *)(v2 + 16) != 259 )
  {
    v10 = sub_1001B960(v2, 259);
    sub_10019200(*(_DWORD **)(v2 + 52), "`%s' expected", v10);
    sub_1001BE20(v2);
  }
  v8 = *(_DWORD *)(v2 + 32);
  *(_DWORD *)(v2 + 8) = *(_DWORD *)(v2 + 4);
  if ( v8 == 287 )
  {
    *(_DWORD *)(v2 + 16) = sub_1001C750(v2, (double *)(v2 + 24));
  }
  else
  {
    *(_DWORD *)(v2 + 16) = *(_DWORD *)(v2 + 32);
    *(_DWORD *)(v2 + 20) = *(_DWORD *)(v2 + 36);
    v9 = *(_DWORD *)(v2 + 44);
    *(_DWORD *)(v2 + 24) = *(_DWORD *)(v2 + 40);
    *(_DWORD *)(v2 + 28) = v9;
    *(_DWORD *)(v2 + 32) = 287;
  }
  v26 = sub_100207F0((int)v4);
  sub_1001E5F0(v2);
  sub_10020F00(v4, v30);
  if ( v28 != -1 )
    v28 += v4[6] - v22;
  if ( v29 != -1 )
    v29 += v4[6] - v22;
  for ( i = 0; i < v7; ++i )
    sub_10020CB0((int)v4, v32[i], v24);
  v11 = (int *)(v2 + 16);
  if ( *(_DWORD *)(v2 + 16) != 262 )
  {
    if ( a2 == *(_DWORD *)(v2 + 4) )
    {
      v20 = sub_1001B960(v2, 262);
      sub_10019200(*(_DWORD **)(v2 + 52), "`%s' expected", v20);
    }
    else
    {
      sub_1001B960(v2, 277);
      v21 = sub_1001B960(v2, 262);
      sub_10019200(*(_DWORD **)(v2 + 52), "`%s' expected (to close `%s' at line %d)", v21);
    }
    sub_1001BE20(v2);
  }
  v12 = (int *)(v2 + 32);
  *(_DWORD *)(v2 + 8) = *(_DWORD *)(v2 + 4);
  if ( *(_DWORD *)(v2 + 32) == 287 )
  {
    *v11 = sub_1001C750(v2, (double *)(v2 + 24));
  }
  else
  {
    *v11 = *v12;
    *(_DWORD *)(v2 + 20) = *(_DWORD *)(v2 + 36);
    v13 = *(_DWORD *)(v2 + 44);
    *(_DWORD *)(v2 + 24) = *(_DWORD *)(v2 + 40);
    *(_DWORD *)(v2 + 28) = v13;
    *v12 = 287;
  }
  v14 = (int *)v4[5];
  v15 = v4[3];
  v4[5] = *v14;
  v16 = *(int **)(v15 + 48);
  for ( j = v14[2]; v16[13] > j; *(_DWORD *)(*(_DWORD *)(v17 + 24) + 12 * v16[v18 + 174] + 8) = v16[6] )
  {
    v17 = *v16;
    v18 = v16[13] - 1;
    v16[13] = v18;
  }
  if ( v14[3] )
    sub_10020D60((int)v4, 33, v14[2], 0, 0);
  v4[9] = v4[13];
  sub_10020F00(v4, v14[1]);
  sub_10021C50(v4, v28, v26);
  return sub_10020F00(v4, v29);
}
// 1001E810: using guessed type int var_1A8[106];

//----- (1001EB70) --------------------------------------------------------
int __usercall sub_1001EB70@<eax>(int a1@<eax>, int a2)
{
  int *v3; // ebx
  int v4; // ebp
  int v5; // ecx
  _DWORD *v6; // eax
  int v7; // edx
  int *v8; // esi
  int v9; // eax
  int v11[5]; // [esp+10h] [ebp-28h] BYREF
  int v12[5]; // [esp+24h] [ebp-14h] BYREF

  v3 = *(int **)(a1 + 48);
  v4 = sub_100207F0((int)v3);
  v11[1] = -1;
  v11[4] = 1;
  v11[2] = v3[13];
  v11[3] = 0;
  v11[0] = v3[5];
  v3[5] = (int)v11;
  v5 = *(_DWORD *)(a1 + 32);
  *(_DWORD *)(a1 + 8) = *(_DWORD *)(a1 + 4);
  v6 = (_DWORD *)(a1 + 32);
  if ( v5 == 287 )
  {
    *(_DWORD *)(a1 + 16) = sub_1001C750(a1, (double *)(a1 + 24));
  }
  else
  {
    *(_DWORD *)(a1 + 16) = *v6;
    *(_DWORD *)(a1 + 20) = *(_DWORD *)(a1 + 36);
    v7 = *(_DWORD *)(a1 + 44);
    *(_DWORD *)(a1 + 24) = *(_DWORD *)(a1 + 40);
    *(_DWORD *)(a1 + 28) = v7;
    *v6 = 287;
  }
  sub_1001E5F0(a1);
  sub_1001CE20(a2, 276, a1, 272);
  sub_1001E4B0(a1, v12, -1);
  if ( v12[0] == 1 )
    v12[0] = 3;
  sub_10021630(*(int **)(a1 + 48), v12);
  sub_10020F00(*(int **)(a1 + 48), v12[3]);
  sub_10021C50(v3, v12[4], v4);
  v8 = (int *)v3[5];
  v9 = v3[3];
  v3[5] = *v8;
  sub_1001CFC0(v9, v8[2]);
  if ( v8[3] )
    sub_10020D60((int)v3, 33, v8[2], 0, 0);
  v3[9] = v3[13];
  return sub_10020F00(v3, v8[1]);
}

//----- (1001ECB0) --------------------------------------------------------
int __usercall sub_1001ECB0@<eax>(int a1@<eax>, int a2@<ecx>, int a3, int a4, int a5)
{
  int *v7; // esi
  int v8; // eax
  int v9; // ebp
  int v10; // eax
  int v11; // edi
  int v12; // eax
  int *v13; // edi
  int v14; // eax
  int v16[5]; // [esp+10h] [ebp-14h] BYREF

  v7 = *(int **)(a2 + 48);
  sub_1001CF80(a2, a1);
  if ( *(_DWORD *)(a2 + 16) != 259 )
  {
    v8 = sub_1001B960(a2, 259);
    sub_10019200(*(_DWORD **)(a2 + 52), "`%s' expected", v8);
    sub_1001BE20(a2);
  }
  sub_1001CDD0(a2);
  v16[1] = -1;
  v16[4] = 1;
  v16[2] = v7[13];
  v16[3] = 0;
  v16[0] = v7[5];
  v7[5] = (int)v16;
  v9 = sub_100207F0((int)v7);
  sub_1001E5F0(a2);
  sub_10020F00(v7, v9 - 1);
  if ( a5 )
    v10 = sub_10020DA0((int)v7, 28, a3, 131070);
  else
    v10 = sub_10020D60((int)v7, 29, a3, 0, a1 - 3);
  v11 = v10;
  sub_10020C90(v7, a4);
  if ( a5 )
    v12 = v11;
  else
    v12 = sub_10020E60((int)v7);
  sub_10021C50(v7, v12, v9);
  v13 = (int *)v7[5];
  v14 = v7[3];
  v7[5] = *v13;
  sub_1001CFC0(v14, v13[2]);
  if ( v13[3] )
    sub_10020D60((int)v7, 33, v13[2], 0, 0);
  v7[9] = v7[13];
  return sub_10020F00(v7, v13[1]);
}

//----- (1001EE00) --------------------------------------------------------
int __usercall sub_1001EE00@<eax>(int a1@<eax>, int a2, int a3)
{
  int *v4; // esi
  int v5; // ebx
  int v6; // eax
  int v7; // eax
  int v8; // eax
  int v10[5]; // [esp+14h] [ebp-14h] BYREF

  v4 = *(int **)(a1 + 48);
  v5 = v4[9];
  sub_1001BEC0(a1, v4[13] + 1, 200, (int)"local variables");
  v4[v4[13] + 174] = sub_1001CF20(a2);
  sub_1001D000("(for limit)", a1, 1);
  sub_1001D000("(for step)", a1, 2);
  if ( *(_DWORD *)(a1 + 16) != 61 )
  {
    v6 = sub_1001B960(a1, 61);
    sub_10019200(*(_DWORD **)(a1 + 52), "`%s' expected", v6);
    sub_1001BE20(a1);
  }
  sub_1001CDD0(a1);
  sub_1001E4B0(a1, v10, -1);
  sub_10021270(*(int **)(a1 + 48), v10);
  if ( *(_DWORD *)(a1 + 16) != 44 )
  {
    v7 = sub_1001B960(a1, 44);
    sub_10019200(*(_DWORD **)(a1 + 52), "`%s' expected", v7);
    sub_1001BE20(a1);
  }
  sub_1001CDD0(a1);
  sub_1001E4B0(a1, v10, -1);
  sub_10021270(*(int **)(a1 + 48), v10);
  if ( *(_DWORD *)(a1 + 16) == 44 )
  {
    sub_1001CDD0(a1);
    sub_1001E4B0(a1, v10, -1);
    sub_10021270(*(int **)(a1 + 48), v10);
  }
  else
  {
    v8 = sub_10020B70(v4, 1.0);
    sub_10020DA0((int)v4, 1, v4[9], v8);
    sub_10020A50(v4, 1);
  }
  sub_10020D60((int)v4, 13, v4[9] - 3, v4[9] - 3, v4[9] - 1);
  sub_10020E60((int)v4);
  return sub_1001ECB0(3, a1, v5, a3, 1);
}
// 1001EE00: using guessed type int var_14[5];

//----- (1001EF90) --------------------------------------------------------
int __usercall sub_1001EF90@<eax>(int a1@<eax>, int a2)
{
  int *v3; // ebp
  int v4; // esi
  int *v5; // ebx
  int v6; // eax
  int *v7; // esi
  int v8; // eax
  int v9; // edx
  int v10; // ecx
  int v11; // eax
  int v12; // ecx
  int v13; // ebp
  _DWORD *v14; // esi
  int v15; // ebx
  int v16; // ecx
  int v17; // eax
  int v18; // eax
  int i; // [esp+10h] [ebp-24h]
  int v21; // [esp+14h] [ebp-20h]
  int *v22; // [esp+18h] [ebp-1Ch]
  int v23; // [esp+18h] [ebp-1Ch]
  int v24; // [esp+1Ch] [ebp-18h]
  int *v25[5]; // [esp+20h] [ebp-14h] BYREF

  v3 = *(int **)(a1 + 48);
  v22 = v3;
  v24 = v3[9];
  sub_1001D000("(for generator)", a1, 0);
  sub_1001D000("(for state)", a1, 1);
  v4 = *(_DWORD *)(a1 + 48);
  sub_1001BEC0(a1, *(_DWORD *)(v4 + 52) + 3, 200, (int)"local variables");
  *(_DWORD *)(v4 + 4 * *(_DWORD *)(v4 + 52) + 704) = sub_1001CF20(a2);
  for ( i = 3; ; ++i )
  {
    v5 = (int *)(a1 + 16);
    if ( *(_DWORD *)(a1 + 16) != 44 )
      break;
    v6 = *(_DWORD *)(a1 + 32);
    v7 = (int *)(a1 + 32);
    *(_DWORD *)(a1 + 8) = *(_DWORD *)(a1 + 4);
    if ( v6 == 287 )
    {
      *v5 = sub_1001C750(a1, (double *)(a1 + 24));
    }
    else
    {
      *v5 = *v7;
      *(_DWORD *)(a1 + 20) = *(_DWORD *)(a1 + 36);
      v8 = *(_DWORD *)(a1 + 44);
      *(_DWORD *)(a1 + 24) = *(_DWORD *)(a1 + 40);
      *(_DWORD *)(a1 + 28) = v8;
      *v7 = 287;
    }
    if ( *v5 != 278 )
      sub_1001BE20(a1);
    v9 = *(_DWORD *)(a1 + 24);
    *(_DWORD *)(a1 + 8) = *(_DWORD *)(a1 + 4);
    v21 = v9;
    if ( *v7 == 287 )
    {
      *v5 = sub_1001C750(a1, (double *)(a1 + 24));
    }
    else
    {
      v10 = *(_DWORD *)(a1 + 36);
      *v5 = *v7;
      v11 = *(_DWORD *)(a1 + 40);
      *(_DWORD *)(a1 + 20) = v10;
      v12 = *(_DWORD *)(a1 + 44);
      *(_DWORD *)(a1 + 24) = v11;
      *(_DWORD *)(a1 + 28) = v12;
      *v7 = 287;
    }
    v13 = *(_DWORD *)(a1 + 48);
    sub_1001BEC0(a1, *(_DWORD *)(v13 + 52) + i + 1, 200, (int)"local variables");
    v14 = *(_DWORD **)(a1 + 48);
    v15 = *v14;
    if ( v14[12] + 1 > *(_DWORD *)(*v14 + 56) )
      *(_DWORD *)(v15 + 24) = sub_1001B8A0(
                                *(_DWORD **)(a1 + 52),
                                *(void **)(v15 + 24),
                                (int *)(*v14 + 56),
                                12,
                                2147483645,
                                byte_1003D986);
    *(_DWORD *)(*(_DWORD *)(v15 + 24) + 12 * v14[12]) = v21;
    v16 = v14[12];
    v14[12] = v16 + 1;
    *(_DWORD *)(v13 + 4 * (i + *(_DWORD *)(v13 + 52)) + 696) = v16;
    v3 = v22;
  }
  if ( *v5 != 267 )
  {
    v17 = sub_1001B960(a1, 267);
    sub_10019200(*(_DWORD **)(a1 + 52), "`%s' expected", v17);
    sub_1001BE20(a1);
  }
  sub_1001CDD0(a1);
  v23 = *(_DWORD *)(a1 + 4);
  v18 = sub_1001DD00((int *)v25, a1);
  sub_1001D200(a1, v18, v25, i);
  sub_10020A10(v3, 3);
  sub_10020DA0((int)v3, 30, v24, 131070);
  return sub_1001ECB0(i, a1, v24, v23, 0);
}

//----- (1001F1D0) --------------------------------------------------------
int __usercall sub_1001F1D0@<eax>(int a1@<eax>, int a2)
{
  int *v3; // ebx
  int v4; // ecx
  int *v5; // eax
  int *v6; // edi
  int v7; // edx
  int v8; // eax
  int v9; // edi
  int *v10; // esi
  int v11; // eax
  int v13[5]; // [esp+Ch] [ebp-14h] BYREF

  v3 = *(int **)(a1 + 48);
  v13[4] = 0;
  v13[1] = -1;
  v13[2] = v3[13];
  v13[3] = 0;
  v13[0] = v3[5];
  v3[5] = (int)v13;
  v4 = *(_DWORD *)(a1 + 4);
  v5 = (int *)(a1 + 32);
  *(_DWORD *)(a1 + 8) = v4;
  v6 = (int *)(a1 + 16);
  if ( *(_DWORD *)(a1 + 32) == 287 )
  {
    *v6 = sub_1001C750(a1, (double *)(a1 + 24));
  }
  else
  {
    *v6 = *v5;
    *(_DWORD *)(a1 + 20) = v5[1];
    v7 = v5[3];
    *(_DWORD *)(a1 + 24) = v5[2];
    *(_DWORD *)(a1 + 28) = v7;
    *v5 = 287;
  }
  v8 = sub_1001CE90(a1);
  v9 = *v6;
  if ( v9 != 44 )
  {
    if ( v9 == 61 )
    {
      sub_1001EE00(a1, v8, a2);
      goto LABEL_10;
    }
    if ( v9 != 267 )
      sub_1001BE20(a1);
  }
  sub_1001EF90(a1, v8);
LABEL_10:
  sub_1001CE20(a2, 262, a1, 264);
  v10 = (int *)v3[5];
  v11 = v3[3];
  v3[5] = *v10;
  sub_1001CFC0(v11, v10[2]);
  if ( v10[3] )
    sub_10020D60((int)v3, 33, v10[2], 0, 0);
  v3[9] = v3[13];
  return sub_10020F00(v3, v10[1]);
}

//----- (1001F2F0) --------------------------------------------------------
int __usercall sub_1001F2F0@<eax>(int *a1@<ebx>, int a2@<esi>)
{
  int v2; // ecx
  int *v3; // eax
  int *v4; // edi
  int v5; // ecx
  int v7; // eax

  v2 = *(_DWORD *)(a2 + 32);
  *(_DWORD *)(a2 + 8) = *(_DWORD *)(a2 + 4);
  v3 = (int *)(a2 + 32);
  v4 = (int *)(a2 + 16);
  if ( v2 == 287 )
  {
    *v4 = sub_1001C750(a2, (double *)(a2 + 24));
  }
  else
  {
    *v4 = *v3;
    *(_DWORD *)(a2 + 20) = *(_DWORD *)(a2 + 36);
    v5 = *(_DWORD *)(a2 + 44);
    *(_DWORD *)(a2 + 24) = *(_DWORD *)(a2 + 40);
    *(_DWORD *)(a2 + 28) = v5;
    *v3 = 287;
  }
  sub_1001E4B0(a2, a1, -1);
  if ( *a1 == 1 )
    *a1 = 3;
  sub_10021630(*(int **)(a2 + 48), a1);
  sub_10020F00(*(int **)(a2 + 48), a1[3]);
  if ( *v4 != 274 )
  {
    v7 = sub_1001B960(a2, 274);
    sub_10019200(*(_DWORD **)(a2 + 52), "`%s' expected", v7);
    sub_1001BE20(a2);
  }
  sub_1001CDD0(a2);
  return sub_1001E5F0(a2);
}

//----- (1001F3C0) --------------------------------------------------------
_DWORD *__usercall sub_1001F3C0@<eax>(int a1@<eax>, int a2)
{
  int *v3; // edi
  int v4; // eax
  int v5; // eax
  int v7; // [esp+Ch] [ebp-18h] BYREF
  int v8[4]; // [esp+10h] [ebp-14h] BYREF
  int v9; // [esp+20h] [ebp-4h]

  v3 = *(int **)(a1 + 48);
  v7 = -1;
  sub_1001F2F0(v8, a1);
  while ( *(_DWORD *)(a1 + 16) == 261 )
  {
    v4 = sub_10020E60((int)v3);
    sub_100209C0(v3, &v7, v4);
    sub_10020F00(v3, v9);
    sub_1001F2F0(v8, a1);
  }
  if ( *(_DWORD *)(a1 + 16) == 260 )
  {
    v5 = sub_10020E60((int)v3);
    sub_100209C0(v3, &v7, v5);
    sub_10020F00(v3, v9);
    sub_1001CDD0(a1);
    sub_1001E5F0(a1);
  }
  else
  {
    sub_100209C0(v3, &v7, v9);
  }
  sub_10020F00(v3, v7);
  return sub_1001CE20(a2, 262, a1, 266);
}
// 1001F3C0: using guessed type int var_14[4];

//----- (1001F490) --------------------------------------------------------
int __usercall sub_1001F490@<eax>(int a1@<eax>)
{
  int v2; // eax
  int v3; // edi
  int v4; // ebx
  int v5; // eax
  int v6; // ecx
  int *v7; // eax
  int v8; // edx
  int v9; // edi
  int v11[5]; // [esp+Ch] [ebp-28h] BYREF
  _DWORD v12[5]; // [esp+20h] [ebp-14h] BYREF

  v2 = sub_1001CE90(a1);
  v3 = *(_DWORD *)(a1 + 48);
  v4 = v2;
  sub_1001BEC0(a1, *(_DWORD *)(v3 + 52) + 1, 200, (int)"local variables");
  *(_DWORD *)(v3 + 4 * *(_DWORD *)(v3 + 52) + 696) = sub_1001CF20(v4);
  v5 = *(_DWORD *)(a1 + 48);
  v6 = *(_DWORD *)(v5 + 36);
  *(_DWORD *)(v5 + 36) = v6 + 1;
  v11[1] = v6;
  v11[3] = -1;
  v11[4] = -1;
  v7 = *(int **)(a1 + 48);
  v11[0] = 5;
  v8 = *v7;
  v9 = v7[13] + 1;
  v7[13] = v9;
  *(_DWORD *)(*(_DWORD *)(v8 + 24) + 12 * v7[v9 + 173] + 4) = v7[6];
  sub_1001DBF0(a1, v12, 0, *(_DWORD *)(a1 + 4));
  return sub_100213E0(*(int **)(a1 + 48), v11, v12);
}
// 1001F490: using guessed type _DWORD var_14[5];

//----- (1001F540) --------------------------------------------------------
_DWORD *__usercall sub_1001F540@<eax>(int a1@<eax>)
{
  int *v2; // edi
  int *v3; // eax
  int v4; // ecx
  int v5; // ebp
  _DWORD *v6; // edi
  int v7; // ebx
  int v8; // eax
  int *v9; // ebx
  int v10; // edi
  int v11; // ecx
  int *v12; // eax
  int v13; // ecx
  int v14; // eax
  int v16; // [esp+10h] [ebp-1Ch]
  int v17; // [esp+14h] [ebp-18h]
  int *v18[5]; // [esp+18h] [ebp-14h] BYREF

  v16 = 0;
  while ( 1 )
  {
    v2 = (int *)(a1 + 16);
    if ( *(_DWORD *)(a1 + 16) != 278 )
      sub_1001BE20(a1);
    v17 = *(_DWORD *)(a1 + 24);
    v3 = (int *)(a1 + 32);
    *(_DWORD *)(a1 + 8) = *(_DWORD *)(a1 + 4);
    if ( *(_DWORD *)(a1 + 32) == 287 )
    {
      *v2 = sub_1001C750(a1, (double *)(a1 + 24));
    }
    else
    {
      *v2 = *v3;
      *(_DWORD *)(a1 + 20) = *(_DWORD *)(a1 + 36);
      v4 = *(_DWORD *)(a1 + 44);
      *(_DWORD *)(a1 + 24) = *(_DWORD *)(a1 + 40);
      *(_DWORD *)(a1 + 28) = v4;
      *v3 = 287;
    }
    v5 = *(_DWORD *)(a1 + 48);
    sub_1001BEC0(a1, *(_DWORD *)(v5 + 52) + v16 + 1, 200, (int)"local variables");
    v6 = *(_DWORD **)(a1 + 48);
    v7 = *v6;
    if ( v6[12] + 1 > *(_DWORD *)(*v6 + 56) )
      *(_DWORD *)(v7 + 24) = sub_1001B8A0(
                               *(_DWORD **)(a1 + 52),
                               *(void **)(v7 + 24),
                               (int *)(*v6 + 56),
                               12,
                               2147483645,
                               byte_1003D986);
    *(_DWORD *)(*(_DWORD *)(v7 + 24) + 12 * v6[12]) = v17;
    v8 = v6[12];
    v6[12] = v8 + 1;
    v9 = (int *)(a1 + 16);
    *(_DWORD *)(v5 + 4 * (v16 + *(_DWORD *)(v5 + 52)) + 696) = v8;
    v10 = ++v16;
    if ( *(_DWORD *)(a1 + 16) != 44 )
      break;
    v11 = *(_DWORD *)(a1 + 32);
    v12 = (int *)(a1 + 32);
    *(_DWORD *)(a1 + 8) = *(_DWORD *)(a1 + 4);
    if ( v11 == 287 )
    {
      *v9 = sub_1001C750(a1, (double *)(a1 + 24));
    }
    else
    {
      *v9 = *v12;
      *(_DWORD *)(a1 + 20) = *(_DWORD *)(a1 + 36);
      v13 = *(_DWORD *)(a1 + 44);
      *(_DWORD *)(a1 + 24) = *(_DWORD *)(a1 + 40);
      *(_DWORD *)(a1 + 28) = v13;
      *v12 = 287;
    }
  }
  if ( *v9 == 61 )
  {
    sub_1001CDD0(a1);
    v14 = sub_1001DD00((int *)v18, a1);
  }
  else
  {
    v14 = 0;
    v18[0] = 0;
  }
  sub_1001D200(a1, v14, v18, v10);
  return sub_1001CF80(a1, v10);
}

//----- (1001F6D0) --------------------------------------------------------
int __usercall sub_1001F6D0@<eax>(int *a1@<eax>, int a2@<ecx>)
{
  int v4; // eax

  v4 = sub_1001CE90(a2);
  sub_1001D120(*(int **)(a2 + 48), v4, a1, 1);
  while ( *(_DWORD *)(a2 + 16) == 46 )
    sub_1001D520(a2, a1);
  if ( *(_DWORD *)(a2 + 16) != 58 )
    return 0;
  sub_1001D520(a2, a1);
  return 1;
}

//----- (1001F730) --------------------------------------------------------
int __usercall sub_1001F730@<eax>(int a1@<eax>, int a2@<esi>)
{
  int v3; // ecx
  _DWORD *v4; // eax
  int v5; // edx
  int v6; // eax
  _DWORD v8[5]; // [esp+4h] [ebp-28h] BYREF
  int v9[5]; // [esp+18h] [ebp-14h] BYREF

  v3 = *(_DWORD *)(a1 + 32);
  *(_DWORD *)(a1 + 8) = *(_DWORD *)(a1 + 4);
  v4 = (_DWORD *)(a1 + 32);
  if ( v3 == 287 )
  {
    *(_DWORD *)(a1 + 16) = sub_1001C750(a1, (double *)(a1 + 24));
  }
  else
  {
    *(_DWORD *)(a1 + 16) = *v4;
    *(_DWORD *)(a1 + 20) = v4[1];
    v5 = v4[3];
    *(_DWORD *)(a1 + 24) = v4[2];
    *(_DWORD *)(a1 + 28) = v5;
    *v4 = 287;
  }
  v6 = sub_1001F6D0(v9, a1);
  sub_1001DBF0(a1, v8, v6, a2);
  sub_100213E0(*(int **)(a1 + 48), v9, v8);
  return sub_10020C90(*(_DWORD **)(a1 + 48), a2);
}
// 1001F730: using guessed type int var_14[5];
// 1001F730: using guessed type _DWORD var_28[5];

//----- (1001F7C0) --------------------------------------------------------
int *__usercall sub_1001F7C0@<eax>(int a1@<esi>)
{
  int v1; // ebx
  int v3; // [esp+8h] [ebp-18h] BYREF
  int v4[5]; // [esp+Ch] [ebp-14h] BYREF

  v1 = *(_DWORD *)(a1 + 48);
  sub_1001DF50(a1, v4);
  if ( v4[0] == 12 )
    return sub_10020BE0(v1, v4, 0);
  v3 = 0;
  return (int *)sub_1001E6E0(a1, &v3, 1);
}

//----- (1001F810) --------------------------------------------------------
int __usercall sub_1001F810@<eax>(int a1@<eax>)
{
  int v2; // ecx
  int *v3; // ebp
  int *v4; // eax
  int *v5; // edi
  int v6; // ecx
  int v7; // edi
  int v8; // eax
  int v9; // esi
  int v10; // eax
  int v12; // [esp+10h] [ebp-14h] BYREF
  int v13; // [esp+14h] [ebp-10h]

  v2 = *(_DWORD *)(a1 + 32);
  v3 = *(int **)(a1 + 48);
  *(_DWORD *)(a1 + 8) = *(_DWORD *)(a1 + 4);
  v4 = (int *)(a1 + 32);
  v5 = (int *)(a1 + 16);
  if ( v2 == 287 )
  {
    *v5 = sub_1001C750(a1, (double *)(a1 + 24));
  }
  else
  {
    *v5 = *v4;
    *(_DWORD *)(a1 + 20) = v4[1];
    v6 = v4[3];
    *(_DWORD *)(a1 + 24) = v4[2];
    *(_DWORD *)(a1 + 28) = v6;
    *v4 = 287;
  }
  v7 = *v5;
  switch ( v7 )
  {
    case 260:
    case 261:
    case 262:
    case 276:
    case 287:
      goto LABEL_13;
    default:
      if ( v7 == 59 )
      {
LABEL_13:
        v9 = 0;
        v10 = 0;
      }
      else
      {
        v8 = sub_1001DD00(&v12, a1);
        v9 = v8;
        if ( v12 == 12 )
        {
          sub_10020BE0((int)v3, &v12, -1);
          if ( v9 == 1 )
            *(_DWORD *)(*(_DWORD *)(*v3 + 12) + 4 * v13) = *(_DWORD *)(*(_DWORD *)(*v3 + 12) + 4 * v13) & 0xFFFFFFC0 | 0x1A;
          v10 = v3[13];
          v9 = -1;
        }
        else if ( v8 == 1 )
        {
          v10 = sub_100212F0(v3, &v12);
        }
        else
        {
          sub_10021270(v3, &v12);
          v10 = v3[13];
        }
      }
      return sub_10020D60((int)v3, 27, v10, v9 + 1, 0);
  }
}

//----- (1001F940) --------------------------------------------------------
int __usercall sub_1001F940@<eax>(int a1@<edi>)
{
  int v1; // ecx
  int *v2; // ebp
  _DWORD *v3; // esi
  _DWORD *v4; // eax
  int v5; // ebx
  int v6; // edx
  int v7; // ecx
  int v8; // eax

  v1 = *(_DWORD *)(a1 + 32);
  v2 = *(int **)(a1 + 48);
  v3 = (_DWORD *)v2[5];
  *(_DWORD *)(a1 + 8) = *(_DWORD *)(a1 + 4);
  v4 = (_DWORD *)(a1 + 32);
  v5 = 0;
  if ( v1 == 287 )
  {
    *(_DWORD *)(a1 + 16) = sub_1001C750(a1, (double *)(a1 + 24));
  }
  else
  {
    *(_DWORD *)(a1 + 16) = *v4;
    *(_DWORD *)(a1 + 20) = *(_DWORD *)(a1 + 36);
    v6 = *(_DWORD *)(a1 + 44);
    *(_DWORD *)(a1 + 24) = *(_DWORD *)(a1 + 40);
    *(_DWORD *)(a1 + 28) = v6;
    *v4 = 287;
  }
  if ( !v3 )
LABEL_7:
    sub_1001BE20(a1);
  while ( !v3[4] )
  {
    v7 = v3[3];
    v3 = (_DWORD *)*v3;
    v5 |= v7;
    if ( !v3 )
      goto LABEL_7;
  }
  if ( v5 )
    sub_10020D60((int)v2, 33, v3[2], 0, 0);
  v8 = sub_10020E60((int)v2);
  return sub_100209C0(v2, v3 + 1, v8);
}

//----- (1001F9F0) --------------------------------------------------------
int __usercall sub_1001F9F0@<eax>(int a1@<ebx>)
{
  int v1; // esi
  int result; // eax

  v1 = *(_DWORD *)(a1 + 4);
  switch ( *(_DWORD *)(a1 + 16) )
  {
    case 0x102:
      sub_1001F940(a1);
      result = 1;
      break;
    case 0x103:
      sub_1001CDD0(a1);
      sub_1001E5F0(a1);
      sub_1001CE20(v1, 262, a1, 259);
      result = 0;
      break;
    case 0x108:
      sub_1001F1D0(a1, *(_DWORD *)(a1 + 4));
      result = 0;
      break;
    case 0x109:
      sub_1001F730(a1, v1);
      result = 0;
      break;
    case 0x10A:
      sub_1001F3C0(a1, *(_DWORD *)(a1 + 4));
      result = 0;
      break;
    case 0x10C:
      sub_1001CDD0(a1);
      if ( *(_DWORD *)(a1 + 16) == 265 )
      {
        sub_1001CDD0(a1);
        sub_1001F490(a1);
      }
      else
      {
        sub_1001F540(a1);
      }
      result = 0;
      break;
    case 0x110:
      sub_1001EB70(a1, *(_DWORD *)(a1 + 4));
      result = 0;
      break;
    case 0x111:
      sub_1001F810(a1);
      result = 1;
      break;
    case 0x115:
      sub_1001E810(a1, *(_DWORD *)(a1 + 4));
      result = 0;
      break;
    default:
      sub_1001F7C0(a1);
      result = 0;
      break;
  }
  return result;
}

//----- (1001FB20) --------------------------------------------------------
int __cdecl sub_1001FB20(int a1)
{
  int v1; // eax
  bool v2; // sf
  int *v3; // esi
  int v4; // edi
  int *v5; // eax
  int v6; // edx
  int result; // eax

  v1 = *(_DWORD *)(a1 + 68) + 1;
  v2 = *(_DWORD *)(a1 + 68) - 199 < 0;
  *(_DWORD *)(a1 + 68) = v1;
  if ( !(v2 ^ __OFSUB__(v1, 200) | (v1 == 200)) )
    sub_1001BE20(a1);
  v3 = (int *)(a1 + 16);
  while ( 2 )
  {
    switch ( *v3 )
    {
      case 260:
      case 261:
      case 262:
      case 276:
      case 287:
        break;
      default:
        v4 = sub_1001F9F0(a1);
        if ( *v3 == 59 )
        {
          v5 = (int *)(a1 + 32);
          *(_DWORD *)(a1 + 8) = *(_DWORD *)(a1 + 4);
          if ( *(_DWORD *)(a1 + 32) == 287 )
          {
            *v3 = sub_1001C750(a1, (double *)(a1 + 24));
          }
          else
          {
            *v3 = *v5;
            *(_DWORD *)(a1 + 20) = *(_DWORD *)(a1 + 36);
            v6 = *(_DWORD *)(a1 + 44);
            *(_DWORD *)(a1 + 24) = *(_DWORD *)(a1 + 40);
            *(_DWORD *)(a1 + 28) = v6;
            *v5 = 287;
          }
        }
        *(_DWORD *)(*(_DWORD *)(a1 + 48) + 36) = *(_DWORD *)(*(_DWORD *)(a1 + 48) + 52);
        if ( !v4 )
          continue;
        break;
    }
    break;
  }
  result = *(_DWORD *)(a1 + 68) - 1;
  *(_DWORD *)(a1 + 68) = result;
  return result;
}

//----- (1001FC00) --------------------------------------------------------
int __cdecl sub_1001FC00(int a1, _DWORD *a2, int a3)
{
  char *v3; // ecx
  _DWORD *v4; // eax
  int v6[4]; // [esp+4h] [ebp-620h] BYREF
  int v7; // [esp+14h] [ebp-610h]
  int v8; // [esp+18h] [ebp-60Ch]
  double v9; // [esp+1Ch] [ebp-608h] BYREF
  int v10; // [esp+24h] [ebp-600h]
  int v11; // [esp+28h] [ebp-5FCh]
  double v12; // [esp+2Ch] [ebp-5F8h]
  int v13; // [esp+40h] [ebp-5E4h]
  int v14; // [esp+48h] [ebp-5DCh]
  int v15[374]; // [esp+4Ch] [ebp-5D8h] BYREF

  v3 = (char *)a2[4];
  v13 = a3;
  v14 = 0;
  v4 = sub_100194B0(a1, v3, strlen(v3));
  sub_1001B990(a1, v6, a2, (int)v4);
  sub_1001D3B0((int)v6, v15);
  v6[2] = v6[1];
  if ( v10 == 287 )
  {
    v7 = sub_1001C750((int)v6, &v9);
  }
  else
  {
    v7 = v10;
    v8 = v11;
    v9 = v12;
    v10 = 287;
  }
  sub_1001FB20((int)v6);
  if ( v7 != 287 )
    sub_1001BE20((int)v6);
  sub_1001D410((int)v6);
  return v15[0];
}
// 1001FC00: using guessed type int var_5D8[374];

//----- (1001FCF0) --------------------------------------------------------
unsigned int __usercall sub_1001FCF0@<eax>(unsigned int result@<eax>, char *a2@<ecx>, _DWORD **a3@<esi>)
{
  char *v3; // edi
  unsigned int v4; // ebp
  _DWORD *v5; // eax
  bool v6; // zf
  unsigned __int8 *v7; // ecx
  unsigned int v8; // ebx

  if ( a3[3] )
  {
    v3 = &a2[result - 1];
    if ( result )
    {
      v4 = result;
      do
      {
        v5 = a3[1];
        v6 = (*v5)-- == 0;
        result = (unsigned int)a3[1];
        if ( v6 )
        {
          result = sub_1001A420((int)a3[1]);
          v8 = result;
        }
        else
        {
          v7 = *(unsigned __int8 **)(result + 4);
          v8 = *v7;
          *(_DWORD *)(result + 4) = v7 + 1;
        }
        if ( v8 == -1 )
          sub_1001B4B0(*a3, "unexpected end of file in %s", (int)a3[4]);
        *v3-- = v8;
        --v4;
      }
      while ( v4 );
    }
  }
  else
  {
    result = sub_1001A4E0((int)a3[1], a2, result);
    if ( result )
      sub_1001B4B0(*a3, "unexpected end of file in %s", (int)a3[4]);
  }
  return result;
}

//----- (1001FD80) --------------------------------------------------------
unsigned int __usercall sub_1001FD80@<eax>(unsigned int result@<eax>, char *a2@<ecx>, _DWORD **a3@<esi>, int a4)
{
  char *v4; // edi
  _DWORD *v5; // eax
  bool v6; // zf
  _DWORD *v7; // eax
  unsigned __int8 *v8; // ecx
  int v9; // ebx
  int v10; // [esp+4h] [ebp-Ch]
  char *v11; // [esp+8h] [ebp-8h]
  unsigned int v12; // [esp+Ch] [ebp-4h]

  if ( a3[3] )
  {
    if ( result )
    {
      v4 = &a2[a4 - 1];
      v11 = v4;
      v12 = result;
      do
      {
        if ( a4 )
        {
          v10 = a4;
          do
          {
            v5 = a3[1];
            v6 = (*v5)-- == 0;
            v7 = a3[1];
            if ( v6 )
            {
              v9 = sub_1001A420((int)a3[1]);
            }
            else
            {
              v8 = (unsigned __int8 *)v7[1];
              v9 = *v8;
              v7[1] = v8 + 1;
            }
            if ( v9 == -1 )
              sub_1001B4B0(*a3, "unexpected end of file in %s", (int)a3[4]);
            *v4-- = v9;
            --v10;
          }
          while ( v10 );
        }
        v4 = &v11[a4];
        result = v12 - 1;
        v6 = v12 == 1;
        v11 += a4;
        --v12;
      }
      while ( !v6 );
    }
  }
  else
  {
    result = sub_1001A4E0((int)a3[1], a2, a4 * result);
    if ( result )
      sub_1001B4B0(*a3, "unexpected end of file in %s", (int)a3[4]);
  }
  return result;
}

//----- (1001FE60) --------------------------------------------------------
_DWORD *__usercall sub_1001FE60@<eax>(_DWORD **a1@<eax>)
{
  unsigned int v2; // edi
  char *v4; // ebx
  unsigned int v5; // [esp+8h] [ebp-4h] BYREF

  sub_1001FCF0(4u, (char *)&v5, a1);
  v2 = v5;
  if ( !v5 )
    return 0;
  v4 = (char *)sub_1001A580(*a1, (void **)a1[2], v5);
  if ( sub_1001A4E0((int)a1[1], v4, v2) )
    sub_1001B4B0(*a1, "unexpected end of file in %s", (int)a1[4]);
  return sub_100194B0((int)*a1, v4, v2 - 1);
}

//----- (1001FED0) --------------------------------------------------------
unsigned int __usercall sub_1001FED0@<eax>(_DWORD **a1@<eax>, int a2@<ebx>)
{
  unsigned int v3; // edi
  char *v4; // eax
  int v6; // [esp+8h] [ebp-4h] BYREF

  sub_1001FCF0(4u, (char *)&v6, a1);
  v3 = v6;
  if ( v6 < 0 )
    sub_1001B4B0(*a1, "bad integer in %s", (int)a1[4]);
  v4 = (char *)sub_1001B810(*a1, 0, 0, 4 * v6);
  *(_DWORD *)(a2 + 12) = v4;
  *(_DWORD *)(a2 + 44) = v3;
  return sub_1001FD80(v3, v4, a1, 4);
}

//----- (1001FF30) --------------------------------------------------------
void *__usercall sub_1001FF30@<eax>(_DWORD **a1@<eax>, int a2@<ebx>)
{
  int v3; // ebp
  void *result; // eax
  int v5; // edi
  int v6; // [esp+8h] [ebp-8h] BYREF
  void *v7; // [esp+Ch] [ebp-4h] BYREF

  sub_1001FCF0(4u, (char *)&v6, a1);
  v3 = v6;
  if ( v6 < 0 )
    sub_1001B4B0(*a1, "bad integer in %s", (int)a1[4]);
  result = sub_1001B810(*a1, 0, 0, 12 * v6);
  *(_DWORD *)(a2 + 24) = result;
  *(_DWORD *)(a2 + 56) = v3;
  if ( v3 > 0 )
  {
    v5 = 0;
    do
    {
      *(_DWORD *)(v5 + *(_DWORD *)(a2 + 24)) = sub_1001FE60(a1);
      sub_1001FCF0(4u, (char *)&v6, a1);
      if ( v6 < 0 )
        sub_1001B4B0(*a1, "bad integer in %s", (int)a1[4]);
      *(_DWORD *)(*(_DWORD *)(a2 + 24) + v5 + 4) = v6;
      sub_1001FCF0(4u, (char *)&v7, a1);
      if ( (int)v7 < 0 )
        sub_1001B4B0(*a1, "bad integer in %s", (int)a1[4]);
      result = v7;
      *(_DWORD *)(*(_DWORD *)(a2 + 24) + v5 + 8) = v7;
      v5 += 12;
      --v3;
    }
    while ( v3 );
  }
  return result;
}

//----- (10020020) --------------------------------------------------------
unsigned int __usercall sub_10020020@<eax>(_DWORD **a1@<eax>, int a2@<ebx>)
{
  unsigned int v3; // edi
  char *v4; // eax
  int v6; // [esp+8h] [ebp-4h] BYREF

  sub_1001FCF0(4u, (char *)&v6, a1);
  v3 = v6;
  if ( v6 < 0 )
    sub_1001B4B0(*a1, "bad integer in %s", (int)a1[4]);
  v4 = (char *)sub_1001B810(*a1, 0, 0, 4 * v6);
  *(_DWORD *)(a2 + 20) = v4;
  *(_DWORD *)(a2 + 48) = v3;
  return sub_1001FD80(v3, v4, a1, 4);
}

//----- (10020080) --------------------------------------------------------
void *__usercall sub_10020080@<eax>(_DWORD **a1@<eax>, int a2)
{
  int v2; // ebp
  int v4; // edi
  void *result; // eax
  int v6; // ebx

  v2 = a2;
  sub_1001FCF0(4u, (char *)&a2, a1);
  v4 = a2;
  if ( a2 < 0 )
    sub_1001B4B0(*a1, "bad integer in %s", (int)a1[4]);
  if ( a2 && a2 != *(unsigned __int8 *)(v2 + 68) )
    sub_1001B4B0(*a1, "bad nupvalues in %s: read %d; expected %d", (int)a1[4]);
  result = sub_1001B810(*a1, 0, 0, 4 * a2);
  v6 = 0;
  *(_DWORD *)(v2 + 28) = result;
  for ( *(_DWORD *)(v2 + 36) = v4; v6 < v4; ++v6 )
  {
    result = sub_1001FE60(a1);
    *(_DWORD *)(*(_DWORD *)(v2 + 28) + 4 * v6) = result;
  }
  return result;
}

//----- (10020120) --------------------------------------------------------
void *__usercall sub_10020120@<eax>(_DWORD **a1@<eax>, int a2)
{
  _DWORD *v2; // ebp
  int v4; // edi
  _DWORD *v5; // eax
  int v6; // edi
  bool v7; // zf
  _DWORD *v8; // eax
  unsigned __int8 *v9; // ecx
  int v10; // ebx
  int v11; // ebx
  void *result; // eax
  int v13; // edi
  int v14; // [esp+10h] [ebp-Ch]
  double v15; // [esp+14h] [ebp-8h] BYREF

  v2 = (_DWORD *)a2;
  sub_1001FCF0(4u, (char *)&a2, a1);
  v4 = a2;
  if ( a2 < 0 )
    sub_1001B4B0(*a1, "bad integer in %s", (int)a1[4]);
  v2[2] = sub_1001B810(*a1, 0, 0, 16 * a2);
  v2[10] = v4;
  if ( v4 > 0 )
  {
    a2 = 0;
    v14 = v4;
    do
    {
      v5 = a1[1];
      v6 = a2 + v2[2];
      v7 = (*v5)-- == 0;
      v8 = a1[1];
      if ( v7 )
      {
        v10 = sub_1001A420((int)a1[1]);
      }
      else
      {
        v9 = (unsigned __int8 *)v8[1];
        v10 = *v9;
        v8[1] = v9 + 1;
      }
      if ( v10 == -1 )
        sub_1001B4B0(*a1, "unexpected end of file in %s", (int)a1[4]);
      if ( (_BYTE)v10 )
      {
        if ( (unsigned __int8)v10 == 3 )
        {
          *(_DWORD *)v6 = 3;
          sub_1001FCF0(8u, (char *)&v15, a1);
          *(double *)(v6 + 8) = v15;
        }
        else
        {
          if ( (unsigned __int8)v10 != 4 )
            sub_1001B4B0(*a1, "bad constant type (%d) in %s", (unsigned __int8)v10);
          *(_DWORD *)v6 = 4;
          *(_DWORD *)(v6 + 8) = sub_1001FE60(a1);
        }
      }
      else
      {
        *(_DWORD *)v6 = 0;
      }
      v7 = v14 == 1;
      a2 += 16;
      --v14;
    }
    while ( !v7 );
  }
  sub_1001FCF0(4u, (char *)&a2, a1);
  v11 = a2;
  if ( a2 < 0 )
    sub_1001B4B0(*a1, "bad integer in %s", (int)a1[4]);
  result = sub_1001B810(*a1, 0, 0, 4 * a2);
  v13 = 0;
  v2[4] = result;
  for ( v2[13] = v11; v13 < v11; ++v13 )
  {
    result = sub_100202D0(a1, v2[8]);
    *(_DWORD *)(v2[4] + 4 * v13) = result;
  }
  return result;
}

//----- (100202D0) --------------------------------------------------------
_DWORD *__cdecl sub_100202D0(_DWORD **a1, int a2)
{
  _DWORD **v2; // esi
  _DWORD *v3; // edi
  _DWORD *v4; // eax
  _DWORD *v5; // eax
  bool v6; // zf
  int v7; // eax
  unsigned __int8 *v8; // ecx
  int v9; // ebx
  _DWORD *v10; // eax
  _DWORD *v11; // eax
  unsigned __int8 *v12; // ecx
  int v13; // ebx
  _DWORD *v14; // eax
  _DWORD *v15; // eax
  unsigned __int8 *v16; // ecx
  int v17; // ebx
  _DWORD *v18; // eax
  _DWORD *v19; // eax
  unsigned __int8 *v20; // ecx
  int v21; // ebx

  v2 = a1;
  v3 = sub_100196C0(*a1);
  v4 = sub_1001FE60(v2);
  v3[8] = v4;
  if ( !v4 )
    v3[8] = a2;
  sub_1001FCF0(4u, (char *)&a1, v2);
  if ( (int)a1 < 0 )
    sub_1001B4B0(*v2, "bad integer in %s", (int)v2[4]);
  v3[15] = a1;
  v5 = v2[1];
  v6 = (*v5)-- == 0;
  v7 = (int)v2[1];
  if ( v6 )
  {
    v9 = sub_1001A420(v7);
  }
  else
  {
    v8 = *(unsigned __int8 **)(v7 + 4);
    v9 = *v8;
    *(_DWORD *)(v7 + 4) = v8 + 1;
  }
  if ( v9 == -1 )
    sub_1001B4B0(*v2, "unexpected end of file in %s", (int)v2[4]);
  *((_BYTE *)v3 + 68) = v9;
  v10 = v2[1];
  v6 = (*v10)-- == 0;
  v11 = v2[1];
  if ( v6 )
  {
    v13 = sub_1001A420((int)v2[1]);
  }
  else
  {
    v12 = (unsigned __int8 *)v11[1];
    v13 = *v12;
    v11[1] = v12 + 1;
  }
  if ( v13 == -1 )
    sub_1001B4B0(*v2, "unexpected end of file in %s", (int)v2[4]);
  *((_BYTE *)v3 + 69) = v13;
  v14 = v2[1];
  v6 = (*v14)-- == 0;
  v15 = v2[1];
  if ( v6 )
  {
    v17 = sub_1001A420((int)v2[1]);
  }
  else
  {
    v16 = (unsigned __int8 *)v15[1];
    v17 = *v16;
    v15[1] = v16 + 1;
  }
  if ( v17 == -1 )
    sub_1001B4B0(*v2, "unexpected end of file in %s", (int)v2[4]);
  *((_BYTE *)v3 + 70) = v17;
  v18 = v2[1];
  v6 = (*v18)-- == 0;
  v19 = v2[1];
  if ( v6 )
  {
    v21 = sub_1001A420((int)v2[1]);
  }
  else
  {
    v20 = (unsigned __int8 *)v19[1];
    v21 = *v20;
    v19[1] = v20 + 1;
  }
  if ( v21 == -1 )
    sub_1001B4B0(*v2, "unexpected end of file in %s", (int)v2[4]);
  *((_BYTE *)v3 + 71) = v21;
  sub_10020020(v2, (int)v3);
  sub_1001FF30(v2, (int)v3);
  sub_10020080(v2, (int)v3);
  sub_10020120(v2, (int)v3);
  sub_1001FED0(v2, (int)v3);
  if ( !sub_1001B1A0((int)v3) )
    sub_1001B4B0(*v2, "bad code in %s", (int)v2[4]);
  return v3;
}

//----- (10020490) --------------------------------------------------------
char __usercall sub_10020490@<al>(_DWORD **a1@<esi>)
{
  const char *v1; // ebx
  _DWORD *v2; // eax
  bool v3; // zf
  _DWORD *v4; // eax
  unsigned __int8 *v5; // ecx
  int v6; // edi
  int v7; // eax

  v1 = "\x1BLua";
  while ( 1 )
  {
    v2 = a1[1];
    v3 = (*v2)-- == 0;
    v4 = a1[1];
    if ( v3 )
    {
      v6 = sub_1001A420((int)a1[1]);
    }
    else
    {
      v5 = (unsigned __int8 *)v4[1];
      v6 = *v5;
      v4[1] = v5 + 1;
    }
    if ( v6 == -1 )
      sub_1001B4B0(*a1, "unexpected end of file in %s", (int)a1[4]);
    v7 = *v1;
    if ( v6 != v7 )
      break;
    LOBYTE(v7) = *++v1;
    if ( !(_BYTE)v7 )
      return v7;
  }
  if ( *v1 )
    sub_1001B4B0(*a1, "bad signature in %s", (int)a1[4]);
  return v7;
}

//----- (10020510) --------------------------------------------------------
int __usercall sub_10020510@<eax>(int a1@<edi>, _DWORD **a2@<esi>)
{
  _DWORD *v2; // eax
  bool v3; // zf
  _DWORD *v4; // eax
  unsigned __int8 *v5; // ecx
  int v6; // ebx
  int result; // eax

  v2 = a2[1];
  v3 = (*v2)-- == 0;
  v4 = a2[1];
  if ( v3 )
  {
    v6 = sub_1001A420((int)a2[1]);
  }
  else
  {
    v5 = (unsigned __int8 *)v4[1];
    v6 = *v5;
    v4[1] = v5 + 1;
  }
  if ( v6 == -1 )
    sub_1001B4B0(*a2, "unexpected end of file in %s", (int)a2[4]);
  result = (unsigned __int8)v6;
  if ( (unsigned __int8)v6 != a1 )
    sub_1001B4B0(*a2, "virtual machine mismatch in %s: size of %s is %d but read %d", (int)a2[4]);
  return result;
}

//----- (10020580) --------------------------------------------------------
int sub_10020580()
{
  return 1;
}

//----- (10020590) --------------------------------------------------------
unsigned __int64 __usercall sub_10020590@<edx:eax>(_DWORD **a1@<eax>)
{
  _DWORD *v2; // eax
  bool v3; // zf
  _DWORD *v4; // eax
  unsigned __int8 *v5; // ecx
  int v6; // ebx
  _DWORD *v7; // eax
  _DWORD *v8; // eax
  unsigned __int8 *v9; // ecx
  int v10; // ebx
  unsigned __int64 result; // rax
  double v12; // [esp+Ch] [ebp-8h] BYREF

  sub_10020490(a1);
  v2 = a1[1];
  v3 = (*v2)-- == 0;
  v4 = a1[1];
  if ( v3 )
  {
    v6 = sub_1001A420((int)a1[1]);
  }
  else
  {
    v5 = (unsigned __int8 *)v4[1];
    v6 = *v5;
    v4[1] = v5 + 1;
  }
  if ( v6 == -1 )
    sub_1001B4B0(*a1, "unexpected end of file in %s", (int)a1[4]);
  if ( (unsigned __int8)v6 > 0x50u )
    sub_1001B4B0(*a1, "%s too new: read version %d.%d; expected at most %d.%d", (int)a1[4]);
  if ( (unsigned __int8)v6 < 0x50u )
    sub_1001B4B0(*a1, "%s too old: read version %d.%d; expected at least %d.%d", (int)a1[4]);
  v7 = a1[1];
  v3 = (*v7)-- == 0;
  v8 = a1[1];
  if ( v3 )
  {
    v10 = sub_1001A420((int)a1[1]);
  }
  else
  {
    v9 = (unsigned __int8 *)v8[1];
    v10 = *v9;
    v8[1] = v9 + 1;
  }
  if ( v10 == -1 )
    sub_1001B4B0(*a1, "unexpected end of file in %s", (int)a1[4]);
  a1[3] = (_DWORD *)((_BYTE)v10 != 1);
  sub_10020510(4, a1);
  sub_10020510(4, a1);
  sub_10020510(4, a1);
  sub_10020510(6, a1);
  sub_10020510(8, a1);
  sub_10020510(9, a1);
  sub_10020510(9, a1);
  sub_10020510(8, a1);
  sub_1001FCF0(8u, (char *)&v12, a1);
  result = (unsigned __int64)v12;
  if ( (unsigned int)(unsigned __int64)v12 != 31415926 )
    sub_1001B4B0(*a1, "unknown number format in %s", (int)a1[4]);
  return result;
}

//----- (10020740) --------------------------------------------------------
_DWORD *__cdecl sub_10020740(_DWORD *a1, _DWORD *a2, _DWORD *a3)
{
  const char *v3; // ecx
  char v4; // al
  _DWORD *v6[4]; // [esp+0h] [ebp-14h] BYREF
  const char *v7; // [esp+10h] [ebp-4h]

  v3 = (const char *)a2[4];
  v4 = *v3;
  if ( *v3 == 64 || v4 == 61 )
  {
    ++v3;
    goto LABEL_6;
  }
  if ( v4 != 27 )
  {
LABEL_6:
    v7 = v3;
    goto LABEL_7;
  }
  v7 = "binary string";
LABEL_7:
  v6[0] = a1;
  v6[1] = a2;
  v6[2] = a3;
  sub_10020590(v6);
  return sub_100202D0(v6, 0);
}

//----- (100207A0) --------------------------------------------------------
int __usercall sub_100207A0@<eax>(int a1@<eax>, int a2@<ecx>, int *a3@<ebx>)
{
  int v3; // esi
  int *v4; // edi
  int result; // eax

  v3 = a1 - a2 - 1;
  v4 = (int *)(*(_DWORD *)(*a3 + 12) + 4 * a2);
  if ( (int)abs32(v3) > 0x1FFFF )
    sub_1001BE20(a3[3]);
  result = (*v4 ^ ((v3 + 0x1FFFF) << 6)) & 0xFFFFC0 ^ *v4;
  *v4 = result;
  return result;
}

//----- (100207F0) --------------------------------------------------------
int __cdecl sub_100207F0(int a1)
{
  int result; // eax

  result = *(_DWORD *)(a1 + 24);
  *(_DWORD *)(a1 + 28) = result;
  return result;
}

//----- (10020800) --------------------------------------------------------
int __usercall sub_10020800@<eax>(int a1@<eax>, int a2@<ecx>, int a3)
{
  int v3; // esi
  int v4; // edi
  _DWORD *v5; // ecx
  unsigned int *v6; // eax
  unsigned int v7; // eax

  v3 = a2;
  if ( a2 == -1 )
    return 0;
  v4 = *(_DWORD *)(*(_DWORD *)a1 + 12);
  while ( 1 )
  {
    v5 = (_DWORD *)(v4 + 4 * v3);
    if ( v3 < 1 || (v6 = v5 - 1, (byte_1003FC04[*(v5 - 1) & 0x3F] & 0x80) == 0) )
      v6 = (unsigned int *)(v4 + 4 * v3);
    v7 = *v6;
    if ( (v7 & 0x3F) != 24 || ((v7 >> 6) & 0x1FF) != a3 )
      break;
    if ( ((*v5 >> 6) & 0x3FFFF) != 131070 )
    {
      v3 += ((*v5 >> 6) & 0x3FFFF) - 0x1FFFF + 1;
      if ( v3 != -1 )
        continue;
    }
    return 0;
  }
  return 1;
}

//----- (10020880) --------------------------------------------------------
void __usercall sub_10020880(int a1@<edx>, int *a2@<ebx>, int a3, int a4, int a5, int a6, int a7)
{
  _DWORD *v7; // edi
  int v8; // eax
  int *v9; // esi
  unsigned int v10; // eax
  int v11; // esi
  int v12; // ecx
  int v13; // esi
  int v14; // ecx
  int v15; // [esp+0h] [ebp-4h]

  if ( a1 != -1 )
  {
    do
    {
      v7 = (_DWORD *)(*(_DWORD *)(*a2 + 12) + 4 * a1);
      v8 = ((*v7 >> 6) & 0x3FFFF) - 0x1FFFF;
      if ( ((*v7 >> 6) & 0x3FFFF) != 131070 )
        v8 += a1 + 1;
      v15 = v8;
      if ( a1 < 1 || (v9 = v7 - 1, byte_1003FC04[*(v7 - 1) & 0x3F] >= 0) )
        v9 = (int *)(*(_DWORD *)(*a2 + 12) + 4 * a1);
      v10 = *v9;
      if ( (*(_BYTE *)v9 & 0x3F) == 24 )
      {
        if ( (v10 & 0x7FC0) != 0 )
        {
          v12 = a4;
          if ( a4 == 255 )
            v12 = (v10 >> 15) & 0x1FF;
          *v9 = (v12 << 24) | v10 & 0xFFFFFF;
          v13 = a3;
        }
        else
        {
          v14 = a6;
          if ( a6 == 255 )
            v14 = (v10 >> 15) & 0x1FF;
          *v9 = (v14 << 24) | v10 & 0xFFFFFF;
          v13 = a5;
        }
        v7 = (_DWORD *)(4 * a1 + *(_DWORD *)(*a2 + 12));
        v11 = v13 - a1 - 1;
        if ( (int)abs32(v11) > 0x1FFFF )
          sub_1001BE20(a2[3]);
      }
      else
      {
        v11 = a7 - a1 - 1;
        if ( (int)abs32(v11) > 0x1FFFF )
          sub_1001BE20(a2[3]);
      }
      a1 = v15;
      *v7 ^= (*v7 ^ ((v11 + 0x1FFFF) << 6)) & 0xFFFFC0;
    }
    while ( v15 != -1 );
  }
}

//----- (100209C0) --------------------------------------------------------
int __cdecl sub_100209C0(int *a1, int *a2, int a3)
{
  int result; // eax
  int v4; // ecx
  int i; // esi

  result = a3;
  if ( a3 != -1 )
  {
    v4 = *a2;
    if ( *a2 == -1 )
    {
      *a2 = a3;
    }
    else
    {
      for ( i = *(_DWORD *)(*a1 + 12);
            ((*(_DWORD *)(i + 4 * v4) >> 6) & 0x3FFFF) != 131070
         && ((*(_DWORD *)(i + 4 * v4) >> 6) & 0x3FFFF) - 0x1FFFF + v4 != -2;
            v4 += ((*(_DWORD *)(i + 4 * v4) >> 6) & 0x3FFFF) - 0x1FFFF + 1 )
      {
        ;
      }
      return sub_100207A0(a3, v4, a1);
    }
  }
  return result;
}

//----- (10020A10) --------------------------------------------------------
int __cdecl sub_10020A10(int *a1, int a2)
{
  int result; // eax
  int v3; // ebx

  result = *a1;
  v3 = a2 + a1[9];
  if ( v3 > *(unsigned __int8 *)(*a1 + 71) )
  {
    if ( v3 >= 250 )
      sub_1001BE20(a1[3]);
    result = *a1;
    *(_BYTE *)(*a1 + 71) = v3;
  }
  return result;
}

//----- (10020A50) --------------------------------------------------------
int __cdecl sub_10020A50(int *a1, int a2)
{
  int v2; // ebx
  int result; // eax

  v2 = a2 + a1[9];
  if ( v2 > *(unsigned __int8 *)(*a1 + 71) )
  {
    if ( v2 >= 250 )
      sub_1001BE20(a1[3]);
    *(_BYTE *)(*a1 + 71) = v2;
  }
  result = a2 + a1[9];
  a1[9] = result;
  return result;
}

//----- (10020AA0) --------------------------------------------------------
int __usercall sub_10020AA0@<eax>(_DWORD *a1@<edi>, int *a2@<esi>, double *a3)
{
  double *v3; // eax
  __int64 v4; // rax
  int v5; // ebx
  _DWORD *v6; // eax

  v3 = (double *)sub_10019DF0(a2[1], a3);
  if ( *(_DWORD *)v3 == 3 )
  {
    return (unsigned __int64)v3[1];
  }
  else
  {
    v5 = *a2;
    if ( a2[10] + 1 > *(_DWORD *)(*a2 + 40) )
      *(_DWORD *)(v5 + 8) = sub_1001B8A0(
                              (_DWORD *)a2[4],
                              *(void **)(v5 + 8),
                              (int *)(*a2 + 40),
                              16,
                              0x3FFFF,
                              "constant table overflow");
    v6 = (_DWORD *)(*(_DWORD *)(v5 + 8) + 16 * a2[10]);
    *v6 = *a1;
    v6[2] = a1[2];
    v6[3] = a1[3];
    LODWORD(v4) = sub_10019E50((_DWORD *)a2[4], a2[1], a3);
    *(_DWORD *)v4 = 3;
    *(double *)(v4 + 8) = (double)a2[10];
    LODWORD(v4) = a2[10];
    a2[10] = v4 + 1;
  }
  return v4;
}

//----- (10020B40) --------------------------------------------------------
int __cdecl sub_10020B40(int *a1, int a2)
{
  double v3; // [esp+8h] [ebp-10h] BYREF
  int v4; // [esp+10h] [ebp-8h]

  LODWORD(v3) = 4;
  v4 = a2;
  return sub_10020AA0(&v3, a1, &v3);
}
// 10020B40: using guessed type double var_10;

//----- (10020B70) --------------------------------------------------------
int __cdecl sub_10020B70(int *a1, double a2)
{
  double v3[2]; // [esp+0h] [ebp-10h] BYREF

  v3[1] = a2;
  LODWORD(v3[0]) = 3;
  return sub_10020AA0(v3, a1, v3);
}

//----- (10020BA0) --------------------------------------------------------
int __usercall sub_10020BA0@<eax>(int *a1@<eax>)
{
  int v2; // eax
  double v4; // [esp+8h] [ebp-20h] BYREF
  int v5; // [esp+10h] [ebp-18h]
  int v6[4]; // [esp+18h] [ebp-10h] BYREF

  v2 = a1[1];
  v6[0] = 0;
  LODWORD(v4) = 5;
  v5 = v2;
  return sub_10020AA0(v6, a1, &v4);
}
// 10020BA0: using guessed type double var_20;
// 10020BA0: using guessed type int var_10[4];

//----- (10020BE0) --------------------------------------------------------
int *__cdecl sub_10020BE0(int a1, _DWORD *a2, int a3)
{
  int v3; // eax
  int v4; // edx
  int v5; // ebx
  int *result; // eax
  int v7; // eax

  if ( *a2 == 12 )
  {
    v3 = a2[1];
    v4 = *(_DWORD *)(*(_DWORD *)a1 + 12);
    v5 = *(_DWORD *)(v4 + 4 * v3);
    result = (int *)(v4 + 4 * v3);
    *result = ((unsigned __int16)v5 ^ (unsigned __int16)(((_WORD)a3 + 1) << 6)) & 0x7FC0 ^ v5;
    if ( a3 == 1 )
    {
      v7 = a2[1];
      *a2 = 11;
      result = (int *)*(unsigned __int8 *)(*(_DWORD *)(*(_DWORD *)a1 + 12) + 4 * v7 + 3);
      a2[1] = result;
    }
  }
  return result;
}

//----- (10020C40) --------------------------------------------------------
int __usercall sub_10020C40@<eax>(int a1@<eax>, int a2@<ecx>)
{
  int v2; // eax
  int *v3; // ecx
  int result; // eax

  v2 = *(_DWORD *)(a1 + 4);
  v3 = (int *)(*(_DWORD *)(*(_DWORD *)a2 + 12) + 4 * v2);
  if ( v2 >= 1 && byte_1003FC04[*(v3 - 1) & 0x3F] < 0 )
    --v3;
  result = *v3 & 0xFFFFFF;
  *v3 = result | (((*v3 & 0xFF000000) == 0) << 24);
  return result;
}

//----- (10020C90) --------------------------------------------------------
int __cdecl sub_10020C90(_DWORD *a1, int a2)
{
  int result; // eax

  result = *(_DWORD *)(*a1 + 20);
  *(_DWORD *)(result + 4 * a1[6] - 4) = a2;
  return result;
}

//----- (10020CB0) --------------------------------------------------------
int __cdecl sub_10020CB0(int a1, int a2, int a3)
{
  int v3; // esi
  int v4; // ecx
  int result; // eax

  v3 = *(_DWORD *)a1;
  sub_10020880(
    *(_DWORD *)(a1 + 32),
    (int *)a1,
    *(_DWORD *)(a1 + 24),
    255,
    *(_DWORD *)(a1 + 24),
    255,
    *(_DWORD *)(a1 + 24));
  v4 = *(_DWORD *)(a1 + 24);
  *(_DWORD *)(a1 + 32) = -1;
  if ( v4 + 1 > *(_DWORD *)(v3 + 44) )
    *(_DWORD *)(v3 + 12) = sub_1001B8A0(
                             *(_DWORD **)(a1 + 16),
                             *(void **)(v3 + 12),
                             (int *)(v3 + 44),
                             4,
                             2147483645,
                             "code size overflow");
  *(_DWORD *)(*(_DWORD *)(v3 + 12) + 4 * *(_DWORD *)(a1 + 24)) = a2;
  if ( *(_DWORD *)(a1 + 24) + 1 > *(_DWORD *)(v3 + 48) )
    *(_DWORD *)(v3 + 20) = sub_1001B8A0(
                             *(_DWORD **)(a1 + 16),
                             *(void **)(v3 + 20),
                             (int *)(v3 + 48),
                             4,
                             2147483645,
                             "code size overflow");
  *(_DWORD *)(*(_DWORD *)(v3 + 20) + 4 * *(_DWORD *)(a1 + 24)) = a3;
  result = *(_DWORD *)(a1 + 24);
  *(_DWORD *)(a1 + 24) = result + 1;
  return result;
}

//----- (10020D60) --------------------------------------------------------
int __cdecl sub_10020D60(int a1, int a2, int a3, int a4, int a5)
{
  return sub_10020CB0(a1, a2 | ((a5 | ((a4 | (a3 << 9)) << 9)) << 6), *(_DWORD *)(*(_DWORD *)(a1 + 12) + 8));
}

//----- (10020DA0) --------------------------------------------------------
int __cdecl sub_10020DA0(int a1, int a2, int a3, int a4)
{
  return sub_10020CB0(a1, a2 | ((a4 | (a3 << 18)) << 6), *(_DWORD *)(*(_DWORD *)(a1 + 12) + 8));
}

//----- (10020DD0) --------------------------------------------------------
int __cdecl sub_10020DD0(_DWORD *a1, int a2, int a3)
{
  int v3; // ecx
  int result; // eax
  int *v5; // edi
  unsigned int v6; // ecx
  int v7; // edx

  v3 = a1[6];
  result = a2;
  if ( v3 <= a1[7] )
    return sub_10020CB0((int)a1, (((a2 << 9) | (a2 + a3 - 1)) << 15) | 3, *(_DWORD *)(a1[3] + 8));
  v5 = (int *)(*(_DWORD *)(*a1 + 12) + 4 * v3 - 4);
  v6 = *v5;
  if ( (*(_BYTE *)v5 & 0x3F) != 3 )
    return sub_10020CB0((int)a1, (((a2 << 9) | (a2 + a3 - 1)) << 15) | 3, *(_DWORD *)(a1[3] + 8));
  v7 = (v6 >> 15) & 0x1FF;
  if ( (int)HIBYTE(v6) > a2 || a2 > v7 + 1 )
    return sub_10020CB0((int)a1, (((a2 << 9) | (a2 + a3 - 1)) << 15) | 3, *(_DWORD *)(a1[3] + 8));
  if ( a2 + a3 - 1 > v7 )
  {
    result = v6 ^ (v6 ^ ((a2 + a3 - 1) << 15)) & 0xFF8000;
    *v5 = result;
  }
  return result;
}

//----- (10020E60) --------------------------------------------------------
int __cdecl sub_10020E60(int a1)
{
  int *v1; // esi
  int v2; // eax
  int v3; // edi

  v1 = (int *)a1;
  v2 = *(_DWORD *)(a1 + 12);
  v3 = *(_DWORD *)(a1 + 32);
  *(_DWORD *)(a1 + 32) = -1;
  a1 = sub_10020CB0((int)v1, 8388500, *(_DWORD *)(v2 + 8));
  sub_100209C0(v1, &a1, v3);
  return a1;
}

//----- (10020EA0) --------------------------------------------------------
int __usercall sub_10020EA0@<eax>(int a1@<eax>, int *a2@<esi>, int a3, int a4, int a5)
{
  int v5; // edi
  int v6; // eax

  sub_10020CB0((int)a2, a3 | ((a5 | ((a4 | (a1 << 9)) << 9)) << 6), *(_DWORD *)(a2[3] + 8));
  v5 = a2[8];
  v6 = a2[3];
  a2[8] = -1;
  a4 = sub_10020CB0((int)a2, 8388500, *(_DWORD *)(v6 + 8));
  sub_100209C0(a2, &a4, v5);
  return a4;
}

//----- (10020F00) --------------------------------------------------------
int __cdecl sub_10020F00(int *a1, int a2)
{
  a1[7] = a1[6];
  return sub_100209C0(a1, a1 + 8, a2);
}

//----- (10020F20) --------------------------------------------------------
int *__cdecl sub_10020F20(int a1, _DWORD *a2)
{
  int *result; // eax
  int v3; // eax
  int v4; // ecx
  int v5; // eax

  result = (int *)(*a2 - 5);
  switch ( *a2 )
  {
    case 5:
      *a2 = 11;
      break;
    case 6:
      result = (int *)sub_10020D60(a1, 4, 0, a2[1], 0);
      goto LABEL_12;
    case 7:
      result = (int *)sub_10020DA0(a1, 5, 0, a2[1]);
      a2[1] = result;
      *a2 = 10;
      break;
    case 8:
      v3 = a2[2];
      v4 = *(_DWORD *)(a1 + 52);
      if ( v3 >= v4 && v3 < 250 )
        --*(_DWORD *)(a1 + 36);
      v5 = a2[1];
      if ( v5 >= v4 && v5 < 250 )
        --*(_DWORD *)(a1 + 36);
      result = (int *)sub_10020D60(a1, 6, 0, a2[1], a2[2]);
LABEL_12:
      a2[1] = result;
      *a2 = 10;
      break;
    case 0xC:
      result = sub_10020BE0(a1, a2, 1);
      break;
    default:
      return result;
  }
  return result;
}

//----- (10020FF0) --------------------------------------------------------
int *__usercall sub_10020FF0@<eax>(int a1@<ebx>, _DWORD *a2@<edi>, int a3@<esi>)
{
  int *result; // eax
  int v4; // [esp+0h] [ebp-8h]
  _DWORD *v5; // [esp+4h] [ebp-4h]

  sub_10020F20(v4, v5);
  result = *(int **)a1;
  switch ( *(_DWORD *)a1 )
  {
    case 1:
      result = (int *)sub_10020DD0(a2, a3, 1);
      *(_DWORD *)(a1 + 4) = a3;
      *(_DWORD *)a1 = 11;
      break;
    case 2:
    case 3:
      result = (int *)sub_10020D60((int)a2, 2, a3, result == (int *)2, 0);
      *(_DWORD *)(a1 + 4) = a3;
      *(_DWORD *)a1 = 11;
      break;
    case 4:
      result = (int *)sub_10020DA0((int)a2, 1, a3, *(_DWORD *)(a1 + 4));
      *(_DWORD *)(a1 + 4) = a3;
      *(_DWORD *)a1 = 11;
      break;
    case 0xA:
      result = (int *)(*(_DWORD *)(*a2 + 12) + 4 * *(_DWORD *)(a1 + 4));
      *result = (a3 << 24) | *result & 0xFFFFFF;
      *(_DWORD *)(a1 + 4) = a3;
      *(_DWORD *)a1 = 11;
      break;
    case 0xB:
      result = *(int **)(a1 + 4);
      if ( (int *)a3 != result )
        result = (int *)sub_10020D60((int)a2, 0, a3, (int)result, 0);
      *(_DWORD *)(a1 + 4) = a3;
      *(_DWORD *)a1 = 11;
      break;
    default:
      return result;
  }
  return result;
}
// 10020FF2: variable 'v4' is possibly undefined
// 10020FF2: variable 'v5' is possibly undefined

//----- (100210E0) --------------------------------------------------------
int *__usercall sub_100210E0@<eax>(int *result@<eax>, _DWORD *a2)
{
  int v2; // ebx
  int v3; // esi

  if ( *a2 != 11 )
  {
    v2 = result[9] + 1;
    if ( v2 > *(unsigned __int8 *)(*result + 71) )
    {
      if ( v2 >= 250 )
        sub_1001BE20(result[3]);
      *(_BYTE *)(*result + 71) = v2;
    }
    v3 = result[9];
    result[9] = v3 + 1;
    return sub_10020FF0((int)a2, result, v3);
  }
  return result;
}

//----- (10021140) --------------------------------------------------------
int __usercall sub_10021140@<eax>(int *a1@<eax>, _DWORD *a2, int a3)
{
  int v5; // ecx
  int v6; // esi
  int v7; // ebx
  int v8; // esi
  int v9; // eax
  int v10; // eax
  int v11; // ecx
  int v12; // esi
  int result; // eax
  int v14; // [esp+10h] [ebp-4h]
  int v15; // [esp+18h] [ebp+4h]

  sub_10020FF0((int)a2, a1, a3);
  if ( *a2 == 9 )
    sub_100209C0(a1, a2 + 3, a2[1]);
  v5 = a2[3];
  v6 = a2[4];
  if ( v5 != v6 )
  {
    v7 = -1;
    v15 = -1;
    if ( sub_10020800((int)a1, v5, 1) || sub_10020800((int)a1, v6, 0) )
    {
      v8 = -1;
      if ( *a2 != 9 )
        v8 = sub_10020E60((int)a1);
      v9 = a1[3];
      a1[7] = a1[6];
      v10 = sub_10020CB0((int)a1, (a3 << 24) | 0x42, *(_DWORD *)(v9 + 8));
      v11 = a1[3];
      v14 = v10;
      a1[7] = a1[6];
      v15 = sub_10020CB0((int)a1, (a3 << 24) | 0x8002, *(_DWORD *)(v11 + 8));
      a1[7] = a1[6];
      sub_100209C0(a1, a1 + 8, v8);
      v7 = v14;
    }
    v12 = a1[6];
    a1[7] = v12;
    sub_10020880(a2[4], a1, v7, 255, v12, a3, v7);
    sub_10020880(a2[3], a1, v12, a3, v15, 255, v15);
  }
  result = -1;
  a2[3] = -1;
  a2[4] = -1;
  a2[1] = a3;
  *a2 = 11;
  return result;
}

//----- (10021270) --------------------------------------------------------
int __cdecl sub_10021270(int *a1, _DWORD *a2)
{
  int v2; // eax
  int v3; // ebx
  int v5; // [esp-4h] [ebp-10h]

  sub_10020F20((int)a1, a2);
  if ( *a2 == 11 )
  {
    v2 = a2[1];
    if ( v2 >= a1[13] && v2 < 250 )
      --a1[9];
  }
  v3 = a1[9] + 1;
  if ( v3 > *(unsigned __int8 *)(*a1 + 71) )
  {
    if ( v3 >= 250 )
      sub_1001BE20(a1[3]);
    *(_BYTE *)(*a1 + 71) = v3;
  }
  v5 = a1[9];
  a1[9] = v5 + 1;
  return sub_10021140(a1, a2, v5);
}

//----- (100212F0) --------------------------------------------------------
int __cdecl sub_100212F0(int *a1, _DWORD *a2)
{
  int result; // eax

  sub_10020F20((int)a1, a2);
  if ( *a2 != 11 )
    goto LABEL_5;
  result = a2[1];
  if ( a2[3] == a2[4] )
    return result;
  if ( result >= a1[13] )
  {
    sub_10021140(a1, a2, a2[1]);
    return a2[1];
  }
  else
  {
LABEL_5:
    sub_10021270(a1, a2);
    return a2[1];
  }
}

//----- (10021340) --------------------------------------------------------
int *__cdecl sub_10021340(int *a1, _DWORD *a2)
{
  if ( a2[3] == a2[4] )
    return sub_10020F20((int)a1, a2);
  else
    return (int *)sub_100212F0(a1, a2);
}

//----- (10021360) --------------------------------------------------------
int __cdecl sub_10021360(int *a1, _DWORD *a2)
{
  int result; // eax
  int v3; // eax

  if ( a2[3] == a2[4] )
    sub_10020F20((int)a1, a2);
  else
    sub_100212F0(a1, a2);
  if ( *a2 == 1 )
  {
    if ( a1[10] + 250 <= 511 )
    {
      v3 = sub_10020BA0(a1);
      a2[1] = v3;
      *a2 = 4;
      return v3 + 250;
    }
    return sub_100212F0(a1, a2);
  }
  if ( *a2 != 4 )
    return sub_100212F0(a1, a2);
  result = a2[1] + 250;
  if ( result > 511 )
    return sub_100212F0(a1, a2);
  return result;
}

//----- (100213E0) --------------------------------------------------------
int __cdecl sub_100213E0(int *a1, _DWORD *a2, _DWORD *a3)
{
  int result; // eax
  int v4; // ecx
  int v5; // eax
  int v6; // eax
  int v7; // ebx
  int v8; // [esp-Ch] [ebp-18h]

  result = *a2 - 5;
  switch ( *a2 )
  {
    case 5:
      if ( *a3 == 11 )
      {
        v4 = a3[1];
        if ( v4 >= a1[13] && v4 < 250 )
          --a1[9];
      }
      return sub_10021140(a1, a3, a2[1]);
    case 6:
      v5 = sub_100212F0(a1, a3);
      result = sub_10020D60((int)a1, 8, v5, a2[1], 0);
      goto LABEL_10;
    case 7:
      v6 = sub_100212F0(a1, a3);
      result = sub_10020CB0((int)a1, ((a2[1] | (v6 << 18)) << 6) | 7, *(_DWORD *)(a1[3] + 8));
      goto LABEL_10;
    case 8:
      v8 = sub_10021360(a1, a3);
      result = sub_10020D60((int)a1, 9, a2[1], a2[2], v8);
      goto LABEL_10;
    default:
LABEL_10:
      if ( *a3 == 11 )
      {
        v7 = a3[1];
        if ( v7 >= a1[13] && v7 < 250 )
          --a1[9];
      }
      return result;
  }
}

//----- (100214C0) --------------------------------------------------------
int __cdecl sub_100214C0(int *a1, _DWORD *a2, int *a3)
{
  int v3; // eax
  int v4; // ebp
  int v5; // ebx
  int v6; // eax
  int result; // eax
  int v8; // ebx

  sub_10020F20((int)a1, a2);
  if ( *a2 != 11 )
    goto LABEL_5;
  if ( a2[3] != a2[4] )
  {
    if ( a2[1] >= a1[13] )
    {
      sub_10021140(a1, a2, a2[1]);
      goto LABEL_6;
    }
LABEL_5:
    sub_10021270(a1, a2);
  }
LABEL_6:
  if ( *a2 == 11 )
  {
    v3 = a2[1];
    if ( v3 >= a1[13] && v3 < 250 )
      --a1[9];
  }
  v4 = a1[9];
  v5 = v4 + 2;
  if ( v4 + 2 > *(unsigned __int8 *)(*a1 + 71) )
  {
    if ( v5 >= 250 )
      sub_1001BE20(a1[3]);
    *(_BYTE *)(*a1 + 71) = v5;
  }
  a1[9] += 2;
  v6 = sub_10021360(a1, a3);
  sub_10020CB0((int)a1, ((v6 | ((a2[1] | (v4 << 9)) << 9)) << 6) | 0xB, *(_DWORD *)(a1[3] + 8));
  result = *a3;
  if ( *a3 == 11 )
  {
    v8 = a3[1];
    if ( v8 >= a1[13] && v8 < 250 )
      --a1[9];
  }
  a2[1] = v4;
  *a2 = 11;
  return result;
}

//----- (100215B0) --------------------------------------------------------
int __usercall sub_100215B0@<eax>(int *a1@<eax>, int a2@<ebx>, _DWORD *a3@<edi>)
{
  unsigned int v4; // eax
  int v6; // eax

  if ( *a3 == 10 && (v4 = *(_DWORD *)(*(_DWORD *)(*a1 + 12) + 4 * a3[1]), (v4 & 0x3F) == 18) )
  {
    --a1[6];
    return sub_10020EA0(255, a1, 24, (v4 >> 15) & 0x1FF, a2 == 0);
  }
  else
  {
    sub_100210E0(a1, a3);
    if ( *a3 == 11 )
    {
      v6 = a3[1];
      if ( v6 >= a1[13] && v6 < 250 )
        --a1[9];
    }
    return sub_10020EA0(255, a1, 24, a3[1], a2);
  }
}

//----- (10021630) --------------------------------------------------------
int __cdecl sub_10021630(int *a1, _DWORD *a2)
{
  int result; // eax
  int v3; // eax
  int v4; // eax

  sub_10020F20((int)a1, a2);
  switch ( *a2 )
  {
    case 2:
    case 4:
      result = sub_100209C0(a1, a2 + 4, -1);
      break;
    case 3:
      v3 = sub_10020E60((int)a1);
      result = sub_100209C0(a1, a2 + 4, v3);
      break;
    case 9:
      sub_10020C40((int)a2, (int)a1);
      result = sub_100209C0(a1, a2 + 4, a2[1]);
      break;
    default:
      v4 = sub_100215B0(a1, 0, a2);
      result = sub_100209C0(a1, a2 + 4, v4);
      break;
  }
  return result;
}

//----- (100216E0) --------------------------------------------------------
int __cdecl sub_100216E0(int *a1, _DWORD *a2)
{
  int result; // eax
  int v3; // eax
  int v4; // eax

  sub_10020F20((int)a1, a2);
  switch ( *a2 )
  {
    case 1:
    case 3:
      result = sub_100209C0(a1, a2 + 3, -1);
      break;
    case 2:
      v3 = sub_10020E60((int)a1);
      result = sub_100209C0(a1, a2 + 3, v3);
      break;
    case 9:
      result = sub_100209C0(a1, a2 + 3, a2[1]);
      break;
    default:
      v4 = sub_100215B0(a1, 1, a2);
      result = sub_100209C0(a1, a2 + 3, v4);
      break;
  }
  return result;
}

//----- (10021790) --------------------------------------------------------
int __usercall sub_10021790@<eax>(int *a1@<edi>, _DWORD *a2@<esi>)
{
  int result; // eax
  int v3; // edx
  int v4; // edx
  int v5; // eax
  int v6; // [esp+0h] [ebp-8h]
  _DWORD *v7; // [esp+4h] [ebp-4h]

  sub_10020F20(v6, v7);
  switch ( *a2 )
  {
    case 1:
    case 3:
      result = a2[4];
      v3 = a2[3];
      *a2 = 2;
      a2[4] = v3;
      a2[3] = result;
      break;
    case 2:
    case 4:
      result = a2[4];
      v4 = a2[3];
      *a2 = 3;
      a2[4] = v4;
      a2[3] = result;
      break;
    case 9:
      sub_10020C40((int)a2, (int)a1);
      result = a2[4];
      a2[4] = a2[3];
      a2[3] = result;
      break;
    case 0xA:
    case 0xB:
      sub_100210E0(a1, a2);
      if ( *a2 == 11 )
      {
        v5 = a2[1];
        if ( v5 >= a1[13] && v5 < 250 )
          --a1[9];
      }
      a2[1] = sub_10020D60((int)a1, 18, 0, a2[1], 0);
      *a2 = 10;
      goto LABEL_10;
    default:
LABEL_10:
      result = a2[4];
      a2[4] = a2[3];
      a2[3] = result;
      break;
  }
  return result;
}
// 10021792: variable 'v6' is possibly undefined
// 10021792: variable 'v7' is possibly undefined

//----- (10021860) --------------------------------------------------------
int __cdecl sub_10021860(int *a1, _DWORD *a2, _DWORD *a3)
{
  int result; // eax

  result = sub_10021360(a1, a3);
  a2[2] = result;
  *a2 = 8;
  return result;
}

//----- (10021880) --------------------------------------------------------
int __cdecl sub_10021880(int *a1, int a2, _DWORD *a3)
{
  int v3; // eax
  int result; // eax
  int v5; // eax

  if ( a2 )
    return sub_10021790(a1, a3);
  if ( a3[3] == a3[4] )
    sub_10020F20((int)a1, a3);
  else
    sub_100212F0(a1, a3);
  if ( *a3 == 4 && (v3 = 16 * a3[1] + *(_DWORD *)(*a1 + 8), *(_DWORD *)v3 == 3) )
  {
    result = sub_10020B70(a1, -*(double *)(v3 + 8));
    a3[1] = result;
  }
  else
  {
    sub_100212F0(a1, a3);
    if ( *a3 == 11 )
    {
      v5 = a3[1];
      if ( v5 >= a1[13] && v5 < 250 )
        --a1[9];
    }
    result = sub_10020CB0((int)a1, (a3[1] << 15) | 0x11, *(_DWORD *)(a1[3] + 8));
    a3[1] = result;
    *a3 = 10;
  }
  return result;
}

//----- (10021940) --------------------------------------------------------
int __cdecl sub_10021940(int *a1, int a2, _DWORD *a3)
{
  int result; // eax
  int v4; // [esp-14h] [ebp-14h]
  int v5; // [esp-14h] [ebp-14h]

  switch ( a2 )
  {
    case 5:
      return sub_10021270(a1, a3);
    case 12:
      sub_10021630(a1, a3);
      v5 = a3[3];
      a1[7] = a1[6];
      result = sub_100209C0(a1, a1 + 8, v5);
      a3[3] = -1;
      break;
    case 13:
      sub_100216E0(a1, a3);
      v4 = a3[4];
      a1[7] = a1[6];
      result = sub_100209C0(a1, a1 + 8, v4);
      a3[4] = -1;
      break;
    default:
      return sub_10021360(a1, a3);
  }
  return result;
}

//----- (100219E0) --------------------------------------------------------
int __usercall sub_100219E0@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>, _DWORD *a4@<edi>, int *a5)
{
  int v5; // ebx
  int result; // eax
  int v7; // eax
  int v8; // ebp

  v5 = a1;
  if ( a2 > 4 )
  {
    v7 = 1;
    if ( a2 < 10 )
    {
      v7 = a2 != 6;
    }
    else
    {
      v8 = a3;
      a3 = v5;
      v5 = v8;
    }
    result = sub_10020EA0(v7, a5, dword_1003FC10[a2], a3, v5);
    *a4 = 9;
    a4[1] = result;
  }
  else
  {
    result = sub_10020CB0((int)a5, (a2 + 12) | ((a1 | (a3 << 9)) << 6), *(_DWORD *)(a5[3] + 8));
    *a4 = 10;
    a4[1] = result;
  }
  return result;
}
// 1003FC10: using guessed type int dword_1003FC10[12];

//----- (10021A50) --------------------------------------------------------
int __cdecl sub_10021A50(int *a1, int a2, int *a3, int *a4)
{
  int v4; // ebp
  int v5; // eax
  int v6; // ebx
  int v7; // ecx
  int result; // eax
  int v9; // eax
  int v10; // edx
  int v11; // eax
  int v12; // eax

  switch ( a2 )
  {
    case 5:
      if ( a4[3] == a4[4] )
        sub_10020F20((int)a1, a4);
      else
        sub_100212F0(a1, a4);
      if ( *a4 == 10 && (v9 = *a1, (*(_BYTE *)(*(_DWORD *)(*a1 + 12) + 4 * a4[1]) & 0x3F) == 19) )
      {
        if ( *a3 == 11 )
        {
          v10 = a3[1];
          if ( v10 >= a1[13] && v10 < 250 )
            --a1[9];
        }
        *(_DWORD *)(*(_DWORD *)(v9 + 12) + 4 * a4[1]) ^= (*(_DWORD *)(*(_DWORD *)(v9 + 12) + 4 * a4[1]) ^ (a3[1] << 15)) & 0xFF8000;
        result = *a4;
        *a3 = *a4;
        a3[1] = a4[1];
      }
      else
      {
        sub_10021270(a1, a4);
        if ( *a4 == 11 )
        {
          v11 = a4[1];
          if ( v11 >= a1[13] && v11 < 250 )
            --a1[9];
        }
        if ( *a3 == 11 )
        {
          v12 = a3[1];
          if ( v12 >= a1[13] && v12 < 250 )
            --a1[9];
        }
        result = sub_10020CB0((int)a1, ((a4[1] | (a3[1] << 9)) << 6) | 0x13, *(_DWORD *)(a1[3] + 8));
        a3[1] = result;
        *a3 = 10;
      }
      break;
    case 12:
      sub_10020F20((int)a1, a4);
      sub_100209C0(a1, a3 + 4, a4[4]);
      *a3 = *a4;
      result = a4[1];
      a3[1] = result;
      a3[2] = a4[2];
      a3[3] = a4[3];
      break;
    case 13:
      sub_10020F20((int)a1, a4);
      sub_100209C0(a1, a3 + 3, a4[3]);
      *a3 = *a4;
      result = a4[1];
      a3[1] = result;
      a3[2] = a4[2];
      a3[4] = a4[4];
      break;
    default:
      v4 = sub_10021360(a1, a3);
      v5 = sub_10021360(a1, a4);
      if ( *a4 == 11 )
      {
        v6 = a4[1];
        if ( v6 >= a1[13] && v6 < 250 )
          --a1[9];
      }
      if ( *a3 == 11 )
      {
        v7 = a3[1];
        if ( v7 >= a1[13] && v7 < 250 )
          --a1[9];
      }
      return sub_100219E0(v5, a2, v4, a3, a1);
  }
  return result;
}

//----- (10021C50) --------------------------------------------------------
void __cdecl sub_10021C50(int *a1, int a2, int a3)
{
  int v3; // ecx

  v3 = a1[6];
  if ( a3 == v3 )
  {
    a1[7] = v3;
    sub_100209C0(a1, a1 + 8, a2);
  }
  else
  {
    sub_10020880(a2, a1, a3, 255, a3, 255, a3);
  }
}

//----- (10021CA0) --------------------------------------------------------
bool __stdcall sub_10021CA0(int a1)
{
  if ( !(a1 % 400) )
    return 1;
  if ( a1 % 100 )
    return a1 % 4 == 0;
  return 0;
}

//----- (10021CF0) --------------------------------------------------------
int __stdcall sub_10021CF0(int a1, char a2, int *a3)
{
  int v3; // eax
  int v5; // ecx

  v3 = a1;
  if ( a1 < 0 )
    return 0;
  if ( a2 )
  {
    if ( a1 > 365 )
      v3 = a1 % 365;
    v5 = 0;
    while ( v3 >= word_1004AD44[v5] )
    {
      if ( v3 < word_1004AD46[v5] )
      {
        ++v5;
        break;
      }
      if ( v3 < word_1004AD48[v5] )
      {
        v5 += 2;
        break;
      }
      if ( v3 < word_1004AD4A[v5] )
      {
        v5 += 3;
        break;
      }
      if ( v3 < word_1004AD4C[v5] )
      {
        v5 += 4;
        break;
      }
      if ( v3 < word_1004AD4E[v5] )
      {
        v5 += 5;
        break;
      }
      v5 += 6;
      if ( v5 >= 12 )
        break;
    }
    if ( !v5 )
    {
LABEL_21:
      *a3 = v3;
      return v5 + 1;
    }
    *a3 = v3 - word_1004AD42[v5];
    return v5 + 1;
  }
  else
  {
    if ( a1 > 364 )
      v3 = a1 % 364;
    v5 = 0;
    while ( v3 >= word_1004AD2C[v5] )
    {
      if ( v3 < word_1004AD2E[v5] )
      {
        ++v5;
        break;
      }
      if ( v3 < word_1004AD30[v5] )
      {
        v5 += 2;
        break;
      }
      if ( v3 < word_1004AD32[v5] )
      {
        v5 += 3;
        break;
      }
      if ( v3 < word_1004AD34[v5] )
      {
        v5 += 4;
        break;
      }
      if ( v3 < word_1004AD36[v5] )
      {
        v5 += 5;
        break;
      }
      v5 += 6;
      if ( v5 >= 12 )
        break;
    }
    if ( !v5 )
      goto LABEL_21;
    *a3 = v3 - word_1004AD2A[v5];
    return v5 + 1;
  }
}
// 1004AD2A: using guessed type __int16 word_1004AD2A[];
// 1004AD2C: using guessed type __int16 word_1004AD2C[];
// 1004AD2E: using guessed type __int16 word_1004AD2E[];
// 1004AD30: using guessed type __int16 word_1004AD30[];
// 1004AD32: using guessed type __int16 word_1004AD32[];
// 1004AD34: using guessed type __int16 word_1004AD34[];
// 1004AD36: using guessed type __int16 word_1004AD36[5];
// 1004AD42: using guessed type __int16 word_1004AD42[];
// 1004AD44: using guessed type __int16 word_1004AD44[];
// 1004AD46: using guessed type __int16 word_1004AD46[];
// 1004AD48: using guessed type __int16 word_1004AD48[];
// 1004AD4A: using guessed type __int16 word_1004AD4A[];
// 1004AD4C: using guessed type __int16 word_1004AD4C[];
// 1004AD4E: using guessed type __int16 word_1004AD4E[93];

//----- (10021E50) --------------------------------------------------------
int __stdcall sub_10021E50(int a1)
{
  if ( a1 % 400 && (!(a1 % 100) || a1 % 4) )
    return 365;
  else
    return 366;
}

//----- (10021EA0) --------------------------------------------------------
BOOL __thiscall sub_10021EA0(_DWORD *this, _DWORD *a2)
{
  if ( *this < *a2 )
    return 1;
  if ( *this <= *a2 )
    return this[1] < a2[1];
  return 0;
}

//----- (10021EE0) --------------------------------------------------------
_DWORD *__thiscall sub_10021EE0(_DWORD *this)
{
  _DWORD *result; // eax

  result = this;
  *this = &off_1003FC94;
  this[2] = 0;
  this[1] = 0;
  return result;
}
// 1003FC94: using guessed type int (__stdcall *off_1003FC94)(int);

//----- (10021F00) --------------------------------------------------------
DWORD __thiscall sub_10021F00(_DWORD *this, int a2)
{
  DWORD TickCount; // eax
  DWORD result; // eax

  TickCount = GetTickCount();
  this[1] = TickCount;
  result = a2 + TickCount;
  this[3] = a2;
  this[2] = result;
  return result;
}

//----- (10021F20) --------------------------------------------------------
int __thiscall sub_10021F20(int *this)
{
  int v2; // edi
  DWORD TickCount; // eax

  v2 = *this;
  TickCount = GetTickCount();
  return (*(int (__thiscall **)(int *, DWORD))(v2 + 8))(this, TickCount);
}

//----- (10021F40) --------------------------------------------------------
bool __thiscall sub_10021F40(_DWORD *this, unsigned int a2)
{
  unsigned int v2; // eax
  unsigned int v3; // ecx

  v2 = this[1];
  v3 = this[2];
  if ( v2 <= v3 )
  {
    if ( a2 < v2 )
      return 1;
  }
  else if ( a2 >= v2 )
  {
    return 0;
  }
  return a2 >= v3;
}

//----- (10021F70) --------------------------------------------------------
int __thiscall sub_10021F70(float *this)
{
  int result; // eax
  float v3; // edi
  DWORD v4; // eax

  result = *((_DWORD *)this + 3);
  if ( !result )
  {
    if ( 1.0 == this[5] )
    {
      v4 = *((_DWORD *)this + 2) - *((_DWORD *)this + 1) + GetTickCount();
    }
    else
    {
      v3 = *this;
      v4 = LODWORD(v3)
         + (unsigned __int64)((double)(*((_DWORD *)this + 2) - *((_DWORD *)this + 1) - LODWORD(v3) + GetTickCount())
                            * this[5]);
    }
    *(_DWORD *)this = v4;
    result = rand();
    LODWORD(this[*((unsigned __int8 *)this + 1052) + 6]) = result;
  }
  return result;
}

//----- (10021FE0) --------------------------------------------------------
void __thiscall sub_10021FE0(_DWORD *this)
{
  *this = &off_1003FCA0;
}
// 1003FCA0: using guessed type void *off_1003FCA0;

//----- (10021FF0) --------------------------------------------------------
__int64 __thiscall sub_10021FF0(unsigned __int16 *this)
{
  return 2678400000i64 * this[3]
       + 86400000i64 * this[4]
       + 3600000i64 * this[5]
       + 60000i64 * this[6]
       + 1000i64 * this[7]
       + this[8]
       + 32140800000i64 * (this[2] - 1900);
}

//----- (100220A0) --------------------------------------------------------
int __thiscall sub_100220A0(WORD *this)
{
  return sub_1000DE20(this + 2);
}

//----- (100220B0) --------------------------------------------------------
int __thiscall sub_100220B0(WORD *this, unsigned int a2)
{
  if ( a2 >= 0x18 )
    return 0;
  this[5] = a2;
  return sub_1000DE90(this + 2, 0i64);
}

//----- (100220E0) --------------------------------------------------------
int __thiscall sub_100220E0(WORD *this, unsigned int a2)
{
  if ( a2 >= 0x3C )
    return 0;
  this[6] = a2;
  return sub_1000DE90(this + 2, 0i64);
}

//----- (10022110) --------------------------------------------------------
int __thiscall sub_10022110(WORD *this, int a2)
{
  return sub_1000DE90(this + 2, 86400000i64 * a2);
}

//----- (10022140) --------------------------------------------------------
int __thiscall sub_10022140(WORD *this, int a2)
{
  return sub_1000DE90(this + 2, 60000i64 * a2);
}

//----- (10022170) --------------------------------------------------------
_DWORD *__thiscall sub_10022170(_DWORD *this)
{
  _DWORD *result; // eax
  int i; // ebp
  int v3; // edi
  int v4; // esi
  int v5; // ebx
  bool v6; // al

  result = this;
  *this = 0;
  this[1] = 0;
  if ( !dword_1004CAE0[0] )
  {
    for ( i = 0; i < 30; ++i )
    {
      v3 = 0;
      v4 = 2 * (5 * i + 900);
      v5 = 10;
      do
      {
        if ( v4 % 400 )
        {
          if ( v4 % 100 )
            v6 = v4 % 4 == 0;
          else
            v6 = 0;
        }
        else
        {
          v6 = 1;
        }
        v3 += v6 + 365;
        ++v4;
        --v5;
      }
      while ( v5 );
      if ( i )
        dword_1004CAE0[i] = v3 + dword_1004CADC[i];
      else
        dword_1004CAE0[0] = v3;
    }
    return this;
  }
  return result;
}
// 1004CADC: using guessed type int dword_1004CADC[];
// 1004CAE0: using guessed type int dword_1004CAE0[];

//----- (10022230) --------------------------------------------------------
_DWORD *__thiscall sub_10022230(_DWORD *this, int a2, int a3)
{
  _DWORD *result; // eax
  int i; // ebp
  int v5; // edi
  int v6; // esi
  int v7; // ebx
  bool v8; // al

  result = this;
  *this = a2;
  this[1] = a3;
  if ( !dword_1004CAE0[0] )
  {
    for ( i = 0; i < 30; ++i )
    {
      v5 = 0;
      v6 = 2 * (5 * i + 900);
      v7 = 10;
      do
      {
        if ( v6 % 400 )
        {
          if ( v6 % 100 )
            v8 = v6 % 4 == 0;
          else
            v8 = 0;
        }
        else
        {
          v8 = 1;
        }
        v5 += v8 + 365;
        ++v6;
        --v7;
      }
      while ( v7 );
      if ( i )
        dword_1004CAE0[i] = v5 + dword_1004CADC[i];
      else
        dword_1004CAE0[0] = v5;
    }
    return this;
  }
  return result;
}
// 1004CADC: using guessed type int dword_1004CADC[];
// 1004CAE0: using guessed type int dword_1004CAE0[];

//----- (100222F0) --------------------------------------------------------
char __thiscall sub_100222F0(int *this, int a2, int a3, int a4)
{
  bool v7; // al
  bool v8; // cc
  int i; // edi
  int v10; // eax
  int v11; // eax
  bool v12; // [esp+14h] [ebp+Ch]

  if ( a4 < 1800 || a4 > 2100 )
    return 0;
  if ( a3 < 1 || a3 > 12 )
    return 0;
  if ( a2 < 1 || a2 > 31 )
    return 0;
  v7 = sub_10021CA0(a4);
  v12 = v7;
  if ( a3 == 2 && v7 )
    v8 = a2 <= 29;
  else
    v8 = a2 <= byte_1004AD1F[a3];
  if ( !v8 )
    return 0;
  if ( a4 - 1800 <= 10 )
    *this = 0;
  else
    *this = dword_1004CADC[(a4 - 1800) / 10];
  for ( i = a4 - a4 % 10; i < a4; *this += v10 )
    v10 = sub_10021E50(i++);
  if ( v12 )
  {
    if ( a3 <= 1 )
      *this += a2;
    else
      *this += a2 + word_1004AD40[a3];
    return 1;
  }
  else
  {
    if ( a3 <= 1 )
      v11 = a2 + *this;
    else
      v11 = a2 + word_1004AD40[a3] + *this;
    *this = v11;
    return 1;
  }
}
// 1004AD40: using guessed type __int16 word_1004AD40[];
// 1004CADC: using guessed type int dword_1004CADC[];

//----- (10022430) --------------------------------------------------------
char __thiscall sub_10022430(_DWORD *this, int *a2, int *a3, int *a4, int *a5)
{
  int *v5; // esi
  int *v6; // edi
  int *v7; // ebp
  int *v8; // ebx
  int v9; // eax
  int v10; // ecx
  int v11; // eax
  int v12; // et2
  int v13; // eax
  int v14; // eax
  int v15; // et2
  int v16; // eax
  char result; // al

  v5 = a2;
  if ( !a2 )
    v5 = (int *)&a2;
  v6 = a3;
  if ( !a3 )
    v6 = (int *)&a2;
  v7 = a4;
  if ( !a4 )
    v7 = (int *)&a2;
  v8 = a5;
  if ( !a5 )
    v8 = (int *)&a2;
  v9 = this[1];
  if ( v9 >= 0 )
  {
    if ( v9 >= 86400000 )
      v9 %= 86400000;
    v12 = v9 % 3600000;
    v11 = v9 / 3600000;
    v10 = v12;
  }
  else
  {
    v10 = (int)a2;
    v11 = 0;
  }
  *v5 = v11;
  v13 = v10;
  if ( v10 >= 0 )
  {
    if ( v10 >= 3600000 )
      v13 = v10 % 3600000;
    v15 = v13 % 60000;
    v14 = v13 / 60000;
    v10 = v15;
  }
  else
  {
    v14 = 0;
  }
  *v6 = v14;
  v16 = v10;
  if ( v10 >= 0 )
  {
    if ( v10 >= 60000 )
      v16 = v10 % 60000;
    *v7 = v16 / 1000;
    *v8 = v16 % 1000;
    return 1;
  }
  else
  {
    result = 1;
    *v7 = 0;
    *v8 = v10;
  }
  return result;
}

//----- (10022500) --------------------------------------------------------
int __thiscall sub_10022500(int *this)
{
  struct tm *v2; // esi
  int result; // eax
  bool v4; // sf
  unsigned int tm_min; // ecx
  unsigned int tm_hour; // esi
  __time32_t Time; // [esp+8h] [ebp-4h] BYREF

  time(&Time);
  v2 = localtime(&Time);
  sub_100222F0(this, v2->tm_mday, v2->tm_mon + 1, v2->tm_year + 1900);
  result = v2->tm_sec;
  v4 = v2->tm_sec < 0;
  tm_min = v2->tm_min;
  tm_hour = v2->tm_hour;
  if ( !v4 && result < 60 && tm_min <= 0x3B && tm_hour <= 0x17 )
    this[1] = 1000 * (result + 60 * (tm_min + 60 * tm_hour));
  return result;
}

//----- (10022580) --------------------------------------------------------
int __stdcall sub_10022580(int a1, int *a2)
{
  int result; // eax
  int v4; // edi
  int v5; // ecx
  int v6; // ebx
  int v7; // esi
  int v8; // eax
  int v9; // eax
  int v10; // [esp+4h] [ebp+4h]

  result = 0;
  if ( a1 >= 0 )
  {
    while ( a1 >= dword_1004CAE0[result] )
    {
      if ( a1 < dword_1004CAE4[result] )
      {
        ++result;
        break;
      }
      if ( a1 < dword_1004CAE8[result] )
      {
        result += 2;
        break;
      }
      if ( a1 < dword_1004CAEC[result] )
      {
        result += 3;
        break;
      }
      if ( a1 < dword_1004CAF0[result] )
      {
        result += 4;
        break;
      }
      if ( a1 < dword_1004CAF4[result] )
      {
        result += 5;
        break;
      }
      result += 6;
      if ( result >= 30 )
        break;
    }
    if ( result == 30 )
    {
      *a2 = 364;
      return 2100;
    }
    else
    {
      v4 = 2 * (5 * result + 900);
      v10 = v4;
      if ( result )
        result = dword_1004CADC[result];
      v5 = a1 - result;
      v6 = 0;
      v7 = 0;
      while ( 1 )
      {
        v8 = v4 % 400 && (!(v4 % 100) || v4 % 4) ? 365 : 366;
        v9 = v7 + v8;
        if ( v5 < v9 )
          break;
        ++v6;
        ++v4;
        v7 = v9;
        if ( v6 >= 10 )
        {
          *a2 = v5;
          return v10;
        }
      }
      *a2 = v5 - v7;
      return v6 + v10;
    }
  }
  return result;
}
// 1004CADC: using guessed type int dword_1004CADC[];
// 1004CAE0: using guessed type int dword_1004CAE0[];
// 1004CAE4: using guessed type int dword_1004CAE4[];
// 1004CAE8: using guessed type int dword_1004CAE8[];
// 1004CAEC: using guessed type int dword_1004CAEC[];
// 1004CAF0: using guessed type int dword_1004CAF0[];
// 1004CAF4: using guessed type int dword_1004CAF4[25];

//----- (100226A0) --------------------------------------------------------
int __thiscall sub_100226A0(_DWORD *this, int a2)
{
  int result; // eax
  int v3; // edx
  int v4; // esi
  __int64 v5; // rax
  int v6; // edx
  __int64 v7; // rt2
  bool v8; // sf
  int v9; // edx

  result = a2;
  v3 = a2 + this[1];
  v4 = v3;
  this[1] = v3;
  if ( v3 < 86400000 )
  {
    if ( v3 < 0 )
    {
      v9 = v3 / 86400000 - 1;
      v8 = v9 + *this < 0;
      *this += v9;
      if ( v8 )
        *this = 0;
      result = 86400000 - -v4 % 86400000;
      this[1] = result;
    }
  }
  else
  {
    v5 = v3;
    v7 = v5 % 86400000;
    result = v5 / 86400000;
    v6 = v7;
    v8 = result + *this < 0;
    *this += result;
    if ( v8 )
      *this = 0;
    this[1] = v6;
  }
  return result;
}

//----- (10022710) --------------------------------------------------------
_DWORD *__thiscall sub_10022710(_DWORD *this, _DWORD *a2, _DWORD *a3)
{
  bool v3; // sf
  int *v4; // ecx

  v3 = *this - *a3 < 0;
  *this -= *a3;
  if ( v3 )
    *this = 0;
  sub_100226A0(this, -a3[1]);
  sub_10022230(a2, *v4, v4[1]);
  return a2;
}
// 10022736: variable 'v4' is possibly undefined

//----- (10022750) --------------------------------------------------------
int __thiscall sub_10022750(int this)
{
  unsigned int TickCount; // eax
  int *v3; // edi
  int v4; // ebx

  *(_DWORD *)this = 0;
  *(_DWORD *)(this + 4) = GetTickCount();
  *(_DWORD *)(this + 8) = 0;
  *(_DWORD *)(this + 12) = 0;
  *(_BYTE *)(this + 16) = 1;
  *(_DWORD *)(this + 20) = 1065353216;
  *(_BYTE *)(this + 1052) = 0;
  TickCount = GetTickCount();
  srand(TickCount);
  v3 = (int *)(this + 24);
  v4 = 257;
  do
  {
    *v3++ = rand();
    --v4;
  }
  while ( v4 );
  sub_10021F70((float *)this);
  return this;
}

//----- (100227B0) --------------------------------------------------------
WORD *__thiscall sub_100227B0(WORD *this)
{
  *(_DWORD *)this = &off_1003FCA0;
  sub_1000DE20(this + 2);
  return this;
}
// 1003FCA0: using guessed type void *off_1003FCA0;

//----- (100227F0) --------------------------------------------------------
char *__thiscall sub_100227F0(_DWORD *this, char *Buffer)
{
  int v3; // [esp+4h] [ebp-10h] BYREF
  int v4; // [esp+8h] [ebp-Ch] BYREF
  int v5; // [esp+Ch] [ebp-8h] BYREF
  int v6; // [esp+10h] [ebp-4h] BYREF

  v6 = 0;
  v5 = 0;
  v4 = 0;
  v3 = 0;
  sub_10022430(this, &v6, &v5, &v4, &v3);
  sprintf(Buffer, "%2.2ld:%2.2ld:%2.2ld:%3.3ld", v6, v5, v4, v3);
  return Buffer;
}

//----- (10022850) --------------------------------------------------------
bool __thiscall sub_10022850(int *this, int a2, int *a3, int *a4)
{
  int *v4; // ebp
  int *v5; // ebx
  int *v6; // edi
  int v8; // eax
  bool v9; // al
  int v10; // eax
  int v11; // eax

  v4 = (int *)a2;
  if ( !a2 )
    v4 = &a2;
  v5 = a3;
  if ( !a3 )
    v5 = (int *)&a3;
  v6 = a4;
  if ( !a4 )
    v6 = (int *)&a3;
  *v6 = 0;
  *v5 = 0;
  *v4 = 0;
  if ( !*this )
    return 0;
  v8 = sub_10022580(*this, &a2);
  *v6 = v8;
  if ( !v8 )
    return 0;
  v9 = sub_10021CA0(v8);
  v10 = sub_10021CF0(a2, v9, &a2);
  *v5 = v10;
  if ( !v10 )
    return 0;
  v11 = a2;
  *v4 = a2;
  return v11 != 0;
}

//----- (100228F0) --------------------------------------------------------
char *__thiscall sub_100228F0(int *this, char *Buffer)
{
  int v3; // eax
  int v5; // [esp+4h] [ebp-1Ch] BYREF
  int v6; // [esp+8h] [ebp-18h] BYREF
  int v7; // [esp+Ch] [ebp-14h] BYREF
  int v8; // [esp+10h] [ebp-10h] BYREF
  int v9; // [esp+14h] [ebp-Ch] BYREF
  int v10; // [esp+18h] [ebp-8h] BYREF
  int v11; // [esp+1Ch] [ebp-4h] BYREF

  v10 = 0;
  v5 = 0;
  v11 = 0;
  v9 = 0;
  v8 = 0;
  v7 = 0;
  v6 = 0;
  sub_10022850(this, (int)&v11, &v5, &v10);
  sub_10022430(this, &v9, &v8, &v7, &v6);
  v3 = v5;
  if ( v5 < 1 || v5 > 12 )
    v3 = 13;
  sprintf(Buffer, "%2.2ld-%3s-%4.4ld %2.2ld:%2.2ld:%2.2ld:%3.3ld", v11, &byte_1004ACE8[4 * v3], v10, v9, v8, v7, v6);
  return Buffer;
}

//----- (100229A0) --------------------------------------------------------
_DWORD *sub_100229A0()
{
  _DWORD *v0; // esi
  _DWORD *v1; // eax

  v0 = sub_1000BB40(20);
  if ( !v0 )
    return 0;
  v1 = sub_1000E120(1);
  v0[4] = v1;
  if ( !v1 )
  {
    sub_1000BBF0(v0);
    return 0;
  }
  *v0 = 0;
  v0[1] = 0;
  v0[2] = 0;
  v0[3] = 0;
  sub_1000E0E0((int)v1);
  return v0;
}

//----- (10022A00) --------------------------------------------------------
__int16 __cdecl sub_10022A00(int *Block, char a2)
{
  int v2; // eax
  int v3; // esi
  void *v4; // eax
  HANDLE *v5; // esi

  if ( sub_1000E090(Block[4], 0xFFFFFFFF) )
  {
    v3 = *Block;
    while ( v3 )
    {
      if ( (a2 & 1) != 0 )
        sub_1000BBF0(*(void **)v3);
      v4 = (void *)v3;
      v3 = *(_DWORD *)(v3 + 4);
      sub_1000BBF0(v4);
    }
    v5 = (HANDLE *)Block[4];
    sub_1000BBF0(Block);
    if ( sub_1000E0E0((int)v5) )
      LOWORD(v2) = -1;
    else
      return -((unsigned __int16)sub_1000E1E0(v5) != 0);
  }
  else
  {
    LOWORD(v2) = -1;
  }
  return v2;
}

//----- (10022A90) --------------------------------------------------------
__int16 __cdecl sub_10022A90(_DWORD *a1, int a2, int a3)
{
  _DWORD *v3; // eax
  int v5; // edx
  int v6; // [esp-4h] [ebp-8h]

  if ( !sub_1000E090(a1[4], 0xFFFFFFFF) )
    return -1;
  v3 = sub_1000BB40(12);
  if ( !v3 )
  {
    sub_1000E0E0(a1[4]);
    return -1;
  }
  v3[2] = a3;
  *v3 = a2;
  v3[1] = 0;
  if ( *a1 )
    *(_DWORD *)(a1[1] + 4) = v3;
  else
    *a1 = v3;
  v5 = a1[3];
  a1[1] = v3;
  ++a1[2];
  v6 = a1[4];
  a1[3] = a3 + v5;
  sub_1000E0E0(v6);
  return 0;
}

//----- (10022B10) --------------------------------------------------------
int __cdecl sub_10022B10(int a1, _DWORD *a2)
{
  int *v2; // eax
  int v4; // edi

  if ( !sub_1000E090(*(_DWORD *)(a1 + 16), 0xFFFFFFFF) )
    return 0;
  v2 = *(int **)a1;
  if ( !*(_DWORD *)a1 )
  {
    sub_1000E0E0(*(_DWORD *)(a1 + 16));
    return 0;
  }
  v4 = *v2;
  *a2 = v2[2];
  *(_DWORD *)a1 = v2[1];
  --*(_DWORD *)(a1 + 8);
  sub_1000BBF0(v2);
  sub_1000E0E0(*(_DWORD *)(a1 + 16));
  return v4;
}

//----- (10022B70) --------------------------------------------------------
int __cdecl sub_10022B70(int a1)
{
  int v2; // edi

  if ( !sub_1000E090(*(_DWORD *)(a1 + 16), 0xFFFFFFFF) )
    return -1;
  v2 = *(_DWORD *)(a1 + 8);
  if ( sub_1000E0E0(*(_DWORD *)(a1 + 16)) )
    return -1;
  else
    return v2;
}

//----- (10022BB0) --------------------------------------------------------
_DWORD *__cdecl sub_10022BB0(unsigned __int16 a1, int a2)
{
  _DWORD *v2; // esi
  _DWORD *v4; // eax
  void *v5; // eax
  int v6; // eax
  int v7; // ecx

  v2 = sub_1000BB40(24);
  if ( v2 )
  {
    v4 = sub_1000E120(2);
    *v2 = v4;
    if ( v4 )
    {
      v5 = sub_1000BB40(4 * a1);
      v2[1] = v5;
      if ( v5 )
      {
        if ( a1 )
        {
          v6 = 0;
          v7 = a1;
          do
          {
            *(_DWORD *)(v6 + v2[1]) = 0;
            v6 += 4;
            --v7;
          }
          while ( v7 );
        }
        *((_WORD *)v2 + 4) = a1;
        v2[5] = a2;
        v2[3] = 0;
        v2[4] = 0;
        return v2;
      }
      else
      {
        sub_1000C6B0(0, 16, "CALL: Cannot create list.");
        sub_1000E1E0((HANDLE *)*v2);
        sub_1000BBF0(v2);
        return 0;
      }
    }
    else
    {
      sub_1000C6B0(0, 16, "CALL: Cannot creae mutex.");
      sub_1000BBF0(v2);
      return 0;
    }
  }
  else
  {
    sub_1000C6B0(0, 16, "CALL: Cannot allocate call_ctrl.");
    return 0;
  }
}

//----- (10022C80) --------------------------------------------------------
__int16 __cdecl sub_10022C80(int a1, void *Block, __int16 a3)
{
  unsigned __int16 v3; // ax
  unsigned __int16 v4; // di

  sub_1000E090(*(_DWORD *)a1, 0xFFFFFFFF);
  v3 = *(_WORD *)(a1 + 8);
  v4 = 0;
  if ( v3 )
  {
    while ( *(void **)(*(_DWORD *)(a1 + 4) + 4 * v4) != Block )
    {
      if ( ++v4 >= v3 )
        return sub_1000E0E0(*(_DWORD *)a1);
    }
    sub_10023110(*(_DWORD **)(a1 + 20), *((_DWORD *)Block + 2));
    if ( a3 && *((_DWORD *)Block + 4) )
    {
      sub_1000BBF0(*((void **)Block + 4));
      *((_DWORD *)Block + 4) = 0;
    }
    j__free(Block);
    *(_DWORD *)(*(_DWORD *)(a1 + 4) + 4 * v4) = 0;
  }
  return sub_1000E0E0(*(_DWORD *)a1);
}

//----- (10022D20) --------------------------------------------------------
__int16 __cdecl sub_10022D20(int a1, int a2, int a3)
{
  __int16 v3; // bp
  unsigned __int16 i; // bx
  _BYTE *v6; // esi

  v3 = 0;
  sub_1000E090(*(_DWORD *)a1, 0xFFFFFFFF);
  if ( (*(_DWORD *)(a1 + 16) & a3) != 0 || (a2 & *(_DWORD *)(a1 + 12)) != 0 )
  {
    sub_1000E0E0(*(_DWORD *)a1);
    return 0;
  }
  else
  {
    for ( i = 0; i < *(_WORD *)(a1 + 8); ++i )
    {
      v6 = *(_BYTE **)(*(_DWORD *)(a1 + 4) + 4 * i);
      if ( v6
        && (*(_DWORD *)v6 & 0x10) == 0
        && (a3 & *((_DWORD *)v6 + 12)) != 0
        && (a2 & *((_DWORD *)v6 + 11)) != 0
        && ((*(_DWORD *)v6 & 0x20) == 0
         || (*(unsigned __int8 (__thiscall **)(_BYTE *))(*((_DWORD *)v6 + 7) + 4))(v6 + 28)) )
      {
        sub_1000E0E0(*(_DWORD *)a1);
        ++v3;
        if ( (*((int (__cdecl **)(_DWORD))v6 + 3))(*((_DWORD *)v6 + 4)) != 2 )
        {
          if ( (*v6 & 2) != 0 )
            sub_10022C80(a1, v6, 1);
          else
            (**((void (__thiscall ***)(int, _DWORD))v6 + 7))((int)(v6 + 28), *((_DWORD *)v6 + 6));
        }
        sub_1000E090(*(_DWORD *)a1, 0xFFFFFFFF);
      }
    }
    sub_1000E0E0(*(_DWORD *)a1);
    return v3;
  }
}

//----- (10022E20) --------------------------------------------------------
__int16 __cdecl sub_10022E20(int a1, int (__cdecl *a2)(_DWORD, int), int a3)
{
  unsigned __int16 i; // bx
  _DWORD *v4; // edi

  sub_1000E090(*(_DWORD *)a1, 0xFFFFFFFF);
  for ( i = 0; i < *(_WORD *)(a1 + 8); ++i )
  {
    v4 = *(_DWORD **)(*(_DWORD *)(a1 + 4) + 4 * i);
    if ( v4 )
    {
      sub_1000E0E0(*(_DWORD *)a1);
      if ( a2(v4[4], a3) == 1 )
        sub_10022C80(a1, v4, 1);
      sub_1000E090(*(_DWORD *)a1, 0xFFFFFFFF);
    }
  }
  return sub_1000E0E0(*(_DWORD *)a1);
}

//----- (10022EA0) --------------------------------------------------------
__int16 __cdecl sub_10022EA0(void *Block, __int16 a2)
{
  unsigned __int16 i; // bx
  int v3; // edi

  sub_1000E090(*(_DWORD *)Block, 0xFFFFFFFF);
  for ( i = 0; i < *((_WORD *)Block + 4); ++i )
  {
    v3 = 4 * i;
    if ( *(_DWORD *)(v3 + *((_DWORD *)Block + 1)) )
    {
      sub_1000E0E0(*(_DWORD *)Block);
      sub_10022C80((int)Block, *(void **)(v3 + *((_DWORD *)Block + 1)), a2);
      sub_1000E090(*(_DWORD *)Block, 0xFFFFFFFF);
    }
  }
  sub_1000E0E0(*(_DWORD *)Block);
  sub_1000E1E0(*(HANDLE **)Block);
  sub_1000BBF0(*((void **)Block + 1));
  return sub_1000BBF0(Block);
}

//----- (10022F30) --------------------------------------------------------
int __cdecl sub_10022F30(int a1, int a2, int a3, int a4, char a5, int a6, int a7)
{
  unsigned __int16 v7; // ax
  unsigned __int16 i; // di
  char *v10; // eax
  int *v11; // esi
  void (__thiscall ***v12)(int, int); // ebp
  int v13; // eax
  int v14; // eax
  unsigned int v15; // eax

  sub_1000E090(*(_DWORD *)a1, 0xFFFFFFFF);
  v7 = *(_WORD *)(a1 + 8);
  for ( i = 0; i < v7; ++i )
  {
    if ( !*(_DWORD *)(*(_DWORD *)(a1 + 4) + 4 * i) )
      break;
  }
  if ( i == v7 || (v10 = (char *)operator new(0x34u), (v11 = (int *)v10) == 0) )
  {
    sub_1000E0E0(*(_DWORD *)a1);
    return 0;
  }
  else
  {
    v12 = (void (__thiscall ***)(int, int))(v10 + 28);
    sub_10021EE0((_DWORD *)v10 + 7);
    *(_DWORD *)(*(_DWORD *)(a1 + 4) + 4 * i) = v11;
    v11[3] = a2;
    v11[4] = a3;
    v11[11] = a6;
    v11[12] = a7;
    *v11 = 1;
    v11[5] = GetTickCount();
    if ( (a5 & 0x20) != 0 )
    {
      *v11 |= 0x20u;
      (**v12)((int)(v11 + 7), a4);
      if ( (a5 & 0x40) != 0 )
      {
        v13 = *v11 | 0x40;
        v11[6] = a4;
        *v11 = v13;
      }
    }
    v11[2] = sub_100230E0(*(int **)(a1 + 20));
    v14 = *v11;
    if ( (a5 & 4) != 0 )
      v15 = v14 & 0xFFFFFFFD;
    else
      v15 = v14 | 2;
    *v11 = v15;
    if ( (a5 & 0x10) != 0 )
      *v11 = v15 & 0xFFFFFFF7;
    else
      *v11 = v15 | 8;
    sub_1000E0E0(*(_DWORD *)a1);
    return v11[2];
  }
}

//----- (10023060) --------------------------------------------------------
_DWORD *__cdecl sub_10023060(int a1)
{
  unsigned int v1; // edi
  _DWORD *v2; // esi
  void *v3; // eax
  unsigned int v5; // eax

  v1 = a1 + 1;
  v2 = sub_1000BB40(8);
  if ( !v2 )
    return 0;
  v3 = sub_1000BB40(v1);
  *v2 = v3;
  if ( !v3 )
  {
    sub_1000BBF0(v2);
    return 0;
  }
  v5 = 0;
  if ( a1 != -1 )
  {
    do
    {
      *(_BYTE *)(v5 + *v2) = 1;
      ++v5;
    }
    while ( v5 < v1 );
  }
  v2[1] = v1;
  return v2;
}

//----- (100230C0) --------------------------------------------------------
__int16 __cdecl sub_100230C0(void **Block)
{
  sub_1000BBF0(*Block);
  return sub_1000BBF0(Block);
}

//----- (100230E0) --------------------------------------------------------
int __cdecl sub_100230E0(int *a1)
{
  unsigned int v1; // edx
  int result; // eax
  int v3; // ecx

  v1 = a1[1];
  result = 1;
  if ( v1 <= 1 )
    return 0;
  v3 = *a1;
  while ( *(_BYTE *)(v3 + result) != 1 )
  {
    if ( ++result >= v1 )
      return 0;
  }
  *(_BYTE *)(v3 + result) = 2;
  return result;
}

//----- (10023110) --------------------------------------------------------
unsigned int __cdecl sub_10023110(_DWORD *a1, unsigned int a2)
{
  unsigned int result; // eax

  result = a2;
  if ( a2 )
  {
    if ( a2 < a1[1] )
      *(_BYTE *)(a2 + *a1) = 1;
  }
  return result;
}

//----- (10023130) --------------------------------------------------------
DNameNode *__thiscall sub_10023130(DNameNode *this)
{
  DNameNode::DNameNode(this);
  *((_DWORD *)this + 2) = 0;
  *((_DWORD *)this + 3) = 0;
  *((_DWORD *)this + 5) = 0;
  *((_DWORD *)this + 6) = 0;
  *(_DWORD *)this = off_1003FD50;
  *((_DWORD *)this + 4) = -1;
  *((_DWORD *)this + 7) = 128;
  dword_1004CF78 = 0;
  return this;
}
// 1003FD50: using guessed type int (__stdcall *off_1003FD50[3])(int);
// 1004CF78: using guessed type int dword_1004CF78;

//----- (10023170) --------------------------------------------------------
int __thiscall sub_10023170(_DWORD *this, int a2)
{
  int v2; // ebx
  _DWORD **v3; // edi
  int v4; // esi
  _DWORD *v5; // eax

  v2 = 0;
  if ( this[4] == -1 )
    return 0;
  v3 = (_DWORD **)this[2];
  v4 = 1;
  while ( 1 )
  {
    v5 = *v3;
    if ( *v3 )
    {
      if ( v5[1] == 1 && *v5 == a2 )
        break;
    }
    ++v2;
    ++v3;
    if ( ++v4 > (unsigned int)(this[4] + 1) )
      return 0;
  }
  return (*(int (__thiscall **)(_DWORD *, int))(*this + 40))(this, v2);
}

//----- (100231C0) --------------------------------------------------------
int __thiscall sub_100231C0(_DWORD *this, int a2)
{
  int result; // eax
  unsigned int v3; // esi
  int v4; // ecx
  int v5; // edx

  result = 0;
  v3 = this[4] + 1;
  if ( this[4] == -1 )
    return -1;
  v4 = this[2];
  v5 = 1;
  while ( *(_DWORD *)(*(_DWORD *)v4 + 4) != 1 || **(_DWORD **)v4 != a2 )
  {
    ++result;
    v4 += 4;
    if ( ++v5 > v3 )
      return -1;
  }
  return result;
}

//----- (10023200) --------------------------------------------------------
int __thiscall sub_10023200(_DWORD *this, unsigned int a2)
{
  _DWORD *v2; // eax
  int v3; // eax
  int v4; // edi
  int v5; // eax
  int v6; // edx
  int v7; // eax

  if ( a2 == -1 )
    return 0;
  if ( a2 + 1 > this[4] + 1 )
    return 0;
  v2 = *(_DWORD **)(this[2] + 4 * a2);
  if ( !v2 )
    return 0;
  *v2 = 0;
  *(_DWORD *)(*(_DWORD *)(this[2] + 4 * a2) + 4) = 0;
  v3 = this[4];
  if ( a2 == v3 && v3 != -1 )
  {
    v4 = this[2];
    do
    {
      v5 = this[4];
      v6 = *(_DWORD *)(v4 + 4 * v5);
      if ( v6 && *(_DWORD *)(v6 + 4) )
        break;
      v7 = v5 - 1;
      this[4] = v7;
    }
    while ( v7 != -1 );
  }
  if ( a2 < this[5] )
    this[5] = a2;
  --this[3];
  return 1;
}

//----- (10023280) --------------------------------------------------------
int __thiscall sub_10023280(void *this)
{
  return (*(int (__thiscall **)(void *, _DWORD))(*(_DWORD *)this + 40))(this, 0);
}

//----- (10023290) --------------------------------------------------------
int __thiscall sub_10023290(_DWORD *this)
{
  return (*(int (__thiscall **)(_DWORD *, _DWORD))(*this + 40))(this, this[4]);
}

//----- (100232A0) --------------------------------------------------------
int __thiscall sub_100232A0(_DWORD *this, unsigned int a2)
{
  int v3; // ebp
  unsigned int i; // esi

  if ( !a2 || a2 + 1 > this[4] + 1 )
    return 0;
  v3 = 0;
  for ( i = 0; i < a2; ++i )
  {
    if ( (*(int (__thiscall **)(_DWORD *, unsigned int))(*this + 40))(this, i) )
      ++v3;
  }
  return v3;
}
// 100232BF: conditional instruction was optimized away because %arg_0.4!=0

//----- (100232F0) --------------------------------------------------------
int __thiscall sub_100232F0(_DWORD *this, unsigned int a2)
{
  unsigned int v3; // eax
  unsigned int v4; // esi
  int v5; // ebx

  if ( a2 == -1 )
    return 0;
  v3 = this[4];
  if ( a2 >= v3 )
    return 0;
  v4 = a2 + 1;
  v5 = 0;
  if ( a2 + 1 <= v3 )
  {
    do
    {
      if ( (*(int (__thiscall **)(_DWORD *, unsigned int))(*this + 40))(this, v4) )
        ++v5;
      ++v4;
    }
    while ( v4 <= this[4] );
  }
  return v5;
}

//----- (10023340) --------------------------------------------------------
int __thiscall sub_10023340(void *this)
{
  int v2; // ebp
  unsigned int i; // edi
  int v4; // ecx

  v2 = 0;
  for ( i = 0; i < *((_DWORD *)this + 6); ++i )
  {
    if ( (*(int (__thiscall **)(void *, unsigned int))(*(_DWORD *)this + 40))(this, i) )
      ++v2;
    v4 = *((_DWORD *)this + 2);
    if ( *(_DWORD *)(v4 + 4 * i) )
    {
      j__free(*(void **)(v4 + 4 * i));
      *(_DWORD *)(*((_DWORD *)this + 2) + 4 * i) = 0;
    }
  }
  if ( *((_DWORD *)this + 4) == -1 )
  {
    if ( *((_DWORD *)this + 2) )
    {
      j__free(*((void **)this + 2));
      *((_DWORD *)this + 2) = 0;
    }
    *((_DWORD *)this + 6) = 0;
  }
  return v2;
}

//----- (100233B0) --------------------------------------------------------
int __thiscall sub_100233B0(_DWORD **this)
{
  int v1; // eax

  v1 = *this[2];
  if ( v1 )
    return *(_DWORD *)v1;
  else
    return 0;
}

//----- (100233C0) --------------------------------------------------------
int __thiscall sub_100233C0(_DWORD *this)
{
  int v1; // eax
  int v2; // eax

  v1 = this[4];
  if ( v1 && (v2 = *(_DWORD *)(this[2] + 4 * v1)) != 0 )
    return *(_DWORD *)v2;
  else
    return 0;
}

//----- (100233E0) --------------------------------------------------------
int __thiscall sub_100233E0(_DWORD *this, int a2)
{
  int v2; // eax

  if ( a2 == -1 )
    return 0;
  if ( a2 + 1 > (unsigned int)(this[4] + 1) )
    return 0;
  v2 = *(_DWORD *)(this[2] + 4 * a2);
  if ( !v2 )
    return 0;
  else
    return *(_DWORD *)v2;
}

//----- (10023410) --------------------------------------------------------
int __thiscall sub_10023410(_DWORD *this)
{
  return this[4] + 1;
}

//----- (10023420) --------------------------------------------------------
int __thiscall sub_10023420(void *this, int a2, int a3)
{
  _DWORD *v4; // eax

  if ( a3 && (v4 = (_DWORD *)sub_10025CC0(a3)) != 0 )
    return (*(int (__thiscall **)(void *, int, _DWORD))(*(_DWORD *)this + 16))(this, a2, *v4);
  else
    return -1;
}

//----- (10023450) --------------------------------------------------------
int __thiscall sub_10023450(void *this, int a2, int a3)
{
  _DWORD *v4; // eax

  if ( a3 && (v4 = (_DWORD *)sub_10025CC0(a3)) != 0 )
    return (*(int (__thiscall **)(void *, int, _DWORD))(*(_DWORD *)this + 24))(this, a2, *v4);
  else
    return -1;
}

//----- (10023480) --------------------------------------------------------
int __thiscall sub_10023480(void *this, int a2, int a3)
{
  _DWORD *v4; // eax

  if ( a3 && (v4 = (_DWORD *)sub_10025CC0(a3)) != 0 )
    return (*(int (__thiscall **)(void *, int, _DWORD))(*(_DWORD *)this + 32))(this, a2, *v4);
  else
    return -1;
}

//----- (100234B0) --------------------------------------------------------
int __thiscall sub_100234B0(void *this, int a2)
{
  _DWORD *v3; // eax

  if ( a2 && (v3 = (_DWORD *)sub_10025CC0(a2)) != 0 )
    return (*(int (__thiscall **)(void *, _DWORD))(*(_DWORD *)this + 40))(this, *v3);
  else
    return 0;
}

//----- (100234E0) --------------------------------------------------------
BOOL __thiscall sub_100234E0(_DWORD *this, int a2)
{
  unsigned int *v3; // eax
  unsigned int v4; // eax
  BOOL result; // eax

  result = 0;
  if ( a2 )
  {
    v3 = (unsigned int *)sub_10025CC0(a2);
    if ( v3 )
    {
      v4 = *v3;
      if ( v4 != -1 && v4 <= this[4] )
        return 1;
    }
  }
  return result;
}

//----- (10023510) --------------------------------------------------------
int __thiscall sub_10023510(void *this, int a2)
{
  _DWORD *v3; // eax

  if ( a2 && (v3 = (_DWORD *)sub_10025CC0(a2)) != 0 )
    return (*(int (__thiscall **)(void *, _DWORD))(*(_DWORD *)this + 84))(this, *v3);
  else
    return 0;
}

//----- (10023540) --------------------------------------------------------
int __thiscall sub_10023540(_DWORD *this, unsigned int a2)
{
  _DWORD *v3; // eax

  if ( a2 != -1 && a2 < this[6] )
  {
    if ( *(_DWORD *)(this[2] + 4 * a2) )
      return 1;
    v3 = operator new(8u);
    if ( v3 )
    {
      *v3 = 0;
      v3[1] = 0;
      *(_DWORD *)(this[2] + 4 * a2) = v3;
      return 1;
    }
  }
  return 0;
}

//----- (10023590) --------------------------------------------------------
BOOL __stdcall sub_10023590(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)
{
  HINSTANCE v4; // eax
  char *v5; // edx
  int v6; // ecx

  if ( !hinstDLL )
    return 0;
  if ( !lpvReserved )
    return DllMain(hinstDLL, fdwReason, 0);
  v4 = hinstDLL + (_DWORD)lpvReserved;
  v5 = (char *)lpvReserved;
  do
  {
    --v4;
    if ( fdwReason && (v6 = *(_DWORD *)((char *)v4 + fdwReason - (_DWORD)hinstDLL)) != 0 )
      *(_DWORD *)v4 = v6;
    else
      *(_DWORD *)v4 = 0;
    --v5;
  }
  while ( v5 );
  return DllMain(hinstDLL, fdwReason, lpvReserved);
}

//----- (100235E0) --------------------------------------------------------
int __thiscall sub_100235E0(_DWORD *this, int a2)
{
  unsigned int *v3; // eax
  unsigned int v5; // eax
  unsigned int v6; // edx
  int v7; // ecx

  if ( !a2 )
    return 0;
  v3 = (unsigned int *)sub_10025CC0(a2);
  if ( !v3 )
    return 0;
  v5 = *v3;
  if ( v5 != -1 )
  {
    v6 = this[4];
    do
    {
      --v5;
      if ( v6 != -1 && v5 <= v6 )
      {
        v7 = *(_DWORD *)(this[2] + 4 * v5);
        if ( v7 )
        {
          if ( *(_DWORD *)(v7 + 4) == 1 )
            break;
        }
      }
    }
    while ( v5 != -1 );
  }
  return (*(int (__thiscall **)(_DWORD *, unsigned int))(*this + 40))(this, v5);
}

//----- (10023630) --------------------------------------------------------
int __thiscall sub_10023630(_DWORD *this, int a2)
{
  unsigned int *v3; // eax
  unsigned int v5; // eax
  unsigned int v6; // edx
  int v7; // ecx

  if ( !a2 )
    return 0;
  v3 = (unsigned int *)sub_10025CC0(a2);
  if ( !v3 )
    return 0;
  v5 = *v3;
  if ( v5 != -1 )
  {
    v6 = this[4];
    do
    {
      if ( ++v5 > v6 )
        v5 = -1;
      if ( v6 != -1 && v5 <= v6 )
      {
        v7 = *(_DWORD *)(this[2] + 4 * v5);
        if ( v7 )
        {
          if ( *(_DWORD *)(v7 + 4) == 1 )
            break;
        }
      }
    }
    while ( v5 != -1 );
  }
  return (*(int (__thiscall **)(_DWORD *, unsigned int))(*this + 40))(this, v5);
}

//----- (10023690) --------------------------------------------------------
int __thiscall sub_10023690(_DWORD *this, int a2)
{
  unsigned int *v3; // eax
  int v5; // edx
  unsigned int v6; // edx
  unsigned int v7; // ecx
  int v8; // edx
  unsigned int v9; // ecx

  if ( !a2 )
    return 0;
  v3 = (unsigned int *)sub_10025CC0(a2);
  if ( !v3 )
    return 0;
  v5 = this[4];
  *v3 = (v5 != -1) - 1;
  if ( v5 != -1 )
  {
    do
    {
      v6 = this[4];
      v7 = *v3;
      if ( v6 != -1 && v7 <= v6 )
      {
        v8 = *(_DWORD *)(this[2] + 4 * v7);
        if ( v8 )
        {
          if ( *(_DWORD *)(v8 + 4) == 1 )
            break;
        }
      }
      v9 = v7 + 1;
      *v3 = v9;
    }
    while ( v9 != -1 );
  }
  return (*(int (__thiscall **)(_DWORD *, unsigned int))(*this + 84))(this, *v3);
}

//----- (10023700) --------------------------------------------------------
int __thiscall sub_10023700(_DWORD *this, int a2)
{
  unsigned int *v3; // eax
  unsigned int v5; // ecx
  unsigned int v6; // edx
  unsigned int v7; // ecx
  int v8; // edx
  unsigned int v9; // ecx

  if ( !a2 )
    return 0;
  v3 = (unsigned int *)sub_10025CC0(a2);
  if ( !v3 )
    return 0;
  v5 = this[4];
  *v3 = v5;
  if ( v5 != -1 )
  {
    do
    {
      v6 = this[4];
      v7 = *v3;
      if ( v6 != -1 && v7 <= v6 )
      {
        v8 = *(_DWORD *)(this[2] + 4 * v7);
        if ( v8 )
        {
          if ( *(_DWORD *)(v8 + 4) == 1 )
            break;
        }
      }
      v9 = v7 - 1;
      *v3 = v9;
    }
    while ( v9 != -1 );
  }
  return (*(int (__thiscall **)(_DWORD *, unsigned int))(*this + 84))(this, *v3);
}

//----- (10023760) --------------------------------------------------------
int __thiscall sub_10023760(_DWORD *this, int a2)
{
  int *v3; // eax
  int v5; // edx
  int v6; // ecx
  unsigned int v7; // edx
  unsigned int v8; // ecx
  int v9; // edx

  if ( !a2 )
    return 0;
  v3 = (int *)sub_10025CC0(a2);
  if ( !v3 )
    return 0;
  v5 = this[4];
  if ( *v3 + 1 <= (unsigned int)(v5 + 1) )
  {
    if ( *v3 == -1 )
    {
      *v3 = v5;
      return (*(int (__thiscall **)(_DWORD *, int))(*this + 84))(this, *v3);
    }
    else
    {
      do
      {
        v6 = *v3 - 1;
        *v3 = v6;
        v7 = v6;
        v8 = this[4];
        if ( v8 != -1 && v7 <= v8 )
        {
          v9 = *(_DWORD *)(this[2] + 4 * v7);
          if ( v9 )
          {
            if ( *(_DWORD *)(v9 + 4) == 1 )
              break;
          }
        }
      }
      while ( *v3 != -1 );
      return (*(int (__thiscall **)(_DWORD *, int))(*this + 84))(this, *v3);
    }
  }
  else
  {
    *v3 = -1;
    return 0;
  }
}

//----- (100237F0) --------------------------------------------------------
int __thiscall sub_100237F0(_DWORD *this, int a2)
{
  unsigned int *v3; // eax
  unsigned int v5; // ecx
  unsigned int v6; // edx
  int v7; // edi

  if ( !a2 )
    return 0;
  v3 = (unsigned int *)sub_10025CC0(a2);
  if ( !v3 )
    return 0;
  if ( *v3 + 1 > this[4] + 1 )
  {
    *v3 = -1;
    return 0;
  }
  if ( *v3 == -1 )
  {
    *v3 = 0;
    if ( this[4] == -1 )
    {
      *v3 = -1;
      return (*(int (__thiscall **)(_DWORD *, unsigned int))(*this + 84))(this, *v3);
    }
  }
  else
  {
    do
    {
      v5 = *v3 + 1;
      *v3 = v5;
      v6 = this[4];
      if ( v6 != -1 && v5 <= v6 )
      {
        v7 = *(_DWORD *)(this[2] + 4 * v5);
        if ( v7 )
        {
          if ( *(_DWORD *)(v7 + 4) == 1 )
            break;
        }
      }
      if ( v5 + 1 > v6 + 1 )
        *v3 = -1;
    }
    while ( *v3 != -1 );
  }
  return (*(int (__thiscall **)(_DWORD *, unsigned int))(*this + 84))(this, *v3);
}

//----- (100238A0) --------------------------------------------------------
int __thiscall sub_100238A0(DWORD *this, int a2, DWORD a3)
{
  DWORD v3; // ebx
  unsigned int v6; // edi
  unsigned int v7; // ebp
  DWORD v8; // ecx
  unsigned int v9; // edx
  HINSTANCE v10; // ebx
  unsigned int v11; // ecx
  _DWORD *v12; // eax
  int v13; // eax
  _DWORD *v14; // eax
  DWORD v15; // eax
  DWORD v16; // ecx
  unsigned int v17; // edi
  int v18; // eax

  v3 = a3;
  if ( a3 == -1 )
    return -1;
  v6 = this[6];
  v7 = a3 + 1;
  if ( a3 + 1 >= v6 )
  {
    v8 = this[7];
    v9 = this[6];
    do
      v9 += v8;
    while ( v7 >= v9 );
    this[6] = v9;
    v10 = (HINSTANCE)operator new(4 * v9);
    if ( !sub_10023590(v10, this[2], (LPVOID)v6) )
      return -1;
    if ( this[2] )
    {
      j__free((void *)this[2]);
      this[2] = 0;
    }
    v11 = 0;
    if ( this[6] != v6 )
    {
      v12 = v10 + v6;
      do
      {
        *v12 = 0;
        ++v11;
        ++v12;
      }
      while ( v11 < this[6] - v6 );
    }
    this[2] = (DWORD)v10;
    v3 = a3;
  }
  v13 = *(_DWORD *)(this[2] + 4 * v3);
  if ( v13 )
  {
    if ( *(_DWORD *)(v13 + 4) )
      return -1;
  }
  else
  {
    v14 = operator new(8u);
    if ( !v14 )
      return -1;
    *v14 = 0;
    v14[1] = 0;
    *(_DWORD *)(this[2] + 4 * v3) = v14;
  }
  **(_DWORD **)(this[2] + 4 * v3) = a2;
  *(_DWORD *)(*(_DWORD *)(this[2] + 4 * v3) + 4) = 1;
  if ( v7 > this[4] + 1 )
    this[4] = v3;
  v15 = this[5];
  if ( v3 == v15 && v15 <= this[4] )
  {
    v16 = this[2];
    do
    {
      v17 = this[5] + 1;
      this[5] = v17;
      v18 = *(_DWORD *)(v16 + 4 * v17);
    }
    while ( v18 && *(_DWORD *)(v18 + 4) && v17 <= this[4] );
  }
  ++this[3];
  return v3;
}

//----- (100239D0) --------------------------------------------------------
_DWORD *__thiscall sub_100239D0(_DWORD *Block, char a2)
{
  *Block = off_1003FD50;
  sub_10023340(Block);
  sub_10025C00(Block);
  if ( (a2 & 1) != 0 )
    j__free(Block);
  return Block;
}
// 1003FD50: using guessed type int (__stdcall *off_1003FD50[3])(int);

//----- (10023A00) --------------------------------------------------------
int __thiscall sub_10023A00(DWORD *this, int a2)
{
  return sub_100238A0(this, a2, this[5]);
}

//----- (10023A20) --------------------------------------------------------
int __thiscall sub_10023A20(DWORD *this, int a2)
{
  return sub_100238A0(this, a2, this[4] + 1);
}

//----- (10023A40) --------------------------------------------------------
int __thiscall sub_10023A40(DWORD *this, int a2, DWORD a3)
{
  DWORD v3; // edx
  DWORD v4; // edi
  int v5; // esi
  int v6; // eax

  v3 = a3;
  v4 = this[5];
  if ( a3 <= v4 || a3 + 1 > this[4] + 1 )
    return -1;
  v5 = this[2] + 4 * a3;
  do
  {
    v6 = *(_DWORD *)(v5 - 4);
    v5 -= 4;
    --v3;
  }
  while ( v6 && *(_DWORD *)(v6 + 4) && v3 > v4 );
  return sub_100238A0(this, a2, v3);
}

//----- (10023A90) --------------------------------------------------------
int __thiscall sub_10023A90(DWORD *this, int a2, int a3)
{
  DWORD v3; // edi
  DWORD v4; // eax
  int v5; // esi

  if ( a3 == -1 )
    return -1;
  v3 = this[4];
  v4 = a3 + 1;
  if ( a3 + 1 > v3 + 1 )
    return -1;
  if ( v4 <= v3 )
  {
    v5 = this[2] + 4 * v4;
    do
    {
      if ( !*(_DWORD *)v5 )
        break;
      if ( !*(_DWORD *)(*(_DWORD *)v5 + 4) )
        break;
      ++v4;
      v5 += 4;
    }
    while ( v4 <= v3 );
  }
  return sub_100238A0(this, a2, v4);
}

//----- (10023AE0) --------------------------------------------------------
int __thiscall sub_10023AE0(DWORD *this, int a2, DWORD a3)
{
  int result; // eax

  if ( a3 == -1 || a3 + 1 > this[4] + 1 )
    return sub_100238A0(this, a2, a3);
  if ( !*(_DWORD *)(this[2] + 4 * a3) && !sub_10023540(this, a3) )
    return -1;
  **(_DWORD **)(this[2] + 4 * a3) = a2;
  result = a3;
  *(_DWORD *)(*(_DWORD *)(this[2] + 4 * a3) + 4) = 1;
  return result;
}

//----- (10023B50) --------------------------------------------------------
__int16 __thiscall sub_10023B50(_DWORD *this, int a2, int a3)
{
  int v4; // ecx
  unsigned int v5; // eax
  void *v6; // eax
  int v8; // eax

  v4 = this[4];
  this[5] = a3;
  if ( v4 && (a3 & 2) != 0 )
    (*(void (__thiscall **)(_DWORD *))(*this + 4))(this);
  if ( a2 )
  {
    v6 = sub_1000BB40(4 * a2);
    this[4] = v6;
    if ( !v6 )
      return -1;
    v5 = this[5] & 0xFFFFFFFB;
  }
  else
  {
    this[4] = 0;
    v5 = this[5] | 4;
  }
  this[5] = v5;
  v8 = 0;
  for ( this[1] = a2; v8 < a2; ++v8 )
    *(_DWORD *)(this[4] + 4 * v8) = 0;
  this[5] |= 2u;
  this[2] = 0;
  return 0;
}

//----- (10023C30) --------------------------------------------------------
__int16 __thiscall sub_10023C30(_DWORD *this, int a2)
{
  int v3; // ebx
  int v5; // ecx
  int v6; // esi
  _DWORD *i; // eax
  int v8; // eax

  v3 = this[5];
  if ( (v3 & 2) == 0 )
    return -1;
  v5 = this[1];
  v6 = 0;
  if ( v5 <= 0 )
    return -1;
  for ( i = (_DWORD *)this[4]; *i != a2; ++i )
  {
    if ( ++v6 >= v5 )
      return -1;
  }
  if ( v6 >= 0 && v6 < v5 )
  {
    if ( (v3 & 1) != 0 )
    {
      v8 = *(_DWORD *)(this[4] + 4 * v6);
      if ( v8 )
        (*(void (__thiscall **)(_DWORD *, int))(*this + 12))(this, v8);
    }
    *(_DWORD *)(this[4] + 4 * v6) = 0;
  }
  return 0;
}

//----- (10023CB0) --------------------------------------------------------
void __stdcall sub_10023CB0(void *Block)
{
  if ( Block )
    j__free(Block);
}

//----- (10023D70) --------------------------------------------------------
void __thiscall sub_10023D70(void *this)
{
  int i; // edi
  int v3; // eax

  if ( (*((_BYTE *)this + 20) & 1) != 0 )
  {
    for ( i = 0; i < *((_DWORD *)this + 1); ++i )
    {
      v3 = *((_DWORD *)this + 5);
      if ( (v3 & 2) != 0 && i >= 0 && i < *((_DWORD *)this + 1) )
      {
        if ( (v3 & 1) != 0 && *(_DWORD *)(*((_DWORD *)this + 4) + 4 * i) )
          (*(void (__thiscall **)(void *, _DWORD))(*(_DWORD *)this + 12))(
            this,
            *(_DWORD *)(*((_DWORD *)this + 4) + 4 * i));
        *(_DWORD *)(*((_DWORD *)this + 4) + 4 * i) = 0;
      }
    }
  }
  if ( (*((_BYTE *)this + 20) & 4) == 0 )
    sub_1000BBF0(*((void **)this + 4));
  *((_DWORD *)this + 4) = 0;
  *((_DWORD *)this + 1) = 0;
  *((_DWORD *)this + 2) = 0;
  *((_DWORD *)this + 5) = 6;
}

//----- (10023E00) --------------------------------------------------------
_DWORD *__thiscall sub_10023E00(_DWORD *this)
{
  _DWORD *result; // eax

  result = this;
  *this = off_1003FDD8;
  this[2] = 0;
  this[1] = 0;
  return result;
}
// 1003FDD8: using guessed type int (__stdcall *off_1003FDD8[2])(int);

//----- (10023E20) --------------------------------------------------------
void __thiscall sub_10023E20(_DWORD *this)
{
  *this = off_1003FDD8;
}
// 1003FDD8: using guessed type int (__stdcall *off_1003FDD8[2])(int);

//----- (10023E30) --------------------------------------------------------
char __stdcall sub_10023E30(int a1)
{
  return 0;
}

//----- (10023E40) --------------------------------------------------------
_DWORD *__thiscall sub_10023E40(_DWORD *this)
{
  _DWORD *result; // eax

  result = this;
  this[2] = 0;
  this[1] = 0;
  *this = 0;
  this[3] = 0;
  return result;
}

//----- (10023E50) --------------------------------------------------------
int __thiscall sub_10023E50(_DWORD *this, int a2)
{
  int v2; // edx
  int result; // eax

  v2 = this[1];
  result = a2;
  if ( v2 )
  {
    *(_DWORD *)(a2 + 4) = v2;
    *(_DWORD *)(this[1] + 8) = a2;
    *(_DWORD *)(a2 + 8) = 0;
    this[1] = a2;
    this[2] = a2;
    ++this[3];
  }
  else
  {
    *(_DWORD *)(a2 + 4) = 0;
    *(_DWORD *)(a2 + 8) = 0;
    this[2] = a2;
    this[1] = a2;
    *this = a2;
    this[3] = 1;
  }
  return result;
}

//----- (10023E90) --------------------------------------------------------
int __thiscall sub_10023E90(int *this)
{
  int result; // eax

  result = *this;
  this[2] = *this;
  return result;
}

//----- (10023EA0) --------------------------------------------------------
int __thiscall sub_10023EA0(_DWORD *this)
{
  int v1; // eax
  int result; // eax

  v1 = this[2];
  if ( !v1 )
    return 0;
  result = *(_DWORD *)(v1 + 8);
  if ( !result )
    return 0;
  this[2] = result;
  return result;
}

//----- (10023EC0) --------------------------------------------------------
int __thiscall sub_10023EC0(_DWORD *this)
{
  int result; // eax

  result = 0;
  this[2] = 0;
  this[1] = 0;
  *this = 0;
  this[3] = 0;
  return result;
}

//----- (10023ED0) --------------------------------------------------------
int __thiscall sub_10023ED0(_DWORD *this, int a2)
{
  int result; // eax
  int v3; // edx
  int v4; // eax
  int v5; // edx
  int v6; // eax

  result = a2;
  this[2] = a2;
  if ( a2 )
  {
    v3 = *(_DWORD *)(a2 + 4);
    if ( v3 )
      *(_DWORD *)(v3 + 8) = *(_DWORD *)(a2 + 8);
    v4 = this[2];
    v5 = *(_DWORD *)(v4 + 8);
    if ( v5 )
      *(_DWORD *)(v5 + 4) = *(_DWORD *)(v4 + 4);
    v6 = this[2];
    if ( this[1] == v6 )
      this[1] = *(_DWORD *)(v6 + 4);
    if ( *this == v6 )
      *this = *(_DWORD *)(v6 + 8);
    result = *(_DWORD *)(v6 + 8);
    if ( !result )
      result = this[1];
    this[2] = result;
    --this[3];
  }
  return result;
}

//----- (10023F30) --------------------------------------------------------
void *__cdecl sub_10023F30(char *ArgList, void *Block, unsigned int *a3)
{
  __int16 v3; // bp
  signed int v4; // eax
  unsigned int v5; // edi
  void *v7; // ebx
  __int16 v8; // ax
  __int16 v9; // si

  v3 = 0;
  v4 = sub_1000E810(ArgList);
  v5 = v4;
  if ( v4 == -1 )
  {
    sub_1000C7C0("FILE_Load: LengthFile failed: '%s'.", ArgList);
    return 0;
  }
  v7 = Block;
  if ( !Block )
  {
    v7 = sub_1000BB40(v4);
    if ( !v7 )
    {
      sub_1000C6B0(0, 16, "FILE_Load: no memory.");
      return 0;
    }
    v3 = 1;
  }
  v8 = sub_1000E4F0(ArgList, 1);
  v9 = v8;
  if ( v8 == -1 )
  {
    if ( v3 )
      sub_1000BBF0(v7);
    sub_1000C7C0("FILE_Load: OpenFile failed: '%s'.", ArgList);
    return 0;
  }
  else if ( sub_1000E710(v8, v7, v5) == -1 )
  {
    if ( v3 )
      sub_1000BBF0(v7);
    sub_1000C7C0("FILE_Load: ReadFile failed: '%s'.", ArgList);
    return 0;
  }
  else
  {
    sub_1000E620(v9);
    if ( a3 )
      *a3 = v5;
    return v7;
  }
}
// 10023F30: using guessed type char *ArgList;

//----- (10024020) --------------------------------------------------------
unsigned int __cdecl sub_10024020(char *ArgList, void *Buf, unsigned int MaxCharCount)
{
  __int16 v3; // ax
  __int16 v4; // si

  v3 = sub_1000E4F0(ArgList, 8);
  v4 = v3;
  if ( v3 == -1 )
  {
    sub_1000C7C0("FILE_Save: BL_OpenFile failed: '%s'.", ArgList);
    return -1;
  }
  else if ( sub_1000E780(v3, Buf, MaxCharCount) == -1 )
  {
    sub_1000C6B0(0, 16, "FILE_Save: BL_WriteFile failed.");
    return -1;
  }
  else
  {
    sub_1000E620(v4);
    return MaxCharCount;
  }
}
// 10024020: using guessed type char *ArgList;

//----- (10024090) --------------------------------------------------------
char *__cdecl sub_10024090(const char *a1, const char *a2)
{
  __int16 v2; // cx
  __int16 v3; // kr00_2
  char *v4; // edx
  char *result; // eax
  const char *v6; // edx
  char v7; // cl

  v2 = strlen(a1);
  v3 = strlen(a2);
  v4 = (char *)&a1[v2];
  if ( *(v4 - 1) != 47 )
  {
    *v4 = 47;
    ++v2;
  }
  if ( v3 > 0 )
  {
    result = (char *)a2;
    v6 = &a1[v2 - (_DWORD)a2];
    do
    {
      v7 = *result;
      result[(_DWORD)v6] = *result;
      ++result;
    }
    while ( v7 );
  }
  else
  {
    result = (char *)v2;
    a1[v2] = 0;
  }
  return result;
}

//----- (10024100) --------------------------------------------------------
int __thiscall sub_10024100(_DWORD *this, int a2)
{
  if ( this[1] )
    JUMPOUT(0x1002410D);
  return -1;
}
// 10024105: control flows out of bounds to 1002410D

//----- (10024120) --------------------------------------------------------
int __thiscall sub_10024120(_DWORD **this, int a2)
{
  if ( this[1] )
    return (*(int (__thiscall **)(_DWORD *, int, _DWORD **))(*this[1] + 12))(this[1], a2, this);
  else
    return -1;
}

//----- (10024140) --------------------------------------------------------
int __thiscall sub_10024140(_DWORD **this, int a2)
{
  if ( this[1] )
    return (*(int (__thiscall **)(_DWORD *, int, _DWORD **))(*this[1] + 20))(this[1], a2, this);
  else
    return -1;
}

//----- (10024160) --------------------------------------------------------
int __thiscall sub_10024160(_DWORD *this, unsigned int a2)
{
  int v3; // ecx
  unsigned int v5; // edi

  v3 = this[1];
  if ( !v3 )
    return 0;
  if ( a2 == -1 )
  {
    this[2] = -1;
    this[3] = 0;
    return 1;
  }
  else if ( a2 < (*(int (__thiscall **)(int))(*(_DWORD *)v3 + 92))(v3) )
  {
    v5 = a2 + 1;
    while ( this[2] + 1 > v5 )
      (*(void (__thiscall **)(_DWORD, _DWORD *))(*(_DWORD *)this[1] + 120))(this[1], this);
    while ( this[2] + 1 < v5 )
      (*(void (__thiscall **)(_DWORD, _DWORD *))(*(_DWORD *)this[1] + 124))(this[1], this);
    return 1;
  }
  else
  {
    return 0;
  }
}

//----- (100241E0) --------------------------------------------------------
int __thiscall sub_100241E0(_DWORD **this)
{
  if ( this[1] )
    return (*(int (__thiscall **)(_DWORD *, _DWORD **))(*this[1] + 104))(this[1], this);
  else
    return 0;
}

//----- (10024200) --------------------------------------------------------
int __thiscall sub_10024200(_DWORD **this)
{
  if ( this[1] )
    return (*(int (__thiscall **)(_DWORD *))(*this[1] + 60))(this[1]);
  else
    return 0;
}

//----- (10024220) --------------------------------------------------------
int __thiscall sub_10024220(_DWORD **this)
{
  if ( this[1] )
    return (*(int (__thiscall **)(_DWORD *, _DWORD **))(*this[1] + 116))(this[1], this);
  else
    return 0;
}

//----- (10024240) --------------------------------------------------------
int __thiscall sub_10024240(_DWORD **this)
{
  if ( this[1] )
    return (*(int (__thiscall **)(_DWORD *, _DWORD **))(*this[1] + 64))(this[1], this);
  else
    return 0;
}

//----- (10024260) --------------------------------------------------------
int __thiscall sub_10024260(_DWORD *this)
{
  return this[2];
}

//----- (10024270) --------------------------------------------------------
int __thiscall sub_10024270(_DWORD **this)
{
  if ( this[1] )
    return (*(int (__thiscall **)(_DWORD *, _DWORD **))(*this[1] + 124))(this[1], this);
  else
    return 0;
}

//----- (10024290) --------------------------------------------------------
int __thiscall sub_10024290(_DWORD *this, _DWORD *a2)
{
  _DWORD *v3; // ecx

  v3 = (_DWORD *)this[1];
  if ( v3 != a2 )
    return 0;
  if ( v3 )
    sub_10025C60(v3, (int)this);
  this[1] = 0;
  this[2] = -1;
  this[3] = 0;
  return 1;
}

//----- (100242D0) --------------------------------------------------------
unsigned int __thiscall sub_100242D0(_DWORD *this, int a2)
{
  unsigned int result; // eax

  result = this[2] + 1;
  if ( result >= a2 + 1 )
    this[2] = result;
  return result;
}

//----- (100242F0) --------------------------------------------------------
unsigned int __thiscall sub_100242F0(_DWORD *this, int a2)
{
  unsigned int result; // eax

  result = this[2] + 1;
  if ( result > a2 + 1 )
    this[2] = result;
  return result;
}

//----- (10024310) --------------------------------------------------------
int __thiscall sub_10024310(_DWORD *this, int a2)
{
  int result; // eax

  result = this[2];
  if ( result + 1 <= (unsigned int)(a2 + 1) )
  {
    if ( result == a2 )
    {
      result = this[1];
      if ( result )
      {
        this[2] = -1;
        this[3] = 0;
      }
    }
  }
  else
  {
    this[2] = --result;
  }
  return result;
}

//----- (10024350) --------------------------------------------------------
_DWORD *__thiscall sub_10024350(_DWORD *this, _DWORD *a2)
{
  *this = &off_1003FEAC;
  this[4] = 0;
  this[5] = 0;
  this[2] = -1;
  this[3] = 0;
  this[1] = a2;
  if ( a2 )
    this[1] = sub_10025C30(a2, (int)this);
  this[3] = 0;
  this[2] = -1;
  return this;
}
// 1003FEAC: using guessed type void *off_1003FEAC;

//----- (100243A0) --------------------------------------------------------
int __thiscall sub_100243A0(_DWORD *this)
{
  _DWORD *v2; // ecx
  int result; // eax

  v2 = (_DWORD *)this[1];
  *this = &off_1003FEAC;
  if ( v2 )
    result = sub_10025C60(v2, (int)this);
  this[1] = 0;
  this[2] = -1;
  this[3] = 0;
  return result;
}
// 1003FEAC: using guessed type void *off_1003FEAC;

//----- (10024420) --------------------------------------------------------
int __thiscall sub_10024420(unsigned __int8 *this, char *Buffer)
{
  return sprintf(Buffer, "%.3d.%.3d.%.3d.%.3d", this[4], this[5], this[6], this[7]);
}

//----- (10024450) --------------------------------------------------------
void __thiscall sub_10024450(int this)
{
  if ( *(_DWORD *)this )
  {
    j__free(*(void **)this);
    *(_DWORD *)this = 0;
  }
  *(_DWORD *)(this + 4) = 0;
}

//----- (10024480) --------------------------------------------------------
void __thiscall sub_10024480(int this, char *Source, signed int Count)
{
  const char *v3; // ebx
  signed int v5; // ebp
  signed int v6; // eax
  void *v7; // eax
  void *v8; // edi

  v3 = Source;
  if ( Source )
  {
    v5 = Count;
    if ( Count != -1 )
      goto LABEL_5;
  }
  else
  {
    v3 = byte_1003D986;
  }
  v5 = strlen(v3) + 1;
LABEL_5:
  if ( *(_DWORD *)(this + 4) - v5 >= 0 && v3 )
    goto LABEL_10;
  if ( *(_DWORD *)this )
  {
    j__free(*(void **)this);
    *(_DWORD *)this = 0;
  }
  *(_DWORD *)(this + 4) = 0;
  if ( v3 )
  {
LABEL_10:
    v6 = *(_DWORD *)(this + 8);
    if ( v5 > v6 && v6 != -1 )
      v5 = *(_DWORD *)(this + 8);
    if ( !*(_DWORD *)this )
    {
      v7 = operator new(v5);
      *(_DWORD *)this = v7;
      if ( !v7 )
        sub_1000C7C0("error ocurred in mstring.cpp");
      v8 = *(void **)this;
      *(_DWORD *)(this + 4) = v5;
      memset(v8, 0, v5);
    }
    strncpy(*(char **)this, v3, v5);
    *(_BYTE *)(*(_DWORD *)this + v5 - 1) = 0;
  }
}

//----- (10024540) --------------------------------------------------------
char *__thiscall sub_10024540(int this, char *Source, unsigned int a3)
{
  char *result; // eax
  unsigned int v5; // esi
  char *v6; // ebx
  unsigned int v7; // ebp
  signed int v8; // eax
  signed int v9; // esi
  void *v10; // eax
  size_t v11; // eax

  result = Source;
  if ( Source )
  {
    v5 = a3;
    if ( a3 == -1 )
      v5 = strlen(Source) + 1;
    v6 = *(char **)this;
    if ( *(_DWORD *)this )
      v7 = strlen(*(const char **)this);
    else
      v7 = 0;
    v8 = *(_DWORD *)(this + 8);
    v9 = v7 + v5;
    if ( v9 > v8 && v8 != -1 )
      v9 = *(_DWORD *)(this + 8);
    if ( *(_DWORD *)(this + 4) - v9 < 0 )
    {
      v10 = operator new(v9);
      *(_DWORD *)this = v10;
      if ( !v10 )
        sub_1000C7C0("error ocurred in mstring.cpp");
      v11 = v7 + 1;
      *(_DWORD *)(this + 4) = v9;
      if ( (int)(v7 + 1) >= v9 )
        v11 = v9;
      strncpy(*(char **)this, v6, v11);
      *(_BYTE *)(*(_DWORD *)this + v9 - 1) = 0;
      if ( v6 )
        j__free(v6);
    }
    result = strncat(*(char **)this, Source, v9 - strlen(*(const char **)this));
    *(_BYTE *)(*(_DWORD *)this + v9 - 1) = 0;
  }
  return result;
}

//----- (10024620) --------------------------------------------------------
void *__thiscall sub_10024620(void *this, char *a2)
{
  sub_10024480((int)this, a2, -1);
  return this;
}

//----- (10024640) --------------------------------------------------------
void *__thiscall sub_10024640(void *this, char *a2)
{
  sub_10024540((int)this, a2, 0xFFFFFFFF);
  return this;
}

//----- (10024660) --------------------------------------------------------
_DWORD *__thiscall sub_10024660(_DWORD *this)
{
  *this = 0;
  this[1] = 0;
  this[2] = -1;
  sub_10024480((int)this, byte_1003D986, -1);
  return this;
}

//----- (10024690) --------------------------------------------------------
int __cdecl sub_10024690(_DWORD *a1, int a2, int a3)
{
  int v4; // ecx
  int v5; // esi
  int v6; // eax
  int v7; // ecx

  if ( !sub_1000E090(a1[5], 0xFFFFFFFF) )
    return -1;
  v4 = a1[2];
  v5 = v4 + 12 * a2;
  if ( a2 < 0 || a2 > a1[1] )
  {
    sub_1000E0E0(a1[5]);
    return -1;
  }
  else
  {
    v6 = *(_DWORD *)(v5 + 4);
    if ( v6 >= 0 )
      *(_DWORD *)(v4 + 12 * v6) = *(_DWORD *)v5;
    else
      a1[4] = *(_DWORD *)v5;
    v7 = *(_DWORD *)(v5 + 4);
    if ( *(int *)v5 >= 0 )
      *(_DWORD *)(a1[2] + 12 * *(_DWORD *)v5 + 4) = v7;
    else
      a1[3] = v7;
    --*a1;
    if ( a3 )
    {
      if ( *(_DWORD *)(v5 + 8) )
      {
        sub_1000BBF0(*(void **)(v5 + 8));
        *(_DWORD *)(v5 + 8) = 0;
      }
    }
    sub_1000E0E0(a1[5]);
    return 0;
  }
}

//----- (10024740) --------------------------------------------------------
int __cdecl sub_10024740(_DWORD *a1, int a2)
{
  int result; // eax

  result = 0;
  if ( a2 > a1[1] )
    return -1;
  if ( a2 >= 0 )
  {
    if ( !*(_DWORD *)(a1[2] + 12 * a2 + 8) )
      return -3;
  }
  else if ( a1[3] != -1 || a1[4] != -1 )
  {
    return -2;
  }
  return result;
}

//----- (10024790) --------------------------------------------------------
int __cdecl sub_10024790(_DWORD *a1)
{
  int v1; // ebx
  int v3; // ecx
  int v4; // esi
  _DWORD *v5; // eax

  v1 = 0;
  if ( !sub_1000E090(a1[5], 0xFFFFFFFF) )
    return -1;
  v3 = a1[1];
  v4 = 0;
  if ( v3 > 0 )
  {
    v5 = (_DWORD *)(a1[2] + 8);
    while ( *v5 )
    {
      ++v4;
      v5 += 3;
      if ( v4 >= v3 )
        goto LABEL_9;
    }
    v1 = 1;
  }
LABEL_9:
  sub_1000E0E0(a1[5]);
  if ( v1 )
    return v4;
  else
    return -1;
}

//----- (10024800) --------------------------------------------------------
_DWORD *__cdecl sub_10024800(int a1)
{
  _DWORD *result; // eax
  _DWORD *v2; // esi
  void *v3; // eax
  _DWORD *v4; // eax
  int v5; // eax
  int v6; // ecx

  result = sub_1000BB40(24);
  v2 = result;
  if ( result )
  {
    v3 = sub_1000BB40(12 * a1);
    v2[2] = v3;
    if ( !v3 )
      return 0;
    v4 = sub_1000E120(1);
    v2[5] = v4;
    if ( !v4 )
    {
      sub_1000BBF0((void *)v2[2]);
      sub_1000BBF0(v2);
      return 0;
    }
    v5 = 0;
    v2[1] = a1;
    *v2 = 0;
    v2[3] = -1;
    v2[4] = -1;
    if ( a1 > 0 )
    {
      v6 = 0;
      do
      {
        *(_DWORD *)(v2[2] + v6 + 8) = 0;
        ++v5;
        v6 += 12;
      }
      while ( v5 < v2[1] );
    }
    if ( sub_1000E0E0(v2[5]) == -1 )
      sub_1000C7C0("PL_Init: unlocking list mutex failed !");
    return v2;
  }
  return result;
}

//----- (100248C0) --------------------------------------------------------
int __cdecl sub_100248C0(void *Block, int a2)
{
  int v3; // ebx
  int v4; // edi
  int v5; // ecx
  HANDLE *v6; // edi

  if ( !sub_1000E090(*((_DWORD *)Block + 5), 0xFFFFFFFF) )
    return -1;
  v3 = 0;
  if ( *((int *)Block + 1) > 0 )
  {
    v4 = 0;
    do
    {
      v5 = *((_DWORD *)Block + 2);
      if ( *(_DWORD *)(v5 + v4 + 8) )
      {
        if ( a2 == 1 )
          sub_1000BBF0(*(void **)(v5 + v4 + 8));
      }
      ++v3;
      v4 += 12;
    }
    while ( v3 < *((_DWORD *)Block + 1) );
  }
  sub_1000BBF0(*((void **)Block + 2));
  v6 = (HANDLE *)*((_DWORD *)Block + 5);
  sub_1000BBF0(Block);
  sub_1000E0E0((int)v6);
  sub_1000E1E0(v6);
  return 0;
}

//----- (10024940) --------------------------------------------------------
int __cdecl sub_10024940(_DWORD *a1, int a2, int a3)
{
  int v3; // edi
  int *v5; // ecx
  int v6; // ebp
  int v7; // eax
  int v8; // edx
  int v9; // [esp-8h] [ebp-10h]

  v3 = sub_10024790(a1);
  if ( v3 == -1 || !sub_1000E090(a1[5], 0xFFFFFFFF) )
    return -1;
  if ( sub_10024740(a1, a2) )
  {
    sub_1000E0E0(a1[5]);
    return -1;
  }
  else
  {
    v5 = (int *)(a1[2] + 12 * v3);
    v5[2] = a3;
    if ( a2 >= 0 )
    {
      v6 = a1[2];
      v7 = 12 * a2;
      v8 = *(_DWORD *)(12 * a2 + v6 + 4);
      if ( v8 >= 0 )
      {
        *(_DWORD *)(v6 + 12 * v8) = v3;
        v5[1] = *(_DWORD *)(a1[2] + v7 + 4);
      }
      else
      {
        a1[4] = v3;
        v5[1] = -1;
      }
      *(_DWORD *)(a1[2] + v7 + 4) = v3;
      *v5 = a2;
    }
    else
    {
      a1[3] = v3;
      a1[4] = v3;
      *v5 = -1;
      v5[1] = -1;
    }
    v9 = a1[5];
    ++*a1;
    sub_1000E0E0(v9);
    return v3;
  }
}

//----- (10024A10) --------------------------------------------------------
int __cdecl sub_10024A10(void *Block)
{
  return sub_100248C0(Block, 1);
}

//----- (10024A20) --------------------------------------------------------
int __cdecl sub_10024A20(_DWORD *a1, int a2)
{
  return sub_10024940(a1, a1[4], a2);
}

//----- (10024A40) --------------------------------------------------------
_BYTE *__usercall sub_10024A40@<eax>(_BYTE *a1@<eax>)
{
  _BYTE *v1; // esi

  v1 = a1;
  if ( *a1 )
  {
    do
    {
      if ( isupper((char)*v1) )
        *v1 = tolower((char)*v1);
    }
    while ( *++v1 );
  }
  return a1;
}

//----- (10024A80) --------------------------------------------------------
const char *__usercall sub_10024A80@<eax>(const char *a1@<edi>)
{
  unsigned int v1; // eax
  const char *i; // esi

  v1 = strlen(a1);
  if ( !v1 )
    return a1;
  for ( i = &a1[v1 - 1]; i != a1; *i-- = 0 )
  {
    if ( !isspace(*i) )
      break;
  }
  return a1;
}

//----- (10024AC0) --------------------------------------------------------
_BYTE *__usercall sub_10024AC0@<eax>(_BYTE *a1@<eax>)
{
  _BYTE *v1; // esi
  char i; // al

  v1 = a1;
  for ( i = *a1; i; i = *++v1 )
  {
    if ( !isspace(i) )
      break;
  }
  return v1;
}

//----- (10024AF0) --------------------------------------------------------
char __usercall sub_10024AF0@<al>(_BYTE *a1@<eax>)
{
  _BYTE *v1; // esi
  char result; // al
  _BYTE *i; // edi

  v1 = a1;
  result = *a1;
  for ( i = v1; result; ++v1 )
  {
    if ( !strchr(" \t\n\r", result) )
      *i++ = *v1;
    result = v1[1];
  }
  *i = 0;
  return result;
}

//----- (10024B30) --------------------------------------------------------
int __cdecl sub_10024B30(int a1)
{
  return *(_DWORD *)a1;
}

//----- (10024B40) --------------------------------------------------------
_DWORD *__usercall sub_10024B40@<eax>(const char *a1@<edi>)
{
  _DWORD *v1; // ebx
  char *v2; // eax

  v1 = malloc(8u);
  if ( v1 )
  {
    v2 = (char *)malloc(strlen(a1) + 1);
    if ( v2 )
      strcpy(v2, a1);
    else
      v2 = 0;
    *v1 = v2;
    v1[1] = off_1004AE9C(1013, strcmp, off_1004AEB8, sub_10024B30);
  }
  return v1;
}
// 1004AE9C: using guessed type int (__cdecl *off_1004AE9C)(_DWORD, _DWORD, _DWORD, _DWORD);
// 1004AEB8: using guessed type void *off_1004AEB8;

//----- (10024BB0) --------------------------------------------------------
_DWORD *__usercall sub_10024BB0@<eax>(const char *a1@<ebx>, const char *a2@<edi>)
{
  _DWORD *v2; // ebp
  char *v3; // eax
  char *v4; // eax

  v2 = malloc(8u);
  if ( v2 )
  {
    v3 = (char *)malloc(strlen(a2) + 1);
    if ( v3 )
      strcpy(v3, a2);
    else
      v3 = 0;
    *v2 = v3;
    v4 = (char *)malloc(strlen(a1) + 1);
    if ( v4 )
    {
      strcpy(v4, a1);
      v2[1] = v4;
      return v2;
    }
    v2[1] = 0;
  }
  return v2;
}

//----- (10024C80) --------------------------------------------------------
void __cdecl sub_10024C80(void **Block)
{
  void *v1; // eax

  if ( Block )
  {
    if ( *Block )
      free(*Block);
    v1 = Block[1];
    if ( v1 )
      off_1004AEA0(v1, sub_10024C40);
    free(Block);
  }
}
// 10024C40: using guessed type int sub_10024C40();
// 1004AEA0: using guessed type int (__cdecl *off_1004AEA0)(_DWORD, _DWORD);

//----- (10024CC0) --------------------------------------------------------
int __cdecl sub_10024CC0(_DWORD *a1, char *FileName)
{
  FILE *v2; // eax
  FILE *v3; // ebx
  char *i; // ebp
  char *v5; // esi
  char v7; // al
  unsigned int v8; // eax
  int v9; // eax
  _DWORD *v10; // eax
  char *v11; // edi
  const char *v12; // edi
  _DWORD *v13; // eax
  int v15; // [esp+4h] [ebp-8h]
  FILE *v16; // [esp+8h] [ebp-4h]

  v2 = (FILE *)sub_10027490(FileName, (int)"r");
  v3 = v2;
  v16 = v2;
  if ( !v2 )
    return 0;
  v15 = 0;
  for ( i = (char *)sub_100260D0(v2); i; i = (char *)sub_100260D0(v3) )
  {
    v5 = i;
    if ( *i )
    {
      while ( isspace(*v5) )
      {
        if ( !*++v5 )
          goto LABEL_16;
      }
    }
    v7 = *v5;
    if ( *v5 && v7 != 59 )
    {
      if ( v7 == 91 )
      {
        sub_10024AF0(v5);
        v8 = strlen(v5);
        if ( v5[v8 - 1] == 93 )
        {
          v5[v8 - 1] = 0;
          sub_10024A40(v5 + 1);
          v9 = off_1004AEA8(*a1, v5 + 1);
          if ( !v9 )
          {
            v10 = sub_10024B40(v5 + 1);
            v9 = off_1004AEA4(*a1, v10);
          }
          v15 = v9;
        }
      }
      else
      {
        v11 = strchr(v5, 61);
        if ( v11 )
        {
          *v11 = 0;
          sub_10024AF0(v5);
          v12 = sub_10024AC0(v11 + 1);
          sub_10024A80(v12);
          v13 = sub_10024BB0(v12, v5);
          off_1004AEA4(*(_DWORD *)(v15 + 4), v13);
          v3 = v16;
        }
      }
    }
LABEL_16:
    free(i);
  }
  fclose(v3);
  return 1;
}
// 1004AEA4: using guessed type int (__cdecl *off_1004AEA4)(_DWORD, _DWORD);
// 1004AEA8: using guessed type int (__cdecl *off_1004AEA8)(_DWORD, _DWORD);

//----- (10024E20) --------------------------------------------------------
void __cdecl sub_10024E20(_DWORD *Block)
{
  if ( Block )
  {
    if ( *Block )
      off_1004AEA0(*Block, sub_10024C80);
    free(Block);
  }
}
// 1004AEA0: using guessed type int (__cdecl *off_1004AEA0)(_DWORD, _DWORD);

//----- (10024E50) --------------------------------------------------------
_DWORD *sub_10024E50()
{
  _DWORD *v0; // esi

  v0 = malloc(4u);
  if ( v0 )
    *v0 = off_1004AE9C(1013, strcmp, off_1004AEB8, sub_10024B30);
  return v0;
}
// 1004AE9C: using guessed type int (__cdecl *off_1004AE9C)(_DWORD, _DWORD, _DWORD, _DWORD);
// 1004AEB8: using guessed type void *off_1004AEB8;

//----- (10024E90) --------------------------------------------------------
_DWORD *__cdecl sub_10024E90(char *a1)
{
  _DWORD *v1; // esi

  v1 = malloc(4u);
  if ( !v1 )
    return v1;
  *v1 = off_1004AE9C(1013, strcmp, off_1004AEB8, sub_10024B30);
  if ( sub_10024CC0(v1, a1) )
    return v1;
  if ( *v1 )
    off_1004AEA0(*v1, sub_10024C80);
  free(v1);
  return 0;
}
// 1004AE9C: using guessed type int (__cdecl *off_1004AE9C)(_DWORD, _DWORD, _DWORD, _DWORD);
// 1004AEA0: using guessed type int (__cdecl *off_1004AEA0)(_DWORD, _DWORD);
// 1004AEB8: using guessed type void *off_1004AEB8;

//----- (10024F00) --------------------------------------------------------
int __cdecl sub_10024F00(_DWORD *a1, const char *a2, const char *a3)
{
  char *v3; // eax
  char *v4; // ebx
  char *v5; // eax
  char *v6; // esi
  int v7; // edi
  _BYTE *v8; // eax
  _BYTE *v9; // eax
  int v10; // eax
  int v11; // eax

  v3 = (char *)malloc(strlen(a2) + 1);
  if ( v3 )
  {
    strcpy(v3, a2);
    v4 = v3;
  }
  else
  {
    v4 = 0;
  }
  v5 = (char *)malloc(strlen(a3) + 1);
  if ( v5 )
  {
    strcpy(v5, a3);
    v6 = v5;
  }
  else
  {
    v6 = 0;
  }
  v7 = 0;
  v8 = sub_10024A40(v4);
  sub_10024AF0(v8);
  v9 = sub_10024A40(v6);
  sub_10024AF0(v9);
  v10 = off_1004AEA8(*a1, v4);
  if ( v10 )
  {
    v11 = off_1004AEA8(*(_DWORD *)(v10 + 4), v6);
    if ( v11 )
      v7 = *(_DWORD *)(v11 + 4);
  }
  free(v4);
  free(v6);
  return v7;
}
// 1004AEA8: using guessed type int (__cdecl *off_1004AEA8)(_DWORD, _DWORD);

//----- (10024FE0) --------------------------------------------------------
DNameNode *__thiscall sub_10024FE0(DNameNode *this)
{
  _DWORD *v2; // eax

  DNameNode::DNameNode(this);
  *(_DWORD *)this = &off_1003FF18;
  *((_DWORD *)this + 3) = 0;
  *((_DWORD *)this + 4) = 0;
  *((_DWORD *)this + 5) = 0;
  v2 = operator new(0x18u);
  if ( v2 )
    *((_DWORD *)this + 2) = sub_10024350(v2, this);
  else
    *((_DWORD *)this + 2) = 0;
  return this;
}
// 1003FF18: using guessed type void *off_1003FF18;

//----- (100250A0) --------------------------------------------------------
int __thiscall sub_100250A0(_DWORD *this, int a2)
{
  _DWORD *v3; // eax
  int v4; // ecx
  int result; // eax

  v3 = operator new(0xCu);
  if ( !v3 )
    return -1;
  *v3 = a2;
  v3[1] = 0;
  v3[2] = 0;
  v4 = this[4];
  if ( v4 )
  {
    v3[2] = v4;
    this[4] = v3;
    *(_DWORD *)(v3[2] + 4) = v3;
  }
  else
  {
    this[4] = v3;
    this[3] = v3;
  }
  sub_10025D10(this, this[5] - 1);
  result = this[5];
  this[5] = result + 1;
  return result;
}

//----- (10025100) --------------------------------------------------------
int __thiscall sub_10025100(_DWORD *this, int a2, unsigned int a3)
{
  _DWORD *v4; // ecx

  v4 = (_DWORD *)this[2];
  if ( v4 && sub_10024160(v4, a3) )
    return sub_10024120((_DWORD **)this[2], a2);
  else
    return -1;
}

//----- (10025130) --------------------------------------------------------
int __thiscall sub_10025130(_DWORD *this, int a2, unsigned int a3)
{
  _DWORD *v4; // ecx

  v4 = (_DWORD *)this[2];
  if ( v4 && sub_10024160(v4, a3) )
    return sub_10024140((_DWORD **)this[2], a2);
  else
    return -1;
}

//----- (10025160) --------------------------------------------------------
int __thiscall sub_10025160(_DWORD *this, int a2)
{
  _DWORD **v3; // ecx
  int v5; // edi
  _DWORD **v6; // ecx

  v3 = (_DWORD **)this[2];
  if ( !v3 )
    return 0;
  v5 = sub_10024240(v3);
  if ( !sub_10024220((_DWORD **)this[2]) )
    return 0;
  while ( 1 )
  {
    v6 = (_DWORD **)this[2];
    if ( v5 == a2 )
      break;
    v5 = sub_10024270(v6);
    if ( !sub_10024220((_DWORD **)this[2]) )
      return 0;
  }
  return sub_100241E0(v6);
}

//----- (100251C0) --------------------------------------------------------
int __thiscall sub_100251C0(_DWORD *this, int a2)
{
  _DWORD **v3; // ecx
  int v5; // edi
  _DWORD **v6; // ecx

  v3 = (_DWORD **)this[2];
  if ( !v3 )
    return -1;
  v5 = sub_10024240(v3);
  if ( !sub_10024220((_DWORD **)this[2]) )
    return -1;
  while ( 1 )
  {
    v6 = (_DWORD **)this[2];
    if ( v5 == a2 )
      break;
    v5 = sub_10024270(v6);
    if ( !sub_10024220((_DWORD **)this[2]) )
      return -1;
  }
  return sub_10024260(v6);
}

//----- (10025220) --------------------------------------------------------
int __thiscall sub_10025220(_DWORD *this)
{
  int v1; // eax

  v1 = this[3];
  if ( v1 )
    return *(_DWORD *)v1;
  else
    return 0;
}

//----- (10025230) --------------------------------------------------------
int __thiscall sub_10025230(_DWORD *this)
{
  int v1; // eax

  v1 = this[4];
  if ( v1 )
    return *(_DWORD *)v1;
  else
    return 0;
}

//----- (10025240) --------------------------------------------------------
int __thiscall sub_10025240(_DWORD *this)
{
  return this[5];
}

//----- (10025250) --------------------------------------------------------
int __thiscall sub_10025250(_DWORD *this, int a2, int a3)
{
  int *v5; // ebx
  int *v6; // ebp
  int v7; // edi
  _DWORD *v8; // eax
  int v9; // ecx

  if ( !a3 )
    return -1;
  v5 = (int *)sub_10025CA0(a3);
  v6 = (int *)sub_10025CC0(a3);
  if ( !v6 )
    return -1;
  if ( !v5 )
    return -1;
  v7 = *v5;
  if ( !*v5 )
    return -1;
  if ( v7 == this[3] )
    return (*(int (__thiscall **)(_DWORD *, int))(*this + 4))(this, a2);
  v8 = operator new(0xCu);
  if ( !v8 )
    return -1;
  *v8 = a2;
  v8[1] = 0;
  v8[2] = 0;
  v9 = *(_DWORD *)(v7 + 8);
  if ( v9 )
  {
    v8[2] = v9;
    *(_DWORD *)(*(_DWORD *)(v7 + 8) + 4) = v8;
  }
  v8[1] = v7;
  *(_DWORD *)(v7 + 8) = v8;
  ++this[5];
  sub_10025CE0(this, *v6);
  return *v6 - 1;
}

//----- (10025300) --------------------------------------------------------
int __thiscall sub_10025300(_DWORD *this, int a2, int a3)
{
  int *v5; // ebx
  int *v6; // ebp
  int v7; // edi
  _DWORD *v8; // eax
  int v9; // ecx

  if ( !a3 )
    return -1;
  v5 = (int *)sub_10025CA0(a3);
  v6 = (int *)sub_10025CC0(a3);
  if ( !v6 )
    return -1;
  if ( !v5 )
    return -1;
  v7 = *v5;
  if ( !*v5 )
    return -1;
  if ( v7 == this[4] )
    return (*(int (__thiscall **)(_DWORD *, int))(*this + 8))(this, a2);
  v8 = operator new(0xCu);
  if ( !v8 )
    return -1;
  *v8 = a2;
  v8[1] = 0;
  v8[2] = 0;
  v9 = *(_DWORD *)(v7 + 4);
  if ( v9 )
  {
    v8[1] = v9;
    *(_DWORD *)(*(_DWORD *)(v7 + 4) + 8) = v8;
  }
  v8[2] = v7;
  *(_DWORD *)(v7 + 4) = v8;
  ++this[5];
  sub_10025D10(this, *v6);
  return *v6 + 1;
}

//----- (100253B0) --------------------------------------------------------
int __stdcall sub_100253B0(int a1, int a2)
{
  _DWORD **v2; // eax
  _DWORD *v3; // eax
  int v4; // eax

  if ( !a2 )
    return -1;
  v2 = (_DWORD **)sub_10025CA0(a2);
  if ( v2 )
  {
    v3 = *v2;
    if ( v3 )
      *v3 = a1;
  }
  v4 = sub_10025CC0(a2);
  if ( v4 )
    return *(_DWORD *)v4;
  else
    return -1;
}

//----- (100253F0) --------------------------------------------------------
BOOL __thiscall sub_100253F0(_DWORD *this, int a2)
{
  unsigned int *v3; // eax
  unsigned int v4; // eax
  BOOL result; // eax

  result = 0;
  if ( a2 )
  {
    v3 = (unsigned int *)sub_10025CC0(a2);
    if ( v3 )
    {
      v4 = *v3;
      if ( v4 != -1 && v4 < this[5] )
        return 1;
    }
  }
  return result;
}

//----- (10025420) --------------------------------------------------------
int __thiscall sub_10025420(_DWORD *this, int a2)
{
  _DWORD *v4; // edi
  _DWORD *v5; // eax
  int v6; // ecx
  int v7; // esi

  if ( !a2 )
    return 0;
  v4 = (_DWORD *)sub_10025CA0(a2);
  v5 = (_DWORD *)sub_10025CC0(a2);
  if ( v4 && v5 && (v6 = this[3], *v4 = v6, *v5 = (v6 != 0) - 1, (v7 = this[3]) != 0) )
    return *(_DWORD *)v7;
  else
    return 0;
}

//----- (10025480) --------------------------------------------------------
int __thiscall sub_10025480(_DWORD *this, int a2)
{
  _DWORD *v4; // edi
  int *v5; // eax
  int v6; // ecx
  int v7; // ecx
  int v8; // esi

  if ( !a2 )
    return 0;
  v4 = (_DWORD *)sub_10025CA0(a2);
  v5 = (int *)sub_10025CC0(a2);
  if ( v4 && v5 && ((v6 = this[4], (*v4 = v6) == 0) ? (v7 = -1) : (v7 = this[5] - 1), *v5 = v7, (v8 = this[4]) != 0) )
    return *(_DWORD *)v8;
  else
    return 0;
}

//----- (100254E0) --------------------------------------------------------
int __thiscall sub_100254E0(_DWORD *this, int a2)
{
  int v4; // edi
  int *v5; // eax
  int v6; // ecx
  int v7; // ecx
  int v8; // esi
  int v9; // ecx
  int v10; // ecx
  int v11; // edi

  if ( !a2 )
    return 0;
  v4 = sub_10025CA0(a2);
  v5 = (int *)sub_10025CC0(a2);
  if ( v4 && v5 )
  {
    if ( *(_DWORD *)v4 )
    {
      v9 = *(_DWORD *)(*(_DWORD *)v4 + 8);
      *(_DWORD *)v4 = v9;
      if ( v9 )
        v10 = *v5 - 1;
      else
        v10 = -1;
      *v5 = v10;
      v11 = *(_DWORD *)v4;
      if ( v11 )
        return *(_DWORD *)v11;
    }
    else
    {
      v6 = this[4];
      *(_DWORD *)v4 = v6;
      if ( v6 )
        v7 = this[5] - 1;
      else
        v7 = -1;
      *v5 = v7;
      v8 = this[4];
      if ( v8 )
        return *(_DWORD *)v8;
    }
  }
  return 0;
}

//----- (10025560) --------------------------------------------------------
int __thiscall sub_10025560(_DWORD *this, int a2)
{
  int v4; // edi
  int *v5; // eax
  int v6; // ecx
  int v7; // esi
  int v8; // ecx
  int v9; // ecx
  int v10; // edi

  if ( !a2 )
    return 0;
  v4 = sub_10025CA0(a2);
  v5 = (int *)sub_10025CC0(a2);
  if ( v4 && v5 )
  {
    if ( *(_DWORD *)v4 )
    {
      v8 = *(_DWORD *)(*(_DWORD *)v4 + 4);
      *(_DWORD *)v4 = v8;
      if ( v8 )
        v9 = *v5 + 1;
      else
        v9 = -1;
      *v5 = v9;
      v10 = *(_DWORD *)v4;
      if ( v10 )
        return *(_DWORD *)v10;
    }
    else
    {
      v6 = this[3];
      *(_DWORD *)v4 = v6;
      *v5 = (v6 != 0) - 1;
      v7 = this[3];
      if ( v7 )
        return *(_DWORD *)v7;
    }
  }
  return 0;
}

//----- (100255E0) --------------------------------------------------------
int __stdcall sub_100255E0(int a1)
{
  int *v1; // eax
  int v2; // eax

  if ( a1 && (v1 = (int *)sub_10025CA0(a1)) != 0 && (v2 = *v1) != 0 )
    return *(_DWORD *)v2;
  else
    return 0;
}

//----- (10025610) --------------------------------------------------------
int __stdcall sub_10025610(int a1)
{
  int **v1; // eax
  int *v2; // eax
  int *v3; // ecx
  int v5; // edx

  if ( !a1 )
    return 0;
  v1 = (int **)sub_10025CA0(a1);
  if ( !v1 )
    return 0;
  v2 = *v1;
  if ( !v2 )
    return 0;
  v3 = (int *)v2[1];
  if ( !v3 )
    return 0;
  v5 = *v2;
  *v2 = *v3;
  *v3 = v5;
  return 1;
}

//----- (10025650) --------------------------------------------------------
int __stdcall sub_10025650(int a1)
{
  int **v1; // eax
  int *v2; // eax
  int *v3; // ecx
  int v5; // edx

  if ( !a1 )
    return 0;
  v1 = (int **)sub_10025CA0(a1);
  if ( !v1 )
    return 0;
  v2 = *v1;
  if ( !v2 )
    return 0;
  v3 = (int *)v2[2];
  if ( !v3 )
    return 0;
  v5 = *v2;
  *v2 = *v3;
  *v3 = v5;
  return 1;
}

//----- (10025690) --------------------------------------------------------
int __thiscall sub_10025690(_DWORD *this, _DWORD *Block)
{
  int result; // eax
  int v4; // ecx
  int v5; // ecx

  result = (int)Block;
  if ( Block )
  {
    if ( (_DWORD *)this[3] == Block )
      this[3] = Block[1];
    if ( (_DWORD *)this[4] == Block )
      this[4] = Block[2];
    v4 = Block[1];
    if ( v4 )
      *(_DWORD *)(v4 + 8) = Block[2];
    v5 = Block[2];
    if ( v5 )
      *(_DWORD *)(v5 + 4) = Block[1];
    j__free(Block);
    --this[5];
    return 1;
  }
  return result;
}

//----- (100256F0) --------------------------------------------------------
int __thiscall sub_100256F0(int *this, int a2, unsigned int a3)
{
  _DWORD *v4; // ecx
  _DWORD **v5; // eax
  _DWORD *v6; // eax

  v4 = (_DWORD *)this[2];
  if ( !v4 )
    return -1;
  if ( !sub_10024160(v4, a3) )
    return -1;
  v5 = (_DWORD **)sub_10025CA0(this[2]);
  if ( !v5 )
    return -1;
  v6 = *v5;
  if ( !v6 )
    return -1;
  *v6 = a2;
  return a3;
}

//----- (10025740) --------------------------------------------------------
int __thiscall sub_10025740(_DWORD *this, unsigned int a2)
{
  _DWORD *v3; // ecx
  _DWORD *v4; // edi
  _DWORD **v5; // eax

  v3 = (_DWORD *)this[2];
  v4 = 0;
  if ( !v3 || !sub_10024160(v3, a2) )
    return sub_10025690(this, v4);
  v5 = (_DWORD **)sub_10025CA0(this[2]);
  if ( v5 )
  {
    v4 = *v5;
    if ( *v5 )
      sub_10025D40(this, a2);
    return sub_10025690(this, v4);
  }
  return sub_10025690(this, 0);
}

//----- (100257A0) --------------------------------------------------------
int __thiscall sub_100257A0(_DWORD *this)
{
  if ( this[3] )
    sub_10025D40(this, 0);
  return sub_10025690(this, (_DWORD *)this[3]);
}

//----- (100257C0) --------------------------------------------------------
int __thiscall sub_100257C0(_DWORD *this)
{
  if ( this[4] )
    sub_10025D40(this, this[5] - 1);
  return sub_10025690(this, (_DWORD *)this[4]);
}

//----- (100257F0) --------------------------------------------------------
int __thiscall sub_100257F0(_DWORD *this, unsigned int a2)
{
  _DWORD *v3; // ecx
  int v4; // ebp
  int *v5; // eax
  int v6; // edi
  _DWORD *v7; // eax
  int v8; // ecx
  int v9; // ecx

  v3 = (_DWORD *)this[2];
  v4 = 0;
  if ( !v3 )
    return 0;
  if ( !sub_10024160(v3, a2) )
    return 0;
  v5 = (int *)sub_10025CA0(this[2]);
  if ( !v5 )
    return 0;
  v6 = *v5;
  if ( *v5 && *(_DWORD *)(v6 + 8) )
  {
    do
    {
      sub_10025D40(this, a2 - 1);
      v7 = *(_DWORD **)(v6 + 8);
      if ( v7 )
      {
        if ( (_DWORD *)this[3] == v7 )
          this[3] = v7[1];
        if ( (_DWORD *)this[4] == v7 )
          this[4] = v7[2];
        v8 = v7[1];
        if ( v8 )
          *(_DWORD *)(v8 + 8) = v7[2];
        v9 = v7[2];
        if ( v9 )
          *(_DWORD *)(v9 + 4) = v7[1];
        j__free(v7);
        --this[5];
      }
      ++v4;
    }
    while ( *(_DWORD *)(v6 + 8) );
  }
  return v4;
}

//----- (100258B0) --------------------------------------------------------
int __thiscall sub_100258B0(_DWORD *this, unsigned int a2)
{
  _DWORD *v3; // ecx
  int v4; // ebp
  int *v5; // eax
  int v6; // edi
  _DWORD *v7; // eax
  int v8; // ecx
  int v9; // ecx

  v3 = (_DWORD *)this[2];
  v4 = 0;
  if ( !v3 )
    return 0;
  if ( !sub_10024160(v3, a2) )
    return 0;
  v5 = (int *)sub_10025CA0(this[2]);
  if ( !v5 )
    return 0;
  v6 = *v5;
  if ( *v5 && *(_DWORD *)(v6 + 4) )
  {
    do
    {
      sub_10025D40(this, a2 + 1);
      v7 = *(_DWORD **)(v6 + 4);
      if ( v7 )
      {
        if ( (_DWORD *)this[3] == v7 )
          this[3] = v7[1];
        if ( (_DWORD *)this[4] == v7 )
          this[4] = v7[2];
        v8 = v7[1];
        if ( v8 )
          *(_DWORD *)(v8 + 8) = v7[2];
        v9 = v7[2];
        if ( v9 )
          *(_DWORD *)(v9 + 4) = v7[1];
        j__free(v7);
        --this[5];
      }
      ++v4;
    }
    while ( *(_DWORD *)(v6 + 4) );
  }
  return v4;
}

//----- (10025970) --------------------------------------------------------
int __thiscall sub_10025970(_DWORD *this)
{
  int i; // edi
  _DWORD *v3; // eax
  int v4; // ecx
  int v5; // ecx

  for ( i = 0; this[3]; ++i )
  {
    sub_10025D40(this, 0);
    v3 = (_DWORD *)this[3];
    if ( v3 )
    {
      this[3] = v3[1];
      if ( (_DWORD *)this[4] == v3 )
        this[4] = v3[2];
      v4 = v3[1];
      if ( v4 )
        *(_DWORD *)(v4 + 8) = v3[2];
      v5 = v3[2];
      if ( v5 )
        *(_DWORD *)(v5 + 4) = v3[1];
      j__free(v3);
      --this[5];
    }
  }
  return i;
}

//----- (100259E0) --------------------------------------------------------
int __thiscall sub_100259E0(int *this, unsigned int a2)
{
  _DWORD *v3; // ecx
  int *v4; // eax
  int v5; // eax

  v3 = (_DWORD *)this[2];
  if ( v3 && sub_10024160(v3, a2) && (v4 = (int *)sub_10025CA0(this[2])) != 0 && (v5 = *v4) != 0 )
    return *(_DWORD *)v5;
  else
    return 0;
}

//----- (10025A20) --------------------------------------------------------
int __thiscall sub_10025A20(_DWORD *this, int a2)
{
  _DWORD **v4; // edi
  int *v5; // eax
  _DWORD *v6; // edi

  if ( !a2 )
    return 0;
  v4 = (_DWORD **)sub_10025CA0(a2);
  v5 = (int *)sub_10025CC0(a2);
  if ( !v4 )
    return 0;
  v6 = *v4;
  if ( !v6 )
    return 0;
  if ( v5 )
    sub_10025D40(this, *v5);
  return sub_10025690(this, v6);
}

//----- (10025A80) --------------------------------------------------------
int __thiscall sub_10025A80(_DWORD *this, int a2)
{
  int *v4; // edi
  _DWORD *v5; // eax
  int v6; // edi

  if ( !a2 )
    return 0;
  v4 = (int *)sub_10025CA0(a2);
  v5 = (_DWORD *)sub_10025CC0(a2);
  if ( !v4 )
    return 0;
  v6 = *v4;
  if ( !v6 )
    return 0;
  if ( v5 )
    sub_10025D40(this, *v5 - 1);
  return sub_10025690(this, *(_DWORD **)(v6 + 8));
}

//----- (10025AE0) --------------------------------------------------------
int __thiscall sub_10025AE0(_DWORD *this, int a2)
{
  int *v4; // edi
  _DWORD *v5; // eax
  int v6; // edi

  if ( !a2 )
    return 0;
  v4 = (int *)sub_10025CA0(a2);
  v5 = (_DWORD *)sub_10025CC0(a2);
  if ( !v4 )
    return 0;
  v6 = *v4;
  if ( !v6 )
    return 0;
  if ( v5 )
    sub_10025D40(this, *v5 - 1);
  return sub_10025690(this, *(_DWORD **)(v6 + 4));
}

//----- (10025B40) --------------------------------------------------------
int __thiscall sub_10025B40(_DWORD *this)
{
  void (__thiscall ***v2)(_DWORD, int); // ecx

  *this = &off_1003FF18;
  sub_10025970(this);
  v2 = (void (__thiscall ***)(_DWORD, int))this[2];
  if ( v2 )
  {
    (**v2)(v2, 1);
    this[2] = 0;
  }
  return sub_10025C00(this);
}
// 1003FF18: using guessed type void *off_1003FF18;

//----- (10025B70) --------------------------------------------------------
_DWORD *__thiscall sub_10025B70(_DWORD *Block, char a2)
{
  void (__thiscall ***v3)(_DWORD, int); // ecx

  *Block = &off_1003FF18;
  sub_10025970(Block);
  v3 = (void (__thiscall ***)(_DWORD, int))Block[2];
  if ( v3 )
  {
    (**v3)(v3, 1);
    Block[2] = 0;
  }
  sub_10025C00(Block);
  if ( (a2 & 1) != 0 )
    j__free(Block);
  return Block;
}
// 1003FF18: using guessed type void *off_1003FF18;

//----- (10025BC0) --------------------------------------------------------
int __stdcall sub_10025BC0(int a1)
{
  return -1;
}

//----- (10025BD0) --------------------------------------------------------
int __stdcall sub_10025BD0(int a1, int a2)
{
  return -1;
}

//----- (10025BE0) --------------------------------------------------------
int sub_10025BE0()
{
  return 0;
}

//----- (10025BF0) --------------------------------------------------------
int __stdcall sub_10025BF0(int a1)
{
  return 0;
}

//----- (10025C00) --------------------------------------------------------
int __thiscall sub_10025C00(_DWORD *this)
{
  int result; // eax

  result = this[1];
  for ( *this = off_1003FFA0; result; result = this[1] )
  {
    result = sub_10024290((_DWORD *)this[1], this);
    if ( !result )
      break;
  }
  return result;
}
// 1003FFA0: using guessed type int (__stdcall *off_1003FFA0[3])(int);

//----- (10025C30) --------------------------------------------------------
_DWORD *__thiscall sub_10025C30(_DWORD *this, int a2)
{
  _DWORD *result; // eax
  int v3; // edx

  result = this;
  if ( !a2 )
    return 0;
  v3 = this[1];
  if ( v3 )
  {
    *(_DWORD *)(a2 + 20) = v3;
    *(_DWORD *)(this[1] + 16) = a2;
  }
  this[1] = a2;
  return result;
}

//----- (10025C60) --------------------------------------------------------
int __thiscall sub_10025C60(_DWORD *this, int a2)
{
  int result; // eax
  int v3; // ecx
  int v4; // ecx

  result = a2;
  if ( a2 )
  {
    if ( a2 == this[1] )
      this[1] = *(_DWORD *)(a2 + 20);
    v3 = *(_DWORD *)(a2 + 20);
    if ( v3 )
      *(_DWORD *)(v3 + 16) = *(_DWORD *)(a2 + 16);
    v4 = *(_DWORD *)(a2 + 16);
    if ( v4 )
      *(_DWORD *)(v4 + 20) = *(_DWORD *)(a2 + 20);
    *(_DWORD *)(a2 + 16) = 0;
    *(_DWORD *)(a2 + 20) = 0;
  }
  return result;
}

//----- (10025CA0) --------------------------------------------------------
int __stdcall sub_10025CA0(int a1)
{
  if ( a1 )
    return a1 + 12;
  else
    return 0;
}

//----- (10025CC0) --------------------------------------------------------
int __stdcall sub_10025CC0(int a1)
{
  if ( a1 )
    return a1 + 8;
  else
    return 0;
}

//----- (10025CE0) --------------------------------------------------------
unsigned int __thiscall sub_10025CE0(_DWORD *this, int a2)
{
  _DWORD *i; // esi
  unsigned int result; // eax

  for ( i = (_DWORD *)this[1]; i; i = (_DWORD *)i[5] )
    result = sub_100242D0(i, a2);
  return result;
}

//----- (10025D10) --------------------------------------------------------
unsigned int __thiscall sub_10025D10(_DWORD *this, int a2)
{
  _DWORD *i; // esi
  unsigned int result; // eax

  for ( i = (_DWORD *)this[1]; i; i = (_DWORD *)i[5] )
    result = sub_100242F0(i, a2);
  return result;
}

//----- (10025D40) --------------------------------------------------------
int __thiscall sub_10025D40(_DWORD *this, int a2)
{
  _DWORD *i; // esi
  int result; // eax

  for ( i = (_DWORD *)this[1]; i; i = (_DWORD *)i[5] )
    result = sub_10024310(i, a2);
  return result;
}

//----- (10025D70) --------------------------------------------------------
_DWORD *__thiscall sub_10025D70(_DWORD *Block, char a2)
{
  int v3; // eax

  v3 = Block[1];
  *Block = off_1003FFA0;
  if ( v3 )
  {
    while ( sub_10024290((_DWORD *)Block[1], Block) && Block[1] )
      ;
  }
  if ( (a2 & 1) != 0 )
    j__free(Block);
  return Block;
}
// 1003FFA0: using guessed type int (__stdcall *off_1003FFA0[3])(int);

//----- (10025DB0) --------------------------------------------------------
_DWORD *__cdecl sub_10025DB0(unsigned int a1, int a2, int a3, int a4)
{
  _DWORD *v4; // esi
  void *v5; // eax
  unsigned int i; // eax

  v4 = malloc(0x14u);
  if ( !v4 )
    nullsub_1(
      "libtools ENSURE: `%s', %s - line %d",
      "hp",
      "\\Projects\\libs\\phase2\\source\\common\\scfg\\hashtom.c",
      54);
  *v4 = a2;
  v4[4] = a1;
  v4[1] = a4;
  v4[2] = a3;
  v5 = malloc(4 * a1);
  v4[3] = v5;
  if ( !v5 )
    nullsub_1(
      "libtools ENSURE: `%s', %s - line %d",
      "hp->h_slots",
      "\\Projects\\libs\\phase2\\source\\common\\scfg\\hashtom.c",
      66);
  for ( i = 0; i < a1; ++i )
    *(_DWORD *)(v4[3] + 4 * i) = 0;
  return v4;
}
// 100261F0: using guessed type int nullsub_1(const char *, ...);

//----- (10025E50) --------------------------------------------------------
void __cdecl sub_10025E50(void *Block, int a2)
{
  unsigned int i; // esi
  int v3; // eax

  for ( i = 0; i < *((_DWORD *)Block + 4); ++i )
  {
    v3 = *(_DWORD *)(*((_DWORD *)Block + 3) + 4 * i);
    if ( v3 )
      off_1004AED4(v3, a2);
  }
  free(*((void **)Block + 3));
  free(Block);
}
// 1004AED4: using guessed type int (__cdecl *off_1004AED4)(_DWORD, _DWORD);

//----- (10025EA0) --------------------------------------------------------
int __cdecl sub_10025EA0(int a1, int a2)
{
  int v2; // eax
  unsigned int v3; // edi
  int v4; // eax

  v2 = (*(int (__cdecl **)(int))(a1 + 4))(a2);
  v3 = (unsigned int)(*(int (__cdecl **)(int))(a1 + 8))(v2) % *(_DWORD *)(a1 + 16);
  v4 = *(_DWORD *)(*(_DWORD *)(a1 + 12) + 4 * v3);
  if ( !v4 )
  {
    *(_DWORD *)(*(_DWORD *)(a1 + 12) + 4 * v3) = off_1004AED0();
    v4 = *(_DWORD *)(*(_DWORD *)(a1 + 12) + 4 * v3);
  }
  return off_1004AEE4(v4, a2);
}
// 1004AED0: using guessed type int (*off_1004AED0)(void);
// 1004AEE4: using guessed type int (__cdecl *off_1004AEE4)(_DWORD, _DWORD);

//----- (10025EF0) --------------------------------------------------------
int __cdecl sub_10025EF0(int a1, int a2)
{
  int v3; // ebx
  int v4; // edi
  int v5; // ebp
  int v6; // eax
  int v8; // [esp+14h] [ebp+4h]

  v3 = *(_DWORD *)(*(_DWORD *)(a1 + 12)
                 + 4 * ((unsigned int)(*(int (__cdecl **)(int))(a1 + 8))(a2) % *(_DWORD *)(a1 + 16)));
  if ( !v3 )
    return 0;
  v4 = 0;
  v8 = off_1004AF00(v3);
  if ( v8 <= 0 )
    return 0;
  while ( 1 )
  {
    v5 = off_1004AED8(v3, v4);
    v6 = (*(int (__cdecl **)(int))(a1 + 4))(v5);
    if ( !(*(int (__cdecl **)(int, int))a1)(a2, v6) )
      break;
    if ( ++v4 >= v8 )
      return 0;
  }
  return v5;
}
// 1004AED8: using guessed type int (__cdecl *off_1004AED8)(_DWORD, _DWORD);
// 1004AF00: using guessed type int (__cdecl *off_1004AF00)(_DWORD);

//----- (10025F60) --------------------------------------------------------
int __cdecl sub_10025F60(int a1, int a2)
{
  unsigned int v3; // edx
  int v4; // eax
  int v5; // ebx
  int v6; // edi
  int v7; // eax
  int v8; // eax
  int v10; // [esp+14h] [ebp+4h]

  v3 = (unsigned int)(*(int (__cdecl **)(int))(a1 + 8))(a2) % *(_DWORD *)(a1 + 16);
  v4 = *(_DWORD *)(a1 + 12);
  v5 = *(_DWORD *)(v4 + 4 * v3);
  if ( !v5 )
    return 0;
  v6 = 0;
  v10 = off_1004AF00(*(_DWORD *)(v4 + 4 * v3));
  if ( v10 <= 0 )
    return 0;
  while ( 1 )
  {
    v7 = off_1004AED8(v5, v6);
    v8 = (*(int (__cdecl **)(int))(a1 + 4))(v7);
    if ( !(*(int (__cdecl **)(int, int))a1)(a2, v8) )
      break;
    if ( ++v6 >= v10 )
      return 0;
  }
  return off_1004AEEC(v5, v6);
}
// 1004AED8: using guessed type int (__cdecl *off_1004AED8)(_DWORD, _DWORD);
// 1004AEEC: using guessed type int (__cdecl *off_1004AEEC)(_DWORD, _DWORD);
// 1004AF00: using guessed type int (__cdecl *off_1004AF00)(_DWORD);

//----- (10025FD0) --------------------------------------------------------
unsigned int __cdecl sub_10025FD0(int a1, void (__cdecl *a2)(int, int, int), int a3)
{
  unsigned int result; // eax
  int v4; // ecx
  int v5; // edi
  int v6; // ebx
  int j; // esi
  int v8; // eax
  unsigned int i; // [esp+4h] [ebp-4h]

  result = 0;
  for ( i = 0; i < *(_DWORD *)(a1 + 16); ++i )
  {
    v4 = *(_DWORD *)(a1 + 12);
    v5 = *(_DWORD *)(v4 + 4 * result);
    if ( v5 )
    {
      v6 = off_1004AF00(*(_DWORD *)(v4 + 4 * result));
      for ( j = 0; j < v6; ++j )
      {
        v8 = off_1004AED8(v5, j);
        a2(a1, v8, a3);
      }
    }
    result = i + 1;
  }
  return result;
}
// 1004AED8: using guessed type int (__cdecl *off_1004AED8)(_DWORD, _DWORD);
// 1004AF00: using guessed type int (__cdecl *off_1004AF00)(_DWORD);

//----- (10026040) --------------------------------------------------------
int __cdecl sub_10026040(int a1, int a2, int a3)
{
  int v3; // eax

  v3 = (*(int (__cdecl **)(int))(a1 + 4))(a2);
  return off_1004AEE4(a3, v3);
}
// 1004AEE4: using guessed type int (__cdecl *off_1004AEE4)(_DWORD, _DWORD);

//----- (10026060) --------------------------------------------------------
int __cdecl sub_10026060(int a1)
{
  int v1; // esi

  v1 = off_1004AED0();
  if ( v1 )
    sub_10025FD0(a1, (void (__cdecl *)(int, int, int))sub_10026040, v1);
  return v1;
}
// 1004AED0: using guessed type int (*off_1004AED0)(void);

//----- (100260C0) --------------------------------------------------------
int __cdecl sub_100260C0(int a1)
{
  return a1;
}

//----- (100260D0) --------------------------------------------------------
void *__cdecl sub_100260D0(FILE *Stream)
{
  void *v1; // esi
  int v2; // ebp
  int v3; // ebx
  size_t v4; // edi
  void *v5; // eax
  void *v6; // eax
  size_t v8; // [esp-8h] [ebp-14h]
  int v9; // [esp+8h] [ebp-4h]

  v1 = 0;
  v2 = 0;
  v9 = 0;
  if ( (Stream->_flag & 0x30) == 0 )
  {
    v3 = fgetc(Stream);
    if ( v3 == -1 )
      goto LABEL_14;
    v4 = 64;
    do
    {
      if ( v3 == 10 )
        break;
      if ( v2 == v9 )
      {
        if ( v1 )
          v5 = realloc(v1, v4);
        else
          v5 = malloc(v4);
        v1 = v5;
        if ( !v5 )
          nullsub_1(
            "libtools ENSURE: `%s', %s - line %d",
            "newbuf",
            "\\Projects\\libs\\phase2\\source\\common\\scfg\\getline.c",
            33);
        v9 += 64;
        v4 += 64;
      }
      *((_BYTE *)v1 + v2++) = v3;
      v3 = fgetc(Stream);
    }
    while ( v3 != -1 );
    if ( v2 == v9 )
    {
LABEL_14:
      v8 = v9 + 64;
      if ( v1 )
        v6 = realloc(v1, v8);
      else
        v6 = malloc(v8);
      v1 = v6;
      if ( !v6 )
        nullsub_1(
          "libtools ENSURE: `%s', %s - line %d",
          "newbuf",
          "\\Projects\\libs\\phase2\\source\\common\\scfg\\getline.c",
          34);
    }
    *((_BYTE *)v1 + v2) = 0;
  }
  return v1;
}
// 100261F0: using guessed type int nullsub_1(const char *, ...);

//----- (100261C0) --------------------------------------------------------
void __cdecl __noreturn sub_100261C0(int a1, int a2)
{
  sub_1002BCF8(&Stream, a1, a2);
  fputc(10, &Stream);
  abort();
}

//----- (10026200) --------------------------------------------------------
int __usercall sub_10026200@<eax>(int *a1@<esi>)
{
  void *v1; // eax
  void *v2; // eax
  int v3; // edi
  void *v4; // ebx
  int result; // eax

  v1 = (void *)a1[2];
  if ( v1 )
  {
    v3 = 2 * a1[1];
    v4 = realloc(v1, 8 * a1[1]);
    if ( !v4 )
      nullsub_1(
        "libtools ENSURE: `%s', %s - line %d",
        "newmem",
        "\\Projects\\libs\\phase2\\source\\common\\scfg\\pset.c",
        74);
    a1[1] = v3;
    a1[2] = (int)v4;
  }
  else
  {
    v2 = malloc(0x80u);
    a1[2] = (int)v2;
    if ( !v2 )
      nullsub_1(
        "libtools ENSURE: `%s', %s - line %d",
        "ps->pointers",
        "\\Projects\\libs\\phase2\\source\\common\\scfg\\pset.c",
        67);
    a1[1] = 32;
  }
  for ( result = *a1; result < a1[1]; ++result )
    *(_DWORD *)(a1[2] + 4 * result) = 0;
  return result;
}
// 100261F0: using guessed type int nullsub_1(const char *, ...);

//----- (100262A0) --------------------------------------------------------
_DWORD *sub_100262A0()
{
  _DWORD *v0; // esi

  v0 = malloc(0xCu);
  if ( !v0 )
    nullsub_1(
      "libtools ENSURE: `%s', %s - line %d",
      "ps",
      "\\Projects\\libs\\phase2\\source\\common\\scfg\\pset.c",
      106);
  v0[1] = 0;
  *v0 = 0;
  v0[2] = 0;
  return v0;
}
// 100261F0: using guessed type int nullsub_1(const char *, ...);

//----- (100262F0) --------------------------------------------------------
void __cdecl sub_100262F0(void *Block, void (__cdecl *a2)(_DWORD))
{
  int i; // edi

  if ( Block )
  {
    if ( *((_DWORD *)Block + 2) )
    {
      if ( a2 )
      {
        for ( i = 0; i < *(_DWORD *)Block; ++i )
        {
          if ( *(_DWORD *)(*((_DWORD *)Block + 2) + 4 * i) )
            a2(*(_DWORD *)(*((_DWORD *)Block + 2) + 4 * i));
        }
      }
      free(*((void **)Block + 2));
    }
    free(Block);
  }
}

//----- (10026350) --------------------------------------------------------
int __cdecl sub_10026350(int *a1, int a2)
{
  if ( a2 >= 0 && a2 < *a1 )
    return *(_DWORD *)(a1[2] + 4 * a2);
  nullsub_1(
    "libtools ENSURE: `%s', %s - line %d",
    "i >= 0 && i < ps->used",
    "\\Projects\\libs\\phase2\\source\\common\\scfg\\pset.c",
    149);
  return *(_DWORD *)(a1[2] + 4 * a2);
}
// 100261F0: using guessed type int nullsub_1(const char *, ...);

//----- (10026390) --------------------------------------------------------
int __cdecl sub_10026390(int *a1, int a2, int a3)
{
  int result; // eax

  if ( a3 < 0 || a3 >= *a1 )
    nullsub_1(
      "libtools ENSURE: `%s', %s - line %d",
      "i >= 0 && i < ps->used",
      "\\Projects\\libs\\phase2\\source\\common\\scfg\\pset.c",
      160);
  result = a2;
  *(_DWORD *)(a1[2] + 4 * a3) = a2;
  return result;
}
// 100261F0: using guessed type int nullsub_1(const char *, ...);

//----- (100263D0) --------------------------------------------------------
int __cdecl sub_100263D0(int *a1, int a2, int a3)
{
  int i; // eax
  _DWORD *v4; // ecx
  int v5; // ecx
  int result; // eax

  if ( a3 < 0 || a3 > *a1 )
    nullsub_1(
      "libtools ENSURE: `%s', %s - line %d",
      "i >= 0 && i <= ps->used",
      "\\Projects\\libs\\phase2\\source\\common\\scfg\\pset.c",
      174);
  if ( *a1 == a1[1] )
    sub_10026200(a1);
  if ( *a1 == a1[1] )
    nullsub_1(
      "libtools ENSURE: `%s', %s - line %d",
      "!_is_full(ps)",
      "\\Projects\\libs\\phase2\\source\\common\\scfg\\pset.c",
      177);
  for ( i = *a1; i > a3; *v4 = *(v4 - 1) )
    v4 = (_DWORD *)(a1[2] + 4 * i--);
  v5 = a1[2];
  ++*a1;
  result = a2;
  *(_DWORD *)(v5 + 4 * a3) = a2;
  return result;
}
// 100261F0: using guessed type int nullsub_1(const char *, ...);

//----- (10026460) --------------------------------------------------------
int __cdecl sub_10026460(int *a1, int a2)
{
  return sub_100263D0(a1, a2, *a1);
}

//----- (10026480) --------------------------------------------------------
int __cdecl sub_10026480(int *a1, int a2)
{
  int result; // eax
  _DWORD *i; // ecx

  result = 0;
  if ( *a1 <= 0 )
    return -1;
  for ( i = (_DWORD *)a1[2]; a2 != *i; ++i )
  {
    if ( ++result >= *a1 )
      return -1;
  }
  return result;
}

//----- (100264B0) --------------------------------------------------------
int __cdecl sub_100264B0(int *a1, int (__cdecl *a2)(_DWORD, int), int a3)
{
  int v3; // esi

  v3 = 0;
  if ( *a1 <= 0 )
    return -1;
  while ( a2(*(_DWORD *)(a1[2] + 4 * v3), a3) )
  {
    if ( ++v3 >= *a1 )
      return -1;
  }
  return v3;
}

//----- (100264F0) --------------------------------------------------------
int __cdecl sub_100264F0(int *a1, int a2)
{
  int result; // eax
  int i; // ecx

  if ( a2 < 0 || a2 >= *a1 )
    nullsub_1(
      "libtools ENSURE: `%s', %s - line %d",
      "i >= 0 && i < ps->used",
      "\\Projects\\libs\\phase2\\source\\common\\scfg\\pset.c",
      267);
  result = *(_DWORD *)(a1[2] + 4 * a2);
  for ( i = a2; i < *a1 - 1; ++i )
    *(_DWORD *)(a1[2] + 4 * i) = *(_DWORD *)(a1[2] + 4 * i + 4);
  --*a1;
  return result;
}
// 100261F0: using guessed type int nullsub_1(const char *, ...);

//----- (10026550) --------------------------------------------------------
int __cdecl sub_10026550(int *a1, int a2)
{
  int v2; // eax
  _DWORD *i; // ecx

  v2 = 0;
  if ( *a1 <= 0 )
    return 0;
  for ( i = (_DWORD *)a1[2]; a2 != *i; ++i )
  {
    if ( ++v2 >= *a1 )
      return 0;
  }
  if ( v2 < 0 )
    return 0;
  else
    return sub_100264F0(a1, v2);
}

//----- (10026590) --------------------------------------------------------
int __cdecl sub_10026590(int *a1, int (__cdecl *a2)(_DWORD, int), int a3)
{
  int v3; // eax

  v3 = sub_100264B0(a1, a2, a3);
  if ( v3 < 0 )
    return 0;
  else
    return sub_100264F0(a1, v3);
}

//----- (100265C0) --------------------------------------------------------
int __cdecl sub_100265C0(int a1, _CoreCrtNonSecureSearchSortCompareFunction CompareFunction)
{
  qsort(*(void **)(a1 + 8), *(_DWORD *)a1, 4u, CompareFunction);
  return a1;
}

//----- (100265E0) --------------------------------------------------------
int *__cdecl sub_100265E0(int *a1, int *a2, int (__cdecl *a3)(_DWORD, int))
{
  int *v3; // esi
  int v4; // ebp
  int v5; // ebx
  int v6; // esi
  int v8; // [esp+8h] [ebp-4h]

  v3 = a2;
  v4 = 0;
  v8 = *a2;
  if ( *a2 <= 0 )
    return a1;
  while ( 1 )
  {
    if ( v4 < 0 || v4 >= *v3 )
      nullsub_1(
        "libtools ENSURE: `%s', %s - line %d",
        "i >= 0 && i < ps->used",
        "\\Projects\\libs\\phase2\\source\\common\\scfg\\pset.c",
        149);
    v5 = *(_DWORD *)(v3[2] + 4 * v4);
    v6 = 0;
    if ( *a1 <= 0 )
      goto LABEL_12;
    while ( a3(*(_DWORD *)(a1[2] + 4 * v6), v5) )
    {
      if ( ++v6 >= *a1 )
        goto LABEL_12;
    }
    if ( v6 < 0 )
LABEL_12:
      sub_100263D0(a1, v5, *a1);
    if ( ++v4 >= v8 )
      return a1;
    v3 = a2;
  }
}
// 100261F0: using guessed type int nullsub_1(const char *, ...);

//----- (10026680) --------------------------------------------------------
int __cdecl sub_10026680(_DWORD *a1, int (__cdecl *a2)(_DWORD, int), int a3)
{
  int v3; // edi
  int v4; // ebx
  int v5; // esi
  int v6; // eax

  v3 = *a1 - 1;
  v4 = 0;
  if ( v3 < 0 )
    return -1;
  while ( 1 )
  {
    v5 = (v4 + v3) / 2;
    v6 = a2(*(_DWORD *)(a1[2] + 4 * v5), a3);
    if ( !v6 )
      break;
    if ( v6 >= 0 )
      v3 = v5 - 1;
    else
      v4 = v5 + 1;
    if ( v3 < v4 )
      return -1;
  }
  return (v4 + v3) / 2;
}

//----- (100266E0) --------------------------------------------------------
int *__cdecl sub_100266E0(const char *a1, char a2)
{
  int *v2; // edi
  char *v3; // ebp
  char *i; // eax
  unsigned int v5; // kr04_4
  const char *v6; // esi
  char *v7; // edx
  char Delimiter[4]; // [esp+Ch] [ebp-4h] BYREF

  v2 = (int *)malloc(0xCu);
  if ( !v2 )
    nullsub_1(
      "libtools ENSURE: `%s', %s - line %d",
      "ps",
      "\\Projects\\libs\\phase2\\source\\common\\scfg\\pset.c",
      106);
  v2[1] = 0;
  *v2 = 0;
  v2[2] = 0;
  v3 = (char *)malloc(strlen(a1) + 1);
  strcpy(v3, a1);
  Delimiter[1] = 0;
  Delimiter[0] = a2;
  for ( i = strtok(v3, Delimiter); i; i = strtok(0, Delimiter) )
  {
    v5 = strlen(i);
    v6 = i;
    v7 = (char *)malloc(v5 + 1);
    strcpy(v7, v6);
    sub_100263D0(v2, (int)v7, *v2);
  }
  free(v3);
  return v2;
}
// 100261F0: using guessed type int nullsub_1(const char *, ...);

//----- (1002740A) --------------------------------------------------------
int __cdecl sub_1002740A(LPCSTR lpFileName)
{
  DWORD LastError; // eax

  if ( DeleteFileA(lpFileName) )
    LastError = 0;
  else
    LastError = GetLastError();
  if ( !LastError )
    return 0;
  _dosmaperr(LastError);
  return -1;
}
// 100269C6: using guessed type _DWORD __cdecl _dosmaperr(_DWORD);

//----- (10027434) --------------------------------------------------------
int __cdecl sub_10027434(char *FileName, int a2, int ShareFlag)
{
  int v3; // eax
  int v5; // [esp+Ch] [ebp-20h]
  FILE *Stream; // [esp+10h] [ebp-1Ch]

  v3 = _getstream();
  Stream = (FILE *)v3;
  if ( v3 )
  {
    v5 = _openfile(FileName, a2, ShareFlag, v3);
    _unlock_file(Stream);
    return v5;
  }
  else
  {
    *_errno() = 24;
    return 0;
  }
}
// 1002FF79: using guessed type int _getstream(void);

//----- (10027490) --------------------------------------------------------
int __cdecl sub_10027490(char *FileName, int a2)
{
  return sub_10027434(FileName, a2, 64);
}

//----- (10027637) --------------------------------------------------------
int __cdecl sub_10027637(LPCSTR lpExistingFileName, LPCSTR lpNewFileName)
{
  DWORD LastError; // eax

  if ( MoveFileA(lpExistingFileName, lpNewFileName) )
    LastError = 0;
  else
    LastError = GetLastError();
  if ( !LastError )
    return 0;
  _dosmaperr(LastError);
  return -1;
}
// 100269C6: using guessed type _DWORD __cdecl _dosmaperr(_DWORD);

//----- (10028174) --------------------------------------------------------
int __cdecl sub_10028174(WORD CharType)
{
  void *v1; // eax

  v1 = *(void **)(_getptd() + 100);
  if ( v1 != off_1004B4BC )
    LOBYTE(v1) = __updatetlocinfo();
  return __toupper_mt((CHAR)v1, CharType);
}
// 1002A3FB: using guessed type int __updatetlocinfo(void);
// 1002C7E4: using guessed type int _getptd(void);

//----- (100289DB) --------------------------------------------------------
int __cdecl sub_100289DB(FILE *Stream, int a2, int a3)
{
  int v4; // [esp+Ch] [ebp-1Ch]

  _lock_file(Stream);
  v4 = _input(Stream, a2, (int)&a3);
  _unlock_file(Stream);
  return v4;
}

//----- (10028C0F) --------------------------------------------------------
size_t __cdecl sub_10028C0F(void *Buffer, size_t ElementSize, size_t ElementCount, FILE *Stream)
{
  size_t v5; // [esp+Ch] [ebp-1Ch]

  _lock_file(Stream);
  v5 = fread(Buffer, ElementSize, ElementCount, Stream);
  _unlock_file(Stream);
  return v5;
}

//----- (10028D62) --------------------------------------------------------
size_t __cdecl sub_10028D62(void *Buffer, size_t ElementSize, size_t ElementCount, FILE *Stream)
{
  size_t v5; // [esp+Ch] [ebp-1Ch]

  _lock_file(Stream);
  v5 = fwrite(Buffer, ElementSize, ElementCount, Stream);
  _unlock_file(Stream);
  return v5;
}

//----- (10029237) --------------------------------------------------------
int sub_10029237()
{
  return flsall((FILE *)1);
}

//----- (10029240) --------------------------------------------------------
intptr_t __cdecl sub_10029240(char *a1)
{
  char *v1; // eax
  intptr_t v3; // edi
  char *Arguments[4]; // [esp+4h] [ebp-10h] BYREF

  v1 = sub_10029363("COMSPEC");
  Arguments[0] = v1;
  if ( a1 )
  {
    Arguments[1] = "/c";
    Arguments[2] = a1;
    Arguments[3] = 0;
    if ( !v1
      || (v3 = _spawnve(0, v1, (const char *const *)Arguments, 0), v3 == -1) && (*_errno() == 2 || *_errno() == 13) )
    {
      Arguments[0] = "command.com";
      if ( (dword_1004D090 & 0x8000) == 0 )
        Arguments[0] = "cmd.exe";
      return _spawnvpe(0, Arguments[0], (const char *const *)Arguments, 0);
    }
    else
    {
      return v3;
    }
  }
  else
  {
    return v1 && _access(v1, 0) == 0;
  }
}
// 1004D090: using guessed type int dword_1004D090;

//----- (10029363) --------------------------------------------------------
char *__cdecl sub_10029363(char *VarName)
{
  char *v2; // [esp+Ch] [ebp-1Ch]

  _lock(7);
  v2 = getenv(VarName);
  _unlock(7);
  return v2;
}
// 1002EC2F: using guessed type _DWORD __cdecl _unlock(_DWORD);
// 1002ECE4: using guessed type _DWORD __cdecl _lock(_DWORD);

//----- (1002A0FE) --------------------------------------------------------
int sub_1002A0FE()
{
  return _make_time_t(1);
}
// 10029F3E: using guessed type _DWORD __cdecl _make_time_t(_DWORD);

//----- (1002BCF8) --------------------------------------------------------
int __cdecl sub_1002BCF8(FILE *Stream, int a2, int a3)
{
  int v4; // [esp+Ch] [ebp-24h]
  int v5; // [esp+14h] [ebp-1Ch]

  _lock_file(Stream);
  v5 = _stbuf(Stream);
  v4 = _output(Stream, a2, a3);
  _ftbuf(v5, Stream);
  _unlock_file(Stream);
  return v4;
}
// 1002F853: using guessed type _DWORD __cdecl _stbuf(_DWORD);
// 1002F8DB: using guessed type _DWORD __cdecl _ftbuf(_DWORD, _DWORD);

//----- (1002E55D) --------------------------------------------------------
void sub_1002E55D()
{
  void (**i)(void); // [esp+Ch] [ebp-1Ch]

  for ( i = dword_100462CC; i < dword_100462CC; ++i )
  {
    if ( *i )
      (*i)();
  }
}
// 100462CC: using guessed type void (*dword_100462CC[2])(void);

//----- (1002E5A1) --------------------------------------------------------
void __cdecl sub_1002E5A1()
{
  void (**i)(void); // [esp+Ch] [ebp-1Ch]

  for ( i = &dword_100462D4; i < &dword_100462D4; ++i )
  {
    if ( *i )
      (*i)();
  }
}
// 100462D4: using guessed type void (*dword_100462D4)(void);

//----- (10037DE9) --------------------------------------------------------
int __cdecl sub_10037DE9(int a1, int a2)
{
  return _ld12cvt(a1, a2, &unk_1004BF78);
}
// 10037C91: using guessed type _DWORD __cdecl _ld12cvt(_DWORD, _DWORD, _DWORD);

//----- (10037DFF) --------------------------------------------------------
int __cdecl sub_10037DFF(int a1, int a2)
{
  return _ld12cvt(a1, a2, &unk_1004BF90);
}
// 10037C91: using guessed type _DWORD __cdecl _ld12cvt(_DWORD, _DWORD, _DWORD);

//----- (10037E15) --------------------------------------------------------
int __cdecl sub_10037E15(int a1, int a2)
{
  char v3[4]; // [esp+0h] [ebp-14h] BYREF
  char v4[12]; // [esp+4h] [ebp-10h] BYREF

  __strgtold12(v4, v3, a2, 0, 0, 0, 0);
  return sub_10037DE9((int)v4, a1);
}
// 1003819D: using guessed type _DWORD __cdecl __strgtold12(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 10037E15: using guessed type char var_14[4];

//----- (10037E52) --------------------------------------------------------
int __cdecl sub_10037E52(int a1, int a2)
{
  char v3[4]; // [esp+0h] [ebp-14h] BYREF
  char v4[12]; // [esp+4h] [ebp-10h] BYREF

  __strgtold12(v4, v3, a2, 0, 0, 0, 0);
  return sub_10037DFF((int)v4, a1);
}
// 1003819D: using guessed type _DWORD __cdecl __strgtold12(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 10037E52: using guessed type char var_14[4];

//----- (10038C34) --------------------------------------------------------
int sub_10038C34()
{
  return 0;
}

//----- (1003A73A) --------------------------------------------------------
int __cdecl sub_1003A73A(LPCSTR lpPathName)
{
  DWORD LastError; // eax

  if ( CreateDirectoryA(lpPathName, 0) )
    LastError = 0;
  else
    LastError = GetLastError();
  if ( !LastError )
    return 0;
  _dosmaperr(LastError);
  return -1;
}
// 100269C6: using guessed type _DWORD __cdecl _dosmaperr(_DWORD);

//----- (1003A770) --------------------------------------------------------
int sub_1003A770()
{
  sub_10022750((int)&unk_1004CB58);
  return atexit(nullsub_4);
}

// nfuncs=1561 queued=1081 decompiled=1081 lumina nreq=0 worse=0 better=0
// ALL OK, 1081 function(s) have been successfully decompiled

